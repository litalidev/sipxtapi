//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////
#ifndef _PLUGIN_H_
#define _PLUGIN_H_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlString.h"
class OsConfigDb;

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class Plugin;

/**
 * A Plugin is a dynamically loaded object that is invoked by some component at some
 *   well defined time (it's an abstract class - how specific can the
 *   description be?).
 *
 * This class is the abstract base from which all plugins must inherit; it
 * decouples the configuration of what plugins should be invoked and the
 * configuration parameters specific to each plugin from the program that
 * uses them.
 *
 * @htmlinclude PluginOverview.html
 *
 * All Plugin classes must implement three methods to configure the plugin
 * into the component:
 * - An extern "C" factory routine
 * - The constructor for its class, which must ultimately derive from Plugin
 * - The readConfig method used to pass configuration data to the plugin (this decouples plugin
 *   configuration from the component configuration).
 *
 * Each class derived from Plugin should also define the method(s) that
 * the program should invoke on the plugin, and all those methods must be virtual.
 *
 * @see PluginHooks for details of how a plugin is configured into a program,
 * and PluginIterator for how plugins are invoked by the calling component.
 *
 */
class Plugin
{
  public:

   typedef Plugin* (*Factory)(const UtlString& pluginName);
   /**<
    * The Factory uses external C linkage to support dynamic loading of Plugin objects.
    *
    * In addition to the class derived from this base, a plugin must implement a
    * Factory routine with extern "C" linkage so that the OsSharedLib mechanism
    * can look it up in the dynamically loaded library (looking up C++ symbols
    * is problematic because of name mangling).  The Factory routine looks like:
    * @code
    * class ExamplePlugin;
    *
    * extern "C" ExamplePlugin* getExamplePlugin(const UtlString& name)
    * {
    *   return new ExamplePlugin;
    * }
    *
    * class ExamplePlugin : public Plugin
    * {
    *    friend ExamplePlugin* getExamplePlugin(const UtlString& name);
    *   ...
    * private:
    *    ExamplePlugin(const UtlString& name);
    * }
    * @endcode
    */

   /// The plugin destructor must be virtual.
   virtual ~Plugin()
      {
      };

   /// Read (or re-read) whatever configuration the plugin requires.
   virtual void readConfig( OsConfigDb& configDb /**< a subhash of the individual configuration
                                                  * parameters for this instance of this plugin. */
                           ) = 0;
   /**<
    * @note
    * The parent service may call the readConfig method at any time to
    * indicate that the configuration may have changed.  The plugin
    * should reinitialize itself based on the configuration that exists when
    * this is called.  The fact that it is a subhash means that whatever prefix
    * is used to identify the plugin (see PluginHooks) has been removed (see the
    * examples in PluginHooks::readConfig).
    */

  protected:

   /// Derived constructors should be private so that only the Factory can call them.
   Plugin(const UtlString& instanceName) :
      mInstanceName(instanceName)
      {
      };

   /// The instance name from the configuration directive - for logging and other identification.
   UtlString   mInstanceName;
    
  private:

   /// There is no copy constructor.
   Plugin(const Plugin&);

   /// There is no assignment operator.
   Plugin& operator=(const Plugin&);
    
};

#endif // _PLUGIN_H_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _PLUGINHOOKS_H_
#define _PLUGINHOOKS_H_

// SYSTEM INCLUDES
#include "utl/UtlSortedList.h"
#include "utl/UtlSortedListIterator.h"

// APPLICATION INCLUDES
// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class Plugin;
class PluginIterator;
class OsConfigDb;

/**
 * A PluginHooks object is used to add dynamically loaded libraries (a "plugin") to a program
 * at run time.  The module to be loaded must implement a class derived from
 * the Plugin abstract class.
 *
 * An object of this class manages all the configured plugin hooks for a program.
 * A class of plugin hooks is identified by a factory routine name used to obtain
 * a hook instance from the dynamic library, and an OsConfigDb prefix string:
 * @code
 * PluginHooks ActionEventHooks("getFooAction", ACTION_EVENT"); // to be called for each Action
 * @endcode
 *
 * The libraries are loaded and configured by the readConfig method:
 * @code
 * ActionEventHooks.readConfig(configDb); 
 * @endcode
 *
 * To invoke the plugins, see PluginIterator.
 */
class PluginHooks
{
  public:
   /// Construct a manager for a set of hooks.
   PluginHooks(const char* hookFactoryName, ///< the prefix name for the OsConfigDb values
               const char* hookPrefix       ///< the prefix name for the OsConfigDb values
               
               );

   ~PluginHooks();

   /// Read what hooks are configured, and instantiate and configure each hook.
   void readConfig( OsConfigDb& configDb );
   /**<
    * This method actually reads the program configuration from the configDb passed in.
    * Each entry that has the prefix followed by "_HOOK_LIBRARY" configures a plugin library.
    * @code
    * [prefix]_HOOK_LIBRARY.[instance] : [path to libexamplereghook.so]
    * @endcode
    * for the example code above, it would look for entries like:
    * @code
    * ACTION_EVENT_HOOK_LIBRARY.RecordAction : /usr/local/lib/sipxpbx/librecordaction.so
    * ACTION_EVENT_HOOK_LIBRARY.CopyAction   : /usr/local/lib/sipxpbx/libcopyaction.so
    * @endcode
    * The readConfig method:
    * - dynamically loads each library 
    * - for each value of [instance]
    *   - calls the factory method provided by the hook to instantiate a hook object,
    *     passing its instance name to it (so that it can be used in logging).
    *   - passes the new hook object a configuration subhash of its configuration
    *     entries (if any).
    *
    * Configuration entries for each hook instance are made with entries like:
    * @code
    * [prefix].[instance].FOO : foovalue
    * [prefix].[instance].BAR : barvalue
    * @endcode
    * Each instance has its own set of configuration entries:
    * @code
    * ACTION_EVENT.RecordAction.FOO : foovalue1
    * ACTION_EVENT.RecordAction.BAR : barvalue1
    * ACTION_EVENT.CopyAction.FOO : foovalue2
    * ACTION_EVENT.CopyAction.BAR : barvalue2
    * @endcode
    *
    * The readConfig method in the hook (which must inherit from Plugin) is passed
    * its own subhash of the configuration data, stripping everything through the '.'
    * following the instance name, so in the example above, the CopyAction hook would
    * be passed the equivalent of this configuration:
    * @code
    * FOO : foovalue2
    * BAR : barvalue2
    * @endcode
    *
    * readConfig can be called more than once.
    * - New plugin instances are instantiated as described above.
    * - Existing plugin instances that are no longer in the configuration
    *   are deleted (their destructor is invoked).
    * - Existing plugin instances that are still in the configuration
    *   are reconfigured (their Plugin::readConfig method is called).
    *
    */

   /**
    * Return the total number of plugins within.
    */
   size_t entries() const;

  protected:
   friend class PluginIterator;

   UtlString      mFactory;         ///< the factory routine name for this hook class
   UtlString      mPrefix;          ///< the prefix name for the OsConfigDb values
   UtlSortedList  mConfiguredHooks; ///< the list of configured hooks.
};

/**
 * PluginIterator is used to obtain a sequence of Plugin objects to be invoked.
 *
 * The calling program gets the plugin objects by creating a PluginIterator
 * over a Plugin object and then calling the PluginIterator::next method to
 * get each instance of the Plugin (and optionally, its instance name).
 *
 * The PluginIterator always returns the configured Plugin objects in lexical
 * order by the instance name; this allows the configuration to control the
 * order in which they are invoked.
 *
 * Plugin libraries can implement any calling interface that's needed (a 
 * program that uses the Plugin mechanism should create a base class that extends
 * Plugin to specify the interface).
 *
 * A typical usage would look like:
 * @code
 * PluginIterator actions(ActionEventHooks);
 * YourPluginClass* action;
 * while(action = static_cast<YourPluginClass*>(actions.next()))
 * {
 *   action->invokeMethod();
 * }
 * @endcode
 */
class PluginIterator
{
  public:
   /// Create an iterator that returns each instance managed by a PluginHooks object.
   PluginIterator( const PluginHooks& pluginHooks );

   ~PluginIterator();
   
   /// Advance to and return the next plugin.
   Plugin* next(UtlString* name = NULL /**< the instance name string for the returned
                                            *   Plugin (for logging purposes)
                                            *   may be NULL if the caller does not need the name.
                                            */
                    );
   /**<
    * No meaning should be attached to Plugin names, so that order of plugin
    * iteration can be controlled by the lexical order of plugin names.
    */

  private:
   UtlSortedListIterator mConfiguredHooksIterator;
   
};

#endif // _PLUGINHOOKS_H_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _UTLBOOL_H_
#define _UTLBOOL_H_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlContainable.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * UtlBool is a UtlContainable wrapper for a bool.
 */
class UtlBool : public UtlContainable
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    static const UtlContainableType TYPE ;    /** < Class type used for runtime checking */ 

/* ============================ CREATORS ================================== */

    /**
     * Constructor
     */
    UtlBool(bool bValue) ;
      
    /**
     * Destructor
     */
    virtual ~UtlBool();

/* ============================ MANIPULATORS ============================== */

    /**
     * Set a new bool value for this object.
     *
     */
    void setValue(bool bValue) ;

/* ============================ ACCESSORS ================================= */

    /**
     * Get the bool wrapped by this object.
     */
    bool getValue() const ;    

    /**
     * Calculate a unique hash code for this object.  If the equals
     * operator returns true for another object, then both of those
     * objects must return the same hashcode.
     */
    virtual unsigned hash() const ;

    /**
     * Get the ContainableType for a UtlContainable derived class.
     */
    virtual UtlContainableType getContainableType() const;
         
/* ============================ INQUIRY =================================== */

    /**
     * Compare the this object to another like-objects.  Results for 
     * designating a non-like object are undefined.
     *
     * @returns 0 if equal, < 0 if less then and >0 if greater.
     */
    virtual int compareTo(UtlContainable const *) const ;    


/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    bool mValue ;    /** < The bool wrapped by this object */ 

} ;

/* ============================ INLINE METHODS ============================ */

#endif    // _UTLBOOL_H_
//
// Copyright (C) 2004-2007 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2007 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef UtlChainPool_h__
#define UtlChainPool_h__

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlLink.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// FORWARD DECLARATIONS
// STRUCTS
// TYPEDEFS

/// Pool of available objects derived from UtlChain.
/**
 * This avoids excessive heap operations; rather than delete unused UtlChains, they are
 * stored on the mPool here.  To limit the heap overhead associated with allocating
 * UtlChain, they are allocated in mBlockSize blocks, which are chained on
 * mBlocks.
 *
 * The actual allocation of the blocks and initial chaining is done by the allocator
 * function supplied by the UtlChain subclass.
 */
class UtlChainPool
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
   friend class UtlLink;
   friend class UtlPair;
   friend class UtlInit;

   /// Allocate blocksize instances of the subclass and chain them into the pool. 
   typedef void allocator(size_t    blocksize, ///< number of instances to allocate
      UtlChain* blockList, ///< list header for first instance
      UtlChain* pool       ///< list header for others
      );
   /**<
    * This function is supplied by the subclass to the UtlChainPool constructor.
    * It is responsible for allocating a block of blocksize instances of its subclass.
    * The first instance in each block is added to the blockList, so that the UtlChainPool
    * destructor can delete the block.  The remaining (blocksize-1) instances are
    * chained onto the pool list header.
    */

   /// Create a UtlChainPool that uses blockAllocator to create UtlChain derived objects.
   UtlChainPool(allocator* blockAllocator, size_t blockSize);

   /// Get a UtlLink with chain pointers NULL
   UtlChain* get();

   /// Return freeLink to the pool of available UtlLinks.
   void release(UtlChain* freeChain);

   /// Returns the total number of subclasses instances allocated by this pool.
   /**
    * The returned count does not include the 1 instance in each allocation that is
    * consumed to manage the pool.
    */
   size_t totalAllocated()
   {
      return mAllocations * (mBlockSize-1); // one per block is overhead
   }

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

   /// Release all dynamic memory used by the UtlLinkPool.
   ~UtlChainPool();

   OsBSem        mLock; ///< lock for all the other member variables
   size_t        mBlockSize;
   size_t        mAllocations;
   allocator*    mAllocator;
   UtlChain      mPool;     ///< list of available UtlLinks.
   UtlChain      mBlocks;   /**< list of memory blocks allocated by the mAllocator.
                             *   Each block is an mBlockSize array of objects derived from
                             *   UtlChain. The 0th element is used to form the linked list
                             *   of blocks.  The rest are made a part of the mPool.*/
};


#endif // UtlChainPool_h__
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _UtlContainable_h_
#define _UtlContainable_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * An UtlContainable object is an abstract object that serves as the base 
 * class for anything that can be contained in one of the UtlContainer- 
 * derived classes.  One of the largest values of a UtlContainable-derived 
 * object is the ability for any UtlContainer to destroy objects, sort 
 * objects, etc.
 */
class UtlContainable 
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    static const UtlContainableType TYPE ;    /** < Class type used for runtime checking */

/* ============================ CREATORS ================================== */

    /**
     * Destructor
     */
    virtual ~UtlContainable();

    /**
     * Get the ContainableType for a UtlContainable-derived class.
     */
    virtual UtlContainableType getContainableType() const = 0 ;

    /// Calculate a hash code for this object.
    virtual unsigned hash() const = 0 ;
    /**<
     * The hash method should return a value that is a function of the key used to
     * locate the object.  As much as possible, hash values should be uniformly
     * distributed over the range of legal unsigned values.
     * 
     * \par Requirements
     * if A.isEqual(B) then A.hash() must == B.hash()
     */

    /// Provides a hash function that uses the object pointer as the hash value.
    unsigned directHash() const;
    /**<
     * This may be used by any UtlContainable class for which generating a value hash
     * is difficult or not meaningful.  Note that pointer values, since they are not
     * uniformly distributed, probably make poor hash codes so this should not be used
     * normally.  @see stringHash
     *
     * To use this, define your hash function as just:<pre>
     * unsigned int Foo::hash() const
     * {
     * return directHash();
     * }
     * </pre>
     *
     * If you use directHash as the hash method, you probably want to
     * use pointer comparison as the compareTo method:<pre>
     * int Foo::compareTo(UtlContainable const* inVal) const
     * {
     *    int result ; 
     * 
     *    result =
     *       this > other ? 1 :
     *       this < other ? -1 :
     *       0;
     *
     *    return result;
     * }
     * </pre>
     */
    
    /// Provides a hash function appropriate for null-terminated string values.
    static unsigned stringHash(char const* value);
    /**<
     * To use this, define your hash function as just:<pre>
     * Foo hash()
     * {
     * return stringHash(value);
     * }
     * </pre>
     */

    /// Compare this object to another object. 
    virtual int compareTo(UtlContainable const *) const = 0  ;    
    /**<
     * Results of comparison to an object not of the same UtlContainableType
     * may be undefined.
     *
     * @returns 0 if equal, < 0 if less then and >0 if greater.
     *
     * \par Requirements
     * - if A.compareTo(B) == 0 then B.compareTo(A) must be == 0
     * - if A.compareTo(B) < 0 then B.compareTo(A) must be > 0
     * - if A.compareTo(B) > 0 then B.compareTo(A) must be < 0
     * - if A.compareTo(B) < 0 and B.compareTo(C) < 0 then A.compareTo(C) must be < 0
     * etc.
     * 
     * Results for comparing with a non-like object are undefined,
     * other than that it must return non-equal.
     * Note that a copy of an object might not compare equal to the
     * original, unless the definition of its type requires it.
     */

    /// Test this object to another object for equality.
    virtual UtlBoolean isEqual(UtlContainable const *) const;
    /**<
     * Results for objects not of the same UtlContainableType may be undefined.
     *
     * A default implementation of this is provided that should be adequate for any
     * UtlContainableType.
     */

    /// Determine if this object is of the specified UtlContainableType.
    virtual UtlBoolean isInstanceOf(const UtlContainableType type) const ; 
    /**<
     * Determine if this object is an instance of the designated runtime
     * class identifer.  For example:
     * <pre>
     * if (pMyObject->isInstanceOf(UtlInt::TYPE))
     * {
     *     ...
     * }
     * </pre>
     */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
        
} ;

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlContainable_h_
//
// Copyright (C) 2004, 2005 Pingtel Corp.
// 
//
// $$
////////////////////////////////////////////////////////////////////////
//////

#ifndef _UtlContainableAtomic_h_
#define _UtlContainableAtomic_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlContainable.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * UtlContainableAtomic is a virtual subclass of UtlContainable that
 * is suitable as a base class for objects that need to be
 * containable, but are not otherwise "data items" that can be
 * compared.
 * A notable feature is that any two UtlContainableAtomic objects are
 * considered equal only if they are the same (their pointers are equal).
 * Comparison between objects in UtlContainableAtomic and its subclasses
 * provides a consistent (albeit arbitrary) linear ordering.
 *
 * A subclass of UtlContainableAtomic only needs to define
 * subclass::getContainableType() and subclass::TYPE, the remaining
 * necessary methods can be inherited from UtlContainableAtomic.
 */
class UtlContainableAtomic : public UtlContainable
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

    /// Calculate a hash code for this object.
    virtual unsigned hash() const;
    /**<
     * Returns a hash of the pointer to the object.
     */

    /// Compare this object to another object. 
    virtual int compareTo(UtlContainable const *) const;
    /**<
     * For all members of subclasses of UtlContainableAtomic,
     * compareTo provides a consistent linear ordering.
     * A copy of an object is never equal to the original.
     */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
        
} ;

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlContainableAtomic_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlContainer_h_
#define _UtlContainer_h_

// SYSTEM INCLUDES
#include <stdlib.h> 

// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlLink.h"
#include "utl/UtlContainable.h"
#include "utl/UtlIterator.h"
#include "os/OsBSem.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * UtlContainer defines and abstract container designed to hold UtlContainable 
 * derived objects.
 */
class UtlContainer : public UtlContainable
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    static const UtlContainableType TYPE ;    /** < Class type used for runtime checking */ 

/* ============================ CREATORS ================================== */
   
    /**
     * Default Constructor
     */
    UtlContainer();

    /**
     * Destructor
     */
    virtual ~UtlContainer(); 

/* ============================ MANIPULATORS ============================== */

    /**
     * Inserts the designated containable object into the list
     * 
     * @return the object if successful, otherwise null
     */
    virtual UtlContainable* insert(UtlContainable* obj) = 0 ;

    /**
     * Removes the designated objects from the list and frees the object 
     * by calling delete.
     */ 
    virtual UtlBoolean destroy(UtlContainable*) = 0 ;    

    /**
     * Removes all elements from the container and deletes each one.
     */
    virtual void destroyAll() = 0 ;

    /**
     * Removes the designated object by reference
     * (as opposed to searching for an equality match).  
     *
     * @return the object if successful, otherwise null
     */
    virtual UtlContainable* removeReference(const UtlContainable* object) = 0;

    /**
     * Removes all elements from the container without freeing the objects.
     */
    virtual void removeAll() = 0 ;

/* ============================ ACCESSORS ================================= */

    /**
     * Find the designated value within the container
     */
    virtual UtlContainable* find(const UtlContainable*) const = 0 ;   


    /**
     * Calculate a unique hash code for this object.  If the equals
     * operator returns true for another object, then both of those
     * objects must return the same hashcode.
     */
    virtual unsigned hash() const;

    /**
     * Get the ContainableType for a UtlContainable derived class.
     */
    virtual UtlContainableType getContainableType() const;


/* ============================ INQUIRY =================================== */

    /**
     * Determine if the container is empty.
     */
    virtual UtlBoolean isEmpty() const = 0 ;

    /**
     * Determine if the container includes the designated objects.
     */
    virtual UtlBoolean contains(const UtlContainable *)  const = 0 ;

    /**
     * Determine the number of elements within the container.
     */     
    virtual size_t entries() const = 0 ;


    /**
     * Compare the this object to another like-objects.  Results for 
     * designating a non-like object are undefined.
     *
     * @returns 0 if equal, < 0 if less then and >0 if greater.
     */
    virtual int compareTo(const UtlContainable* otherObject) const;    

    /// Lock the linkage between containers and iterators
    static void acquireIteratorConnectionLock();
    /**<
     * This must be called by any code that will take both the
     * mContainerRefLock in an iterator and the mContainerLock in a
     * container.  It can be released as soon as both those locks are
     * acquired, and should be, since most operations on any iterator
     * will need to take it briefly.
     */

    /// Unlock the linkage between containers and iterators
    static void releaseIteratorConnectionLock();

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    friend class UtlIterator;
    friend class UtlInit;

    /// Add an iterator to the list to be notified of changes to this container.
    void addIterator(UtlIterator* newIterator ///< to be notified of container changes
                     ) const; // this const is a lie, but not a detectable one...
    /**<
     * <strong>
     * The caller must be holding this->mContainerLock and newIterator->mContainerRefLock
     * </strong>
     *
     * This also sets the mpMyContainer pointer in newIterator.
     */

    /// Called from iterator destructor to prevent further notices.
    void removeIterator(UtlIterator* existingIterator ///< iterator to remove from notice list
                        ) const;
    /**<
     * <strong>
     *   The caller must be holding both this->mContainerLock and 
     *   existingIterator->mContainerRefLock; see also acquireIteratorConnectionLock. 
     * </strong>
     *
     * Remove the existingIterator from the list to be called for
     * changes to this UtlContainer.
     */
    
    /// Call the invalidate method on all iterators
    void invalidateIterators();
    /**<
     * This is for use in subclasses that have other state that must
     * be cleaned up.
     *
     * :NOTE: the caller must be holding the iterator list lock;
     *  see iteratorListLock
     */

    /// Must be taken when making any change to container state
    OsBSem mContainerLock;


    /**
     * mpIterator list is the list of existing UtlIterator objects
     *   constructed using this UtlContainer
     *
     * This is used to invoke methods on each UtlIterator when changes are made to the UtlContainer
     *   ->remove when an element is about to be removed from the UtlContainer,
     *   ->invalidate when this UtlContainer is being deleted
     * see sIteratorConnectionLock
     */
    UtlChain mIteratorList; 

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    /// This lock prevent container/iterator deadlocks
    static OsBSem* spIteratorConnectionLock;
    /**<
     * UtlContainer/UtlIterator locking strategy
     *
     * The mpMyContainer pointer in a UtlIterator is protected by
     * the UtlIterator::mContainerRefLock.  That lock must be held to
     * write mpMyContainer, and while an iterator method is accessing
     * its container, *mpMyContainer.
     *
     * All other member variables of any UtlContainer, and all other
     * member variables of any UtlIterator are protected by the
     * UtlContainer::mContainerLock.
     *
     * A UtlIterator must always take both, because it has to lock the
     * mpMyContainer value to find its UtlContainer, and then lock the
     * mContainerLock before looking at the  UtlContainer state.
     *
     * A UtlContainer can usually take just the mContainerLock, but
     * when it is adding or removing a UtlIterator, it must lock the iterator's
     * mContainerRefLock as well so that it can change the mpMyContainer value.
     *
     * To prevent deadlocks, the sIteratorConnectionLock must be taken
     * before either lock when both are going to be needed.  It can
     * (and should) be released as soon as both locks are taken.  It does
     * not need to be held through the entire operation - once both
     * individual locks are taken, everything is safe and there can be no
     * deadlock.  Since holding it will block any operation on any UtlIterator,
     * it should be released as early as possible.
     *
     * Thus, the common sequences of operations are:
     *
     * Iterator operations:
     *
     *   UtlContainer::acquireIteratorConnectionLock();
     *   OsLock take(mContainerRefLock);
     *
     *   UtlList* myList = dynamic_cast<UtlList*>(mpMyContainer);
     *   if (myList != NULL)
     *   {
     *      OsLock take(myList->mContainerLock);
     *      UtlContainer::releaseIteratorConnectionLock(); // as soon as both locks are taken
     *
     *      // ... whatever the method does ...
     *   }
     *   else
     *   {
     *      UtlContainer::releaseIteratorConnectionLock();
     *   }
     *
     * Container operations (that does not affect mpMyContainer in any iterator):
     *
     *   {
     *      OsLock take (mContainerLock);
     *
     *      ... whatever the method does ...
     *   }
     *
     * Container destructor (must take sIteratorConnectionLock to disconnect iterators):
     *
     *   UtlContainer::acquireIteratorConnectionLock();
     *   OsLock take(mContainerRefLock);
     *  
     *   UtlList* myList = dynamic_cast<UtlList*>(mpMyContainer);
     *   if (myList != NULL)
     *   {
     *      OsLock take(myList->mContainerLock);
     *      UtlContainer::releaseIteratorConnectionLock(); // as soon as both locks are taken
     *  
     *      myList->removeIterator(this);
     *      mpMyContainer = NULL;
     *   }
     *   else
     *   {
     *      UtlContainer::releaseIteratorConnectionLock();
     *   }
     */

    /**
     * There is no copy constructor
     */
    UtlContainer(const UtlContainer& copy );

    /**
     * There is no assignment operator
     */
    UtlContainer& operator=(const UtlContainer& copy );

} ;

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlContainer_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlCopyableContainable_h_
#define _UtlCopyableContainable_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlSList.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * UtlCopyableContainable is a containble that must a clone method, that is 
 * used by UtlCopyableSList in order to assign/copy list elements on list copy.
 *
 * Derived classes should also implement a copy contructor and an equals 
 * operator.
 *
 * Sample clone implementation:
 * SampleClass* clone() const { return new SampleClass(*this); }
 *
 */
class UtlCopyableContainable : public UtlContainable
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
   
   virtual UtlCopyableContainable* clone() const = 0;

/* ============================ CREATORS ================================== */

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */
   
/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

} ;

/* ============================ INLINE METHODS ============================ */\

#endif    // _UtlCopyableContainable_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlCopyableSList_h_
#define _UtlCopyableSList_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlSList.h"
#include "utl/UtlCopyableContainable.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * UtlCopyableSList is a linked list that provides a copy contructor and an 
 * equals operator.  A deep copy of the array elements is performed.
 * 
 * @see UtlSList
 */
class UtlCopyableSList : public UtlSList
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
   
   /**
    * Constructor
    */
   UtlCopyableSList();

   /**
    * Copy Constructor
    */
   UtlCopyableSList(const UtlCopyableSList& rhs);

   /**
    * Destructor
    */
   virtual ~UtlCopyableSList() ;


/* ============================ CREATORS ================================== */

/* ============================ MANIPULATORS ============================== */

   /**
    * Assignment operator
    */
   UtlCopyableSList& operator=(const UtlCopyableSList& rhs);

    /**
     * Append the designated containable object to the end of this list.
     * 
     * @return the object if successful, otherwise null
     */
    virtual UtlContainable* append(UtlCopyableContainable* obj) ;

    /// Insert the designated containable object at the designated position.
    virtual UtlContainable* insertAt(size_t N,           ///< zero-based position obj should be
                                     UtlCopyableContainable* obj ///< object to insert at N
                                     );
    /**<
     * It is an error to specify N > entries()
     *
     * @return obj if successful, NULL if N > entries
     */

    /**
     * Inserts the designated containable object at the end postion (tailer).
     * 
     * @return the object if successful, otherwise null
     */
    virtual UtlContainable* insert(UtlCopyableContainable* obj) ;

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */


   /**
    * Get the ContainableType for the hash bag as a contained object.
    */
   virtual UtlContainableType getContainableType() const;

   static UtlContainableType TYPE ;    /** < Class type used for runtime checking */ 
   
/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:


} ;

/* ============================ INLINE METHODS ============================ */\

#endif    // _UtlCopyableSList_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlCopyableSortedList_h_
#define _UtlCopyableSortedList_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlSortedList.h"
#include "utl/UtlCopyableContainable.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * UtlCopyableSortedList is a linked list that provides a copy contructor and an 
 * equals operator.  A deep copy of the array elements is performed.
 * 
 * @see UtlSortedList
 */
class UtlCopyableSortedList : public UtlSortedList
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
   
   /**
    * Constructor
    */
   UtlCopyableSortedList();

   /**
    * Copy Constructor
    */
   UtlCopyableSortedList(const UtlCopyableSortedList& rhs);

   /**
    * Destructor
    */
   virtual ~UtlCopyableSortedList() ;


/* ============================ CREATORS ================================== */

/* ============================ MANIPULATORS ============================== */

   /**
    * Assignment operator
    */
   UtlCopyableSortedList& operator=(const UtlCopyableSortedList& rhs);

    /**
     * Inserts the designated containable object into the list
     * 
     * @return the object if successful, otherwise null
     */
    virtual UtlContainable* insert(UtlCopyableContainable* obj);

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */


   /**
    * Get the ContainableType for the hash bag as a contained object.
    */
   virtual UtlContainableType getContainableType() const;

   static UtlContainableType TYPE ;    /** < Class type used for runtime checking */ 
   
/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:


} ;

/* ============================ INLINE METHODS ============================ */\

#endif    // _UtlCopyableSortedList_h_

//
// Copyright (C) 2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UrlCrc32_h_
#define _UrlCrc32_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "os/OsDefs.h"
#include "utl/UtlString.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * Utility class for generating CRC-32s
 */
class UtlCrc32 
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    /**
     * Default no-argument constructor
     */
    UtlCrc32() ;

/* ============================ CREATORS ================================== */

/* ============================ MANIPULATORS ============================== */

    /**
     * Reset the Crc32 value
     */
    void reset() ;

    /**
     * Adds a single byte to the checksum
     */
    void calc(unsigned char ch) ;

    /**
     * Adds a sequence of bytes to the checksum
     */
    void calc(unsigned char* pData, size_t nData) ;

    /**
     * Adds a sequence of bytes contained within a UtlString to the checksum
     */
    void calc(const UtlString& data) ;

/* ============================ ACCESSORS ================================= */

    /**
     * Get the current CRC-32 value
     */
    unsigned long getValue() const ;

/* ============================ INQUIRY =================================== */    

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    unsigned long mCrc ;
   
/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

   UtlCrc32(const UtlCrc32& rUtlCrc32);
     //:Copy constructor (not implemented for this class)

   UtlCrc32& operator=(const UtlCrc32& rhs);
     //:Assignment operator (not implemented for this class)

};

/* ============================ INLINE METHODS ============================ */

#endif  // _UrlCrc32_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _UTLDATETIME_H_
#define _UTLDATETIME_H_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlContainable.h"
#include "os/OsDateTime.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * UtlDateTime is a UtlContainable wrapper for a OsDateTime object.
 */
class UtlDateTime : public UtlContainable
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    static const UtlContainableType TYPE ;    /** < Class type used for runtime checking */ 

/* ============================ CREATORS ================================== */

    /**
     * Constructor
     */
    UtlDateTime(OsDateTime time) ;
      
    /**
     * Destructor
     */
    virtual ~UtlDateTime();

/* ============================ MANIPULATORS ============================== */

    /**
     * Set a new time value for this object.
     *
     */
    void setTime(const OsDateTime& time) ;

/* ============================ ACCESSORS ================================= */

    /**
     * Get the time wrapped by this object.
     */
    void getTime(OsDateTime& time) const ;    

    /**
     * Calculate a unique hash code for this object.  If the equals
     * operator returns true for another object, then both of those
     * objects must return the same hashcode.
     */
    virtual unsigned hash() const ;

    /**
     * Get the ContainableType for a UtlContainable derived class.
     */
    virtual UtlContainableType getContainableType() const;
         
/* ============================ INQUIRY =================================== */

    /**
     * Compare the this object to another like-objects.  Results for 
     * designating a non-like object are undefined.
     *
     * @returns 0 if equal, < 0 if less then and >0 if greater.
     */
    virtual int compareTo(UtlContainable const *) const ;    


/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    OsDateTime mTime ;    /** < The OsDateTime wrapped by this object */ 

} ;

/* ============================ INLINE METHODS ============================ */

#endif    // _UTLDATETIME_H_
//
// Copyright (C) 2006 SIPez LLC.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlDefs_h_
#define _UtlDefs_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
// DEFINES
#ifndef FALSE
#define FALSE ((UtlBoolean)(1==0))
#endif

#ifndef TRUE
#define TRUE ((UtlBoolean)(1==1))
#endif

#ifndef NULL
#define NULL 0
#endif

#define UTL_NOT_FOUND ((size_t)-1)

// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS

typedef int UtlBoolean ;


/** FORMAT_INTLL is a string containing the format length specifier
 *  for printing an intll with the 'd', 'x', etc. format specifiers.  E.g.:
 *      intll xyz;
 *      printf("The value is %" FORMAT_INTLL "d", xyz);
 *  Note that the '%' before and the format specifier after must be provided.
 *  This must be a #define, since this specifier isn't standardized.
 */
#if defined(_WIN32)
#  define   FORMAT_INTLL   "I64"
#elif defined(__pingtel_on_posix__)
#  define   FORMAT_INTLL   "ll"
#else
#  error Unsupported target platform.
#endif

typedef const char* const UtlContainableType ;

// FORWARD DECLARATIONS

#endif // _UtlDefs_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlDList_h_
#define _UtlDList_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlSList.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * UtlDList is a doubly linked list designed to contain any number of
 * UtlContainable derived object.  For more information on lists, please
 * look at UtlSList.
 * 
 * @see UtlSList
 */
class UtlDList : public UtlSList
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
   static UtlContainableType TYPE ;    /** < Class type used for runtime checking */ 
   
   /**
    * Constructor
    */
   UtlDList();


   /**
    * Destructor
    */
   virtual ~UtlDList() ;


/* ============================ CREATORS ================================== */

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */


   /**
    * Get the ContainableType for the hash bag as a contained object.
    */
   virtual UtlContainableType getContainableType() const;

   
/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:


} ;

/* ============================ INLINE METHODS ============================ */\

#endif    // _UtlDList_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlDListIterator_h_
#define _UtlDListIterator_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlSListIterator.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * UtlDListIterator allows developers to iterate (walks through) a UtlDList.
 * 
 * @see UtlIterator
 * @see UtlDList
 */
class UtlDList;
     
class UtlDListIterator : public UtlSListIterator
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   /**
    * Constructor accepting a source UtlDList 
    */
   UtlDListIterator(const UtlDList& list) ;


   /**
     * Destructor
     */
    virtual ~UtlDListIterator();

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    friend class UtlDList;
    


/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    UtlDListIterator();
};

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlDListIterator_h_


//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlHashBag_h_
#define _UtlHashBag_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlContainer.h"
#include "utl/UtlLink.h"

// DEFINES
// MACROS
#define NUM_HASHBAG_BUCKETS(bits) (1<<bits)

// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlContainable;

/**
 * A UtlHashBag is an orderless container that efficiently allows for both 
 * random access and iteration. 
 */
class UtlHashBag : public UtlContainer
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:
    static UtlContainableType TYPE;

/* ============================ CREATORS ================================== */

   /**
    * Constructor
    */
   UtlHashBag();

   /**
    * Destructor
    */
   virtual ~UtlHashBag(); 
/* ============================ MANIPULATORS ============================== */

   /**
    * Insert the designated object into this container.  
    * 
    * @return the given object on success otherwise null.
    */
   virtual UtlContainable* insert(UtlContainable* object);

   /**
    * Remove one matching object from this container.  
    * 
    * @return the removed object if a match was found, otherwise NULL.
    */
   virtual UtlContainable* remove(UtlContainable* object);
    
   /**
    * Remove the designated object by reference
    * (as opposed to searching for an equality match).  
    *
    * @return the object if successful, otherwise null
    */
   virtual UtlContainable* removeReference(const UtlContainable* object);

   /**
    * Removes one matching object from the bag and deletes the object 
    *
    * @return true if a match was found, false if not
    */ 
   virtual UtlBoolean destroy(UtlContainable* object);    

   /**
    * Removes all elements from the container and deletes each one.
    */
   virtual void destroyAll();

   /**
    * Removes all elements from the container without freeing the objects.
    */
   virtual void removeAll();

/* ============================ ACCESSORS ================================= */

   /**
    * Return the designated object if found, otherwise null.
    */
   virtual UtlContainable* find(const UtlContainable* object) const;


/* ============================ INQUIRY =================================== */


   /**
    * Return the total number of elements within the container.
    */
   size_t entries() const;

   /**
    * Return true of the container is empty (entries() == 0), otherwise false.
    */
   UtlBoolean isEmpty() const;

   /**
    * Return true if the container includes the designated object.  Each 
    * element within the list is tested for equality against the designated 
    * object using the equals() method. 
    */
   UtlBoolean contains(const UtlContainable* object) const;


   /**
    * Get the ContainableType for the hash bag as a contained object.
    */
   virtual UtlContainableType getContainableType() const;

   /// The current number of buckets in the hash.
   size_t numberOfBuckets() const
      {
         return NUM_HASHBAG_BUCKETS(mBucketBits);
      }

/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:
   friend class UtlHashBagIterator;

   void notifyIteratorsOfRemove(const UtlLink* pair);

   /// If the Hash is too full, add additional buckets.
   /**
    * Assumes that the caller is holding the mContainerLock.
    *
    * This calls resize to actually do the resize if it is safe.
    */
   void resizeIfNeededAndSafe()
      {
         if (   ( mElements / NUM_HASHBAG_BUCKETS(mBucketBits) >= 3 ) // mean bucket 3 or more
             && ( mIteratorList.isUnLinked() )   /* there are no iterators -
                                                  * resizing moves elements to new buckets,
                                                  * which could cause an iterator to miss some
                                                  * and to return others more than once.
                                                  */
             )
         {
            resize();
         }
      }
    
   size_t    mElements;   ///< number of UtlContainable objects in this UtlHashMap
   size_t    mBucketBits; ///< number of bits used to index the buckets
   UtlChain* mpBucket;    ///< an array of 2**n UtlChain elements, each used as a list header.

/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:


   /// Insert a link into a bucket (the bucket list is ordered by hashcode).
   void insert(UtlLink*       link,  ///< The UtlLink for the entry if it was found.
               UtlChain*      bucket ///< The bucket list header where the entry belongs.
               );

   /// Allocate additional buckets and redistribute existing contents.
   void resize();
   /**
    * This should only be called through resizeIfNeededAndSafe.
    */          

   /// Search for a given key value and return the the UtlPair and bucket for it.
   bool lookup(const UtlContainable* key, ///< The key to locate.
               UtlChain*&      bucket,    /**< The bucket list header in which it belongs.
                                           *   This is set regardless of whether or not the
                                           *   key was found in the table. */
               UtlLink*&       pair       /**< If the key was found, the UtlPair for the entry.
                                           *   If the key was not found, this is NULL. */
               ) const;
   /**<
    * @return true if the key was found, and false if not.
    */
    
   /// Insert a pair into a bucket.
   void insert(UtlPair*        pair,   /**< The UtlPair for the entry - data, value, and hash
                                        *   are already set. */
               UtlChain*       bucket  ///< The bucket list header where the entry belongs.
               );

   /// Calculate the bucket number for a given hash.
   size_t bucketNumber(unsigned hash) const;


   // Don't allow the implicit copy constructor.
   UtlHashBag(UtlHashBag&);

   UtlHashBag& operator=(UtlHashBag&);
   
};

/* ============================ INLINE METHODS ============================ */


#endif    // _UtlHashBag_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlHashBagIterator_h_
#define _UtlHashBagIterator_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlIterator.h"
#include "utl/UtlHashBag.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlContainable ;

/**
 * UtlHashBagIterator allows developers to iterator (walks through) an 
 * UtlHashBag.
 * 
 * @see UtlIterator
 * @see UtlSList
 */
class UtlHashBagIterator : public UtlIterator
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   /**
    * Construct an iterator over all objects in a given UtlHashBag
    * If key is specified, iterate only over objects that match that key
    * (UtlHashBags may have any number of copies of a given object)
    */
   UtlHashBagIterator(UtlHashBag& hashBag, UtlContainable* key = NULL);

   /**
     * Destructor
     */
    virtual ~UtlHashBagIterator();

/* ============================ MANIPULATORS ============================== */

    /**
     * Return the next element.
     * 
     * @return The next element or NULL if no more elements are available.
     */
    virtual UtlContainable*    operator()() ;

    /**
     * Reset the list by moving the iterator cursor to the location before the
     * first element. 
     */
    virtual void reset() ; 

/* ============================ ACCESSORS ================================= */

    /**
     * Gets the key of the current element
     */
    UtlContainable* key() const ;

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    friend class UtlHashBag;
    
    /**
     * removing is called by the UtlHashMap when an element is about to be
     * removed from the container.  The iterator must ensure that the element
     * for the removed node is not returned by any subsequent call.
     */
    virtual void removing(const UtlLink* node);


/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    void init(UtlHashBag& hashBag);
   
    UtlContainable* mpSubsetMatch; ///< if non-NULL, points to the key that defines the subset
    unsigned        mSubsetHash;   ///< if mpSubsetMatch != NULL, this is its hash code
    
    size_t   mPosition;      ///< current bucket number [0..numberOfBuckets-1]
    UtlLink* mpCurrentLink;  ///< current UtlLink within the bucket, or BEFORE_FIRST
    bool     mLinkIsValid;   /**< true if mpCurrentLink is the valid current position
                              * The only time this is false is when the UtlContainable
                              * at the current position was removed while it was current. */

    // no copy constructor
    UtlHashBagIterator(UtlHashBagIterator&);
} ;

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlHashBagIterator_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlHashMap_h_
#define _UtlHashMap_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlContainer.h"

// DEFINES
// MACROS
#define NUM_HASHMAP_BUCKETS(bits) (1<<bits)

// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlContainable;
class UtlPair;

/**
 * UtlHashMap is a container object that allows you to store keys and 
 * values.  Key must be unique (testing for equality using the
 * UtlContainer::isEquals(...) method).
 */
class UtlHashMap : public UtlContainer
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
    static const UtlContainableType TYPE;

/* ============================ CREATORS ================================== */

    /**
     * Default Constructor
     */
    UtlHashMap();

    /**
     * Destructor
     */
    virtual ~UtlHashMap();

/* ============================ MANIPULATORS ============================== */

    /**
     * Inserts a key and value pair into the hash map.
     *
     * If the inserted key is already in the table, this method 
     * fails (returns NULL - note that this means if value is NULL,
     * then you can't tell whether  there was an error or not).
     * To replace the value for a given key, the old value must
     * be Removed before the new value is inserted.
     *
     * @return the key on success, otherwise NULL
     */
    UtlContainable* insertKeyAndValue(UtlContainable* key, UtlContainable* value);


    /**
     * Inserts the designated containable object into the list
     * with a NULL value (see note regarding use of NULL value
     * in insertKeyAndValue).
     * If there is an equal key in the UtlHashMap already,
     * the insert will fail.
     * 
     * @return the object if successful, otherwise NULL
     */
    UtlContainable* insert(UtlContainable* obj);


    /**
     * Remove the designated key and its associated value.
     *
     * @return the key or NULL if not found
     */
    UtlContainable* remove(UtlContainable* key);


    /**
     * Remove the designated key and its associated value.
     *
     * @return the key or NULL if not found
     */
    UtlContainable* removeReference(const UtlContainable* key);
    

    /**
     * Remove the designated key and its associated value.  The pointer of value
     * is returned as part of the call if successful.
     *
     * @return the key or NULL if not found
     */
    UtlContainable* removeKeyAndValue(const UtlContainable* key, UtlContainable*& value);


    /**
     * Removes the designated key and its associated value from the map
     * and frees the key and the value (if not NULL) by calling delete.
     */ 
    virtual UtlBoolean destroy(UtlContainable* key);    


    /**
     * Removes all elements from the hash map and deletes each element.
     */
    virtual void destroyAll();


    /**
     * Removes all elements from the hash map without deleting the elements
     */
    virtual void removeAll();

/* ============================ ACCESSORS ================================= */

    /**
     * Return the value for a given key or NULL if not found.
     */
    UtlContainable* findValue(const UtlContainable* key) const;


    /**
     * Return the designated key if found otherwise NULL.
     */
    virtual UtlContainable* find(const UtlContainable* key) const;

/* ============================ INQUIRY =================================== */

    /**
     * Return the total number of keys in the hash map
     */
    size_t entries() const;


    /**
     * Return true if the hash map is empty (entries() == 0), otherwise false.
     */
    UtlBoolean isEmpty() const;


    /**
     * Return true if the hash map includes an entry with the specified key.
     */
    UtlBoolean contains(const UtlContainable* key) const;
  

    /**
     * Get the ContainableType for the hash bag as a contained object.
     */
    virtual UtlContainableType getContainableType() const;

    /**
     * Make a copy of all of the items BY POINTER in (*this) instance
     * into the given map. It does not clear the given map. IF USING
     * destroyAll call, be sure to call this on only ONE map instance.
     */
    void copyInto(UtlHashMap& map) const;

    /// The current number of buckets in the hash.
    size_t numberOfBuckets() const
       {
          return NUM_HASHMAP_BUCKETS(mBucketBits);
       }
    

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    friend class UtlHashMapIterator;

    static const UtlContainable* INTERNAL_NULL;

    /// If the Hash is too full, add additional buckets.
    /**
     * Assumes that the caller is holding the mContainerLock.
     *
     * This calls resize to actually do the resize if it is safe.
     */
    void resizeIfNeededAndSafe()
       {
          if (   ( mElements / NUM_HASHMAP_BUCKETS(mBucketBits) >= 3 ) // mean bucket 3 or more
              && ( mIteratorList.isUnLinked() )   /* there are no iterators -
                                                   * resizing moves elements to new buckets,
                                                   * which could cause an iterator to miss some
                                                   * and to return others more than once.
                                                   */
              )
          {
             resize();
          }
       }
    
    size_t    mElements;   ///< number of UtlContainable objects in this UtlHashMap
    size_t    mBucketBits; ///< number of bits used to index the buckets
    UtlChain* mpBucket;    ///< an array of 2**n UtlChain elements, each used as a list header.

    static    UtlChainPool* spPairPool; ///< pool of available UtlPair objects.
    
/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    /// Allocate additional buckets and redistribute existing contents.
    void resize();
    /**
     * This should only be called through resizeIfNeededAndSafe.
     */          

    /// Search for a given key value and return the the UtlPair and bucket for it.
    bool lookup(const UtlContainable* key, ///< The key to locate.
                UtlChain*&      bucket,    /**< The bucket list header in which it belongs.
                                            *   This is set regardless of whether or not the
                                            *   key was found in the table. */
                UtlPair*&       pair       /**< If the key was found, the UtlPair for the entry.
                                            *   If the key was not found, this is NULL. */
                ) const;
    /**<
     * @return true if the key was found, and false if not.
     */
    
    /// Insert a pair into a bucket.
    void insert(UtlPair*        pair,   /**< The UtlPair for the entry - data, value, and hash
                                         *   are already set. */
                UtlChain*       bucket  ///< The bucket list header where the entry belongs.
                );

    /// Calculate the bucket number for a given hash.
    size_t bucketNumber(unsigned hash) const;
    
    // no copy constructor is provided
    UtlHashMap(UtlHashMap&);

    /** Use copyInto instead */
    UtlHashMap& operator=(const UtlHashMap&);
    
    /**
     * notifyIteratorsOfRemove - called before removing any entry from the UtlHashMap
     */
    void notifyIteratorsOfRemove(const UtlPair* pair);
};

#endif    // _UtlHashMap_h_


//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _UtlHashMapIterator_h_
#define _UtlHashMapIterator_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlIterator.h"
#include "utl/UtlHashMap.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlContainable;
class UtlPair;

/**
 * UtlHashMapIterator allows developers to iterate (walks through) the
 * objects in a UtlHashMap.
 * 
 * @see UtlIterator
 * @see UtlHashMap
 */
class UtlHashMapIterator : public UtlIterator
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

/* ============================ CREATORS ================================== */

   /**
    * Constructor accepting a source UtlHashMap 
    */
   UtlHashMapIterator(const UtlHashMap& hashMap);


   /**
    * Destructor
    */
   virtual ~UtlHashMapIterator();

/* ============================ MANIPULATORS ============================== */

   /**
    * Return the key for the next element. 
    *
    * @return The next element key or NULL if no more elements are available.
    */
   virtual UtlContainable* operator()();


   /**
    * Reset the list by moving the iterator cursor to the location before the
    * first element. 
    */
   virtual void reset(); 


/* ============================ ACCESSORS ================================= */

   /**
    * Gets the key of the current element
    *
    * This method is undefined if the next element has not been called
    * (e.g. immediately after construction or after calling reset()).
    * If the current element has been removed from the hash (either through
    * the remove method on the iterator or directly on the UtlHashMap),
    * this method returns NULL.  The remaining values in the iteration sequence
    * are not affected (the next call to () will return the next key).
    */
   UtlContainable* key() const;


   /**
    * Gets the value of the current element
    *
    * This method is undefined if the next element has not been called
    * (e.g. immediately after construction or after calling reset()).
    * If the current element has been removed from the hash (either through
    * the remove method on the iterator or directly on the UtlHashMap),
    * this method returns NULL.  The remaining values in the iteration sequence
    * are not affected (the next call to () will return the next key).
    */
   UtlContainable* value() const;

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:
   friend class UtlHashMap;

   /**
    * removing is called by the UtlHashMap when an element is about to be
    * removed from the container.  The iterator must ensure that the element
    * for the removed node is not returned by any subsequent call.
    */
   virtual void removing(const UtlPair* key);


/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:

   void init();

   size_t   mPosition;      ///< current bucket number [0..numberOfBuckets-1]
   UtlPair* mpCurrentPair;  ///< current UtlPair within the bucket, or BEFORE_FIRST
   bool     mPairIsValid;   /**< true if mpCurrentPair is the valid current position
                             * The only time this is false is when the UtlContainable
                             * at the current position was removed while it was current. */

   // no copy constructor
   UtlHashMapIterator(UtlHashMapIterator&);
   
};

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlHashMapIterator_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _UtlHistogram_h_
#define _UtlHistogram_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include "utl/UtlString.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * Record and dump counts in a series of bins.
 *
 * Recorded values are integers.  The histogram has a specified number
 * of bins, each counting the number of values over a range, each of
 * which has the same specified width.
 *
 * The number of bins implemented is 2 more than the specified number,
 * to allow one bin for values lower than the range and one for values
 * higher than the range.
 *
 * The minimum of the range of bin 0 is Base, and each normal bin has
 * a range of Size values.
 *
 * The first normal bin is numbered 0, so the bin for too-low values
 * is numbered -1.  Thus, the bins record:
 *
 * Bin -1 counts values less than "Base".
 * Bin 0 counts values from "Base" to "Base + Size - 1".
 * Bin 1 counts values from "Base + Size" to "Base + 2*Size - 1".
 * Bin n counts values from "Base + n*Size" to "Base + (n+1)*Size - 1".
 * Bin NoOfBins-1 counts values from "Base + (NoOfBins-1)*Size" to
 *         "Base + NoOfBins*Size -1".
 * Bin NoOfBins counts values greater than or equal to "Base + NoOfBins*Size".
 *
 * The values of all the bins can be extracted in a string by setting
 * outputFormat and outputWidth when the histogram is created.
 * Calling show() formats each bin's value via
 * sprintf(buffer, outputFomat, bin-value), concatenates them
 * together, and returns the result as a UtlString.
 * outputFormat must be a format string for formatting a single int,
 * and it must always generate at most outputWidth characters.
 *
 * The outputFormat string must remain valid as long as the histogram
 * object exists; the returned UtlString must be freed by the caller.
 */
class UtlHistogram
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

/* ============================ CREATORS ================================== */

   /**
    * Constructor.
    */
   UtlHistogram(unsigned int bins, int base, unsigned int size,
                const char* outputFormat = "", unsigned int outputWidth = 0);
     
   /**
    * Destructor
    */
   ~UtlHistogram();

/* ============================ MANIPULATORS ============================== */

   /**
    * Record a value.
    * Returns the number of counts in the histogram.
    */
   unsigned int tally(int);

   /**
    * Clear the histogram.
    */
   void clear();

/* ============================ ACCESSORS ================================= */

   /**
    * Get the specified number of bins (which is 2 less than the total number
    * of bins).
    */
   unsigned int getNoOfBins();

   /**
    * Get the lowest value for bin 0.
    */
   unsigned int getBase();

   /**
    * Get the size of each bin.
    */
   unsigned int getBinSize();

   /**
    * Get the total count.
    */
   unsigned int getCount();

   /**
    * Get the count in bin i.
    * i ranges from -1 to NoOfBins+1.
    */
   unsigned int operator[](unsigned int i);

/* ============================ INQUIRY =================================== */

   /**
    * Get a string containing the formatted values from the bins.
    * The caller must free the returned UtlString.
    */
   UtlString* show();

/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:

   // Number of bins.
   unsigned int mNoOfBins;
   // Lowest value in bin 0.
   int mBase;
   // Size of each bin:
   unsigned int mBinSize;
   // Pointer to an array of mNoOfBins int's.
   unsigned int* mpBins;
   // Total number of counts.
   unsigned int mCount;

   // Format used to output values.
   const char* mOutputFormat;
   // Width of output that format will generate.
   unsigned int mOutputWidth;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _UtlHistogram_h_
// 
// Copyright (C) 2007 Jaroslav Libak
// Licensed to SIPfoundry under a Contributor Agreement.
//
// Copyright (C) 2007 SIPez LLC.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// Copyright (C) 2004-2007 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef UtlInit_h__
#define UtlInit_h__

// SYSTEM INCLUDES
// APPLICATION INCLUDES
// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// FORWARD DECLARATIONS
// STRUCTS
// TYPEDEFS

/**
*  @brief Utl initializer class. Solves the problem with ordering of
*  constructors & destructors.
*
*  The h file needs to be included in:
*  - all cpp files whose static members are initialized in UtlInit constructor,
*  in order to make sure they are initialized properly whenever they are linked
*  into program.
*  - it also has to be included as the first include in cpp files, that
*  initialize static members whose constructor or destructor tries to use any
*  static members we initialize here.
*/
class UtlInit
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
/* ============================ CREATORS ================================== */
///@name Creators
//@{

   /// Constructor
   UtlInit(void);

   /// Destructor
   ~UtlInit(void);
//@}

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
   static unsigned int msCount; ///< Class instance counter.
};

/**
*  This fixes constructor/destructor ordering by declaring a static instance
*  of this Init class in every cpp file where this .h file is included.
*  Thus constructor of this class will be run first, and destructor as the last.
*/
static UtlInit gUtlInit;

#endif // UtlInit_h__
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlInt_h_
#define _UtlInt_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlCopyableContainable.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * UtlInt is a UtlContainable wrapper for an int.
 */
class UtlInt : public UtlCopyableContainable
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
    static const UtlContainableType TYPE ;    /** < Class type used for runtime checking */ 

/* ============================ CREATORS ================================== */

    /**
     * Constructor accepting an optional default value.
     */
    UtlInt(int initialValue = 0) ;
    UtlInt(const UtlInt& rhs) ;
      
    /**
     * Destructor
     */
    virtual ~UtlInt();

    UtlCopyableContainable* clone() const;

/* ============================ OPERATORS ============================== */

    // Declare prefix and postfix increment operators.
    UtlInt& operator++();       // Prefix increment operator
    UtlInt operator++(int);     // Postfix increment operator

    // Declare prefix and postfix decrement operators.
    UtlInt& operator--();       // Prefix decrement operator
    UtlInt operator--(int);     // Postfix decrement operator

    UtlInt& operator=(const UtlInt& rhs); // assigment operator

    // Conversion to int
    operator int() { return mValue; }

/* ============================ MANIPULATORS ============================== */

    /**
     * Set a new int value for this object.
     *
     * @returns the old value
     */
    int setValue(int iValue) ;

/* ============================ ACCESSORS ================================= */

    /**
     * Get the int wrapped by this object.
     */
    int getValue() const ;    

    /**
     * Calculate a unique hash code for this object.  If the equals
     * operator returns true for another object, then both of those
     * objects must return the same hashcode.
     */
    virtual unsigned hash() const ;

    /**
     * Get the ContainableType for a UtlContainable derived class.
     */
    virtual UtlContainableType getContainableType() const;
         
/* ============================ INQUIRY =================================== */

    /**
     * Compare this object to another like-object.  Results for 
     * comparing to a non-like object are undefined.
     *
     * @returns 0 if equal, < 0 if less then and >0 if greater.
     */
    virtual int compareTo(UtlContainable const *) const ;    

    /**
     * Test this object to another like-object for equality.  This method 
     * returns false if unlike-objects are specified.
     */
    virtual UtlBoolean isEqual(UtlContainable const *) const ; 

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    int mValue ;    /** < The int wrapped by this object */ 

} ;

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlInt_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlIterator_h_
#define _UtlIterator_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "os/OsBSem.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlContainable ;
class UtlContainer;

/**
 * UltIterator defines an abstract Iterator for walking through the elements
 * of UtlContainer derived class.
 * 
 * <p>
 * Example Code:
 * <pre>
 *    // Create an iterator that walks through the elements of myContentSource.
 *    FooIterator itor(myContentSource);
 *    MyObject* pObj;
 *    // Fetch a pointer to each element of myContentSource into pObj.
 *    while ((pObj = itor()))
 *    {
 *       // Do something to *pObj.
 *    }
 *    // Reset itor to its initial state, so itor() starts walking through the
 *    // elements of myContentSource all over again.
 *    itor.reset();
 *    while ((pObj = itor()))
 *    {
 *       // Do something else to *pObj.
 *    }
 * </pre>
 * (The extra parentheses in the while clauses are to mark that that
 * operation is an assignment, not a comparison.)
 */
class UtlIterator
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   UtlIterator(const UtlContainer& container);
   
    /**
     * Destructor
     */
    virtual ~UtlIterator() = 0;

/* ============================ MANIPULATORS ============================== */

    
    /// Return the next element.
    virtual UtlContainable* operator()() = 0 ;

    /// Reset the iterator cursor so that it will again return all elements in the container.
    virtual void reset() = 0 ; 

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    friend class UtlContainer;

    /******************************************************************
     * @par Removing Method - Variable Signature.
     *
     * All iterators must have a 'removing' method so that they can be notified
     * by the container when an element is removed.
     *
     * There is no prototype for it here because the signature differs depending
     * on the container type.
     *
     * removing is called by the UtlContainer when an element is about to be
     * removed from the container.  The iterator must ensure that the removed
     * element is not returned by any subsequent call.
     * if element != NULL, it points to the element to be removed.
     * if element == NULL, means all elements to be removed.
     */
    // virtual void removing( ... type depends on the class of the iterator... ) = 0;


    void addToContainer(const UtlContainer* container);
    
    /**
     * invalidate is called by the UtlContainer from its destructor.
     * It disconnects the iterator from its container object (sets
     * mpContainerRef to NULL).
     * Any subsequent invocation of this iterator (other than its
     * destructor) must return an error.
     *
     * :NOTE: Both the sIiteratorListLock and the container lock must be held by the caller.
     */
    virtual void invalidate();
    
    /**
     * The mContainerRefLock must be held whenever the mpMyContainer value
     * is being used or modified.  If the mpIteratorListLock in the container
     * is also held, then the mpIteratorListLock must be taken first.
     */
    OsBSem mContainerRefLock;
    UtlContainer* mpMyContainer;
    
/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    /**
     * There is no copy constructor
     */
    UtlIterator(const UtlIterator& noCopyAllowed);

    /**
     * There is no assignment operator
     */
    UtlIterator& operator=(const UtlIterator& noCopyAllowed);

} ;

/* ============================ INLINE METHODS ============================ */

#endif  // _UtlIterator_h_

//
// Copyright (C) 2005 SIPfoundry Inc.
// License by SIPfoundry under the LGPL license.
// 
// Copyright (C) 2005 Pingtel Corp.
// Licensed to SIPfoundry under a Contributor Agreement.
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _UTLLINK_H_
#define _UTLLINK_H_

#include "assert.h"

// SYSTEM INCLUDES
#include "os/OsDefs.h"
#include "os/OsBSem.h"

// APPLICATION INCLUDES
#include "utl/UtlContainable.h"

// DEFINES
#ifndef UTLLINK_BLOCK_SIZE
#define UTLLINK_BLOCK_SIZE 1000
#endif

// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlLink;
class UtlChainPool;

/**
 * UtlChain is the internal class that implements the linked list blocks
 * for other Utl classes.  It may not be used directly because by itself
 * it is not thread safe.  Use one of the lists types derived from UtlList.
 *
 * Each UltLinkChain links forward (next) and backward (prev) in the chain of links;
 * ends of a chain are indicated by NULL values.  A UtlChain not in a chain,
 * including a newly constructed instance, have NULL pointers in both directions.
 *
 * A UtlChain can also be used as a list header whose links point to the ends
 * of a NULL terminated list.
 */
class UtlChain
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:
   /// Constructor initializes to unlinked.
   UtlChain() :
      prev(NULL),
      next(NULL)
      {
      }

   /// Destructor
   ~UtlChain()
      {
      }

/* //////////////////////////// PROTECTED //////////////////////////////////// */
  protected:
   friend class UtlChainPool;
   friend class UtlLink;
   friend class UtlPair;
   friend class UtlContainer;
   friend class UtlList;
   friend class UtlHashMap;
   friend class UtlHashMapIterator;
   friend class UtlHashBag;
   friend class UtlHashBagIterator;
   friend class UtlChainTest;
   friend class UtlLinkTest;
   
   UtlChain* prev; ///< backward chain pointer
   UtlChain* next; ///< forward chain pointer

   // ================================================================
   /** @name                  Chain Operations
    *
    * These methods manipulate the forward and backward links within a 
    * chain.  They do no do anything with respect to any header, so they
    * can be used to implement chains that are linear (NULL terminated)
    * or circular.
    */
   ///@{

   /// Is this block not linked to anything?
   bool isUnLinked() const
      {
         return (!(prev||next));
      }

   /// Take the link out of its chain.
   void unchain()
      {
         if (prev)
         {
            prev->next = next;
         }
         if (next)
         {
            next->prev = prev;
         }
         prev=NULL;
         next=NULL;
      }

   /// Insert a new UtlChain before existing.
   /**
    * This may be called only on an unlinked UtlChain
    */
   void chainBefore(UtlChain* existing)
      {
         assert(isUnLinked()); // not valid on a link that's in a chain
         
         next = existing;
         if (existing->prev)
         {
            prev = existing->prev;
         }
         if (prev)
         {
            prev->next = this;
         }
         existing->prev = this;
      }
   

   /// Insert a new UtlChain after existing..
   /**
    * This may be called only on an unlinked UtlChain
    */
   void chainAfter(UtlChain* existing)
      {
         assert(isUnLinked()); // not valid on a link that's in a chain

         prev = existing;
         next = existing->next;
         if (next)
         {
            next->prev = this;
         }
         existing->next = this;
      }

   ///@}

   // ================================================================
   /** @name                  List Operations
    *
    * These methods do the special handling for using a UtlChain as a list
    * header.  The UtlChain.next points to the head (first) UtlLink on the
    * list.  The UtlChain.prev points to the tail (last) UtlLink.
    *
    * The UtlLink objects on the list form a NULL-terminated chain - 
    * they do not point to the UtlChain that serves as the header.
    */
   ///@{

   /// Returns the head (first) UtlLink on the list (or NULL if the list is empty).
   UtlChain* listHead() const
      {
         return next;
      }

   /// Returns the tail (last) UtlLink on the list (or NULL if the list is empty).   
   UtlChain* listTail() const
      {
         return prev;
      }

   /// Returns the head (first) UtlLink on the list (or NULL if the list is empty).
   UtlLink* head() const
      {
         return (UtlLink*)next;
      }

   /// Returns the tail (last) UtlLink on the list (or NULL if the list is empty).   
   UtlLink* tail() const
      {
         return (UtlLink*)prev;
      }

   /// Insert this link into a list before an existing entry (before NULL == at the tail).
   void listBefore(UtlChain* list,    ///< the list to insert into
                   UtlChain* existing /**< the UtlLink for the position in the
                                       *   list to insert before.  NULL means
                                       *   at the end of the list. */
                   );
   /**<
    * @note
    * This method does not verify that the existing element is actually on the list; doing
    * so is the responsibility of the caller.  If the list is empty, existing must be NULL.
    */


   /// Insert this link into a list after an existing entry (after NULL == at the head).
   void listAfter(UtlChain* list,     ///< the list to insert into
                  UtlChain* existing  /**< the UtlLink for the position in the
                                       *   list to insert after.  NULL means
                                       *   at the beginning of the list. */
                  );
   /**<
    * @note
    * This method does not verify that the existing element is actually on the list; doing
    * so is the responsibility of the caller.  If the list is empty, existing must be NULL.
    */

   /// Remove a link from a list.
   UtlChain* detachFromList(UtlChain* listHead);
   /**<
    * @note
    * This method does not verify that the UtlLink
    * object being detached is actually on the specified list; doing
    * so is the responsibility of the caller.
    */

///@}   
   
/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:
};


/**
 * UtlLink implements linked lists of data blocks.
 * It may not be used directly because it is not thread safe; use one of the
 * classes derived from UtlList.
 *
 * In addition to the links forward (next) and backward (prev) provided by the
 * parent UtlChain, a UtlLink also points to an item whose place it implements
 * in the list (data). 
 *
 * @nosubgrouping
 */
class UtlLink : public UtlChain
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

   // ================================================================
   /** @name                  Traversal Operations
    *
    * These methods move forward and back in a chain of UtlLinks.
    */
   ///@{

   /// Returns the next UtlLink forward in a chain (or NULL for the end).
   UtlLink* next() const
      {
         return static_cast<UtlLink*>(UtlChain::next);
      }
   
   /// Returns the next UtlLink backward in a chain (or NULL for the end).
   UtlLink* prev() const
      {
         return static_cast<UtlLink*>(UtlChain::prev);
      }

   /// Linear search starting at this link for a matching data value.
   UtlLink* findDataRef(UtlContainable* target) const
      {
         UtlLink* theLink;
         for (theLink=const_cast<UtlLink*>(this);
              theLink && theLink->data != target;
              theLink=theLink->next())
         {
         }
         return theLink;
      }

   /// Linear search starting at this link for a matching data value.
   UtlLink* findNextHash(unsigned targetHash) const
      {
         UtlLink* theLink;
         for (theLink=const_cast<UtlLink*>(this);
              theLink && theLink->hash != targetHash;
              theLink=theLink->next())
         {
         }
         return theLink;
      }
   
   /// The containable object whose place in the list this UtlLink is tracking.
   UtlContainable*    data;
   /// The hash code for the containable object whose place in the list this UtlLink is tracking.
   unsigned           hash;

   ///@}

   // ================================================================
   ///@name                  Memory Management                      
   ///@{

   /// Get the total number of UtlLink blocks allocated.
   /**
    * Because the underlying UtlLinkPool implementation allocates UtlLinks in blocks,
    * this number will usually be slightly higher than the maximum number ever in use
    * (rounded up to the nearest UTLLINK_BLOCK_SIZE)
    */
   static size_t totalAllocated();

   ///@}
   
/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:
   friend class UtlChainPool;
   friend class UtlContainer;
   friend class UtlList;
   friend class UtlListIterator;
   friend class UtlSList;
   friend class UtlSListIterator;
   friend class UtlSortedList;
   friend class UtlHashBag;
   friend class UtlHashBagIterator;
   friend class UtlLinkTest;
   friend class UtlInit;

   // ================================================================
   /** @name                  Link Manipulation in a Chain
    *
    * These methods insert and remove this UtlLink in a chain.  They do not
    * do any special handling for the ends of a chain, so they can be used
    * in either NULL-terminated or circular chains.
    */
   ///@{
   
   /// Take the link block out of its list, and return the data pointer
   UtlContainable* unlink();
   /**<
    * @note
    * After this call, the UtlLink has been released, and the pointer to it
    * may not be used.
    */

   /// Insert a new UtlLink to newData before existing, returning the new UtlLink.
   static UtlLink* before(UtlChain* existing, UtlContainable* newData);

   /// Insert a new UtlLink to newData after existing, returning the new UtlLink.
   static UtlLink* after(UtlChain* existing, UtlContainable* newData);

   ///@}

   // ================================================================
   /** @name                  List Operations
    *
    * These methods do the special handling for using a UtlChain as a list
    * header.  The UtlChain.next points to the head (first) UtlLink on the
    * list.  The UtlChain.prev points to the tail (last) UtlLink.
    *
    * The UtlLink objects on the list form a NULL-terminated chain - 
    * they do not point to the UtlChain that serves as the header.
    */
   ///@{


   /// Insert a new item into a list before an existing entry (before NULL == at the tail).
   static UtlLink* listBefore(UtlChain* list,    ///< the list to insert into
                              UtlChain* existing,/**< the UtlLink for the position in the
                                                  *   list to insert before.  NULL means
                                                  *   at the end of the list. */
                              UtlContainable* newData ///< the new data item to be inserted.
                              );
   /**<
    * @note
    * This method does not verify that the existing element is actually on the list; doing
    * so is the responsibility of the caller.  If the list is empty, existing must be NULL.
    */


   /// Insert a new item into a list before an existing entry (after NULL == at the head).
   static UtlLink* listAfter(UtlChain* list,     ///< the list to insert into
                             UtlChain* existing, /**< the UtlLink for the position in the
                                                  *   list to insert after.  NULL means
                                                  *   at the beginning of the list. */
                             UtlContainable* newData ///< the new data item to be inserted.
                             );
   /**<
    * @note
    * This method does not verify that the existing element is actually on the list; doing
    * so is the responsibility of the caller.  If the list is empty, existing must be NULL.
    */

   /// Remove a link from a list.
   UtlContainable* detachFrom(UtlChain* listHead);
   /**<
    * @note
    * This method does not verify that the UtlLink
    * object being detached is actually on the specified list; doing
    * so is the responsibility of the caller.
    */

   /// Find the first matching target in the list by reference.
   static UtlLink* findData(UtlChain* list, UtlContainable* target) 
      {
         return list->next ? static_cast<UtlLink*>(list->next)->findDataRef(target) : NULL;
      }
   
   ///@}

   // ================================================================
   /** @name                  Constructor and Destructor
    *
    * @see UtlLinkPool for how a UtlLink is allocated and freed.
    */
   ///@{

   /// The UtlLink constructor is protected.
   /**
    * A UtlLink should only be instantiated by a call to UtlLinkPool::get
    * because the UtlLinkPool recycles them rather than allocating and
    * deallocating from the system heap.
    */
   UtlLink() :
      data(NULL),
      hash(0)
      {
      };

   /// Destructor
   /**
    * A UtlLink is only destructed when the UtlLinkPool destructor is invoked.
    */
   ~UtlLink()
      {
      };

   /// Get a UtlLink from the pool.
   static UtlLink* get();

   /// Return a UtlLink to the pool.
   void release();

   /// Recalculate the hash for this item
   void rehash();

/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:

   /// The allocator function to be passed to the UtlChainPool
   static void allocate(size_t    blocksize, ///< number of instances to allocate
                        UtlChain* blockList, ///< list header for first instance
                        UtlChain* pool       ///< list header for others
                        );
   

   /// The pool of available UltLink instances.
   static UtlChainPool* spLinkPool;  
};

/// Associate a key object (the parent UtlLink data) with its value object.
class UtlPair : public UtlLink
{
  protected:
   friend class UtlHashMap;
   friend class UtlHashMapIterator;
   friend class UtlHashBagIterator;
   friend class UtlInit;

   UtlContainable* value;

   UtlPair() :
      value(NULL)
      {
      };

   ~UtlPair()
      {
      }
   
   static UtlChainPool* spPairPool;

   /// Get a UtlPair from the pool.
   static UtlPair* get();

   /// Return a UtlPair to the pool.
   void release();

  private:
   /// The allocator function to be passed to the UtlChainPool
   static void allocate(size_t    blocksize, ///< number of instances to allocate
                        UtlChain* blockList, ///< list header for first instance
                        UtlChain* pool       ///< list header for others
                        );

};

#endif    // _UTLLINK_H_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _UtlList_h_
#define _UtlList_h_

//#define GLIST_SANITY_TEST
#ifdef LIST_SANITY_TEST
# include "assert.h"
#endif

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlLink.h"
#include "utl/UtlContainer.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlContainable ;

/**
 * UtlList is an abstract base class for list classes designed to contain any number
 * of objects derived from the UtlContainable class.  Like any UtlContainer, a
 * UtlList may contain objects of different UtlContainableType
 * (e.g. UtlInts and UtlVoidPtrs), however, sorting and comparison behavior
 * may be non-obvious or undefined, so this is not recommended.
 * 
 * Most list accessors and inquiry methods are performed by equality as 
 * opposed to by reference.  That is, the comparisons between UtlContainable
 * objects are made using the UtlContainable::isEqual or UtlContainable::compareTo
 * methods, so for example, two different UtlInt* values (having different pointer
 * values) would compare as equal if they both contained the same integer value.
 *
 * Some methods are concerned with references; these compare the actual UtlContainable*
 * pointer values, so for example list.containsReference(obj) call will search 
 * for a pointer match with each UtlContainable* on the list, matching only when
 * the value of the 'obj' pointer is found.
 * 
 * @see UtlContainable for the methods that must be implemented by a class for its
 * objects to be stored in any UtlContainer.
 *
 * Like other UtlContainer classes, UtlList is itself a UtlContainable, so one can have
 * lists of lists and other complex structures.  
 */
class UtlList : public UtlContainer, public UtlChain                                               
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
    static UtlContainableType TYPE ;    /** < Class type used for runtime checking */

/* ============================ CREATORS ================================== */

// this base class cannot be instantiated directly - the constructor is protected

// Destructor
    virtual ~UtlList();

/* ============================ MANIPULATORS ============================== */
   
    /**
     * Removes and returns the first item in the list (pop).
     * 
     * @return the first object if successful, otherwise null
     */
    UtlContainable* get() ;  

    /**
     * Remove the designated object by reference
     * (as opposed to searching for an equality match).  
     *
     * @return the object if successful, otherwise null
     */
    UtlContainable* removeReference(const UtlContainable* obj);    

    /**
     * Remove the designated object by equality (as opposed to by reference).
     */
    virtual UtlContainable* remove(const UtlContainable* object) = 0;

    /**
     * Remove the object at (zero-based) location N.
     *
     * @return the object removed from the list, or NULL if there was no object at index N
     */
    UtlContainable* removeAt(const size_t N);

    /**
     * Removes the designated objects from the list and frees the object 
     * by calling delete.
     */ 
    virtual UtlBoolean destroy(UtlContainable*);

    /**
     * Removes all elements from the list and deletes each one.
     */
    void destroyAll();

    /**
     * Removes all elements from the list without freeing the objects.
     */
    void removeAll();

    /**
     * Re-calculates hashes for all items
     */
    void rehash();

/* ============================ ACCESSORS ================================= */

    /**
     * Find the first occurence of the designated object by equality (as 
     * opposed to by reference).
     */
    virtual UtlContainable* find(const UtlContainable*) const = 0;

    /**
     * Return the element at position N or null if N is out of bounds.
     */
    virtual UtlContainable* at(size_t N) const;

    /**
     * Return the first element (head) of the list
     */
    virtual UtlContainable* first() const ;

    /**
     * Return the last element (tail) of the list
     */
    virtual UtlContainable* last() const ;

/* ============================ INQUIRY =================================== */

    /**
     * Return the total number of elements within the container
     */
    virtual size_t entries() const;

    /**
     * Return true of the container is empty (entries() == 0), otherwise false.
     */
    virtual UtlBoolean isEmpty() const;

    /**
     * Return true if the container includes the designated object.  Each 
     * element within the list is tested for equality against the designated 
     * object using the equals() method. 
     */
    virtual UtlBoolean contains(const UtlContainable* object) const;

    /**
     * Return true if the list contains the designated object reference.
     */
    virtual UtlBoolean containsReference(const UtlContainable *) const ;

    /**
     * Return the number of occurrences of the designated object
     */
    virtual size_t occurrencesOf(const UtlContainable* obj) const = 0;

    /**
     * Return the list position of the designated object or UTL_NOT_FOUND  if
     * not found.
     */
    virtual size_t index(const UtlContainable* obj) const = 0;


   /**
    * Get the ContainableType for the list as a contained object.
    */
   virtual UtlContainableType getContainableType() const;

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:


    /**
     * The UtlList constructor is protected - only subclasses may be instantiated
     */
    UtlList();
    
    friend class UtlListIterator;

    /**
     * notifyIteratorsOfRemove - called before removing any element in the collection
     */
    void notifyIteratorsOfRemove(UtlLink* element);

    /**
     * removeLink is used internally to manipulate the links.
     *
     * :NOTE: the caller must hold the mContainerLock
     *
     * This does not return a new value for the current list position;
     * this is because it will call the <some-list-iterator>::removing method on the
     * removed element, passing the new value.  This means the that current position
     * update is always done the same way no matter what routine did the removing.
     */
    virtual void removeLink(UtlLink* toBeRemoved);

#ifdef LIST_SANITY_TEST
#  define LIST_SANITY_CHECK { if (!sanityCheck()){ assert(FALSE); } }
    bool sanityCheck() const;
#else
#  define LIST_SANITY_CHECK /* sanityCheck() */
#endif

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
} ;

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlList_h_


//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _UtlListIterator_h_
#define _UtlListIterator_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlLink.h"
#include "utl/UtlIterator.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlContainable ;
class UtlList ;

/**
 * UtlListIterator allows developers to iterator (walks through) an UtlList.
 * 
 * @see UtlIterator
 * @see UtlList
 */
class UtlListIterator : public UtlIterator
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

    /**
     * Constructor accepting a source UtlList 
     */
    UtlListIterator(const UtlList& list) ;

    /**
     * Destructor
     */
    virtual ~UtlListIterator();

/* ============================ MANIPULATORS ============================== */

    /**
     * Return the next element.
     * 
     * @return The next element or NULL if no more elements are available.
     */
    virtual UtlContainable* operator()() ;

    /**
     * Reset the list by moving the iterator cursor to the location before the
     * first element. 
     */
    virtual void reset() ; 

    /**
     * Find the designated object, and reset the iterator so that it is the current position.
     * 
     * @return The  element or NULL if no more elements are available.
     */
    virtual UtlContainable* findNext(const UtlContainable* objectToFind) = 0;

    /**
     * Move the iterator to the last element within the iterator.
     */
    virtual UtlContainable* toLast() ;

/* ============================ ACCESSORS ================================= */

    /**
     * return the current value . 
     */     
    UtlContainable* item() const;

/* ============================ INQUIRY =================================== */

    /**
     * Is the iterator positioned at the last element? 
     */
    UtlBoolean atLast() const ;

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    UtlLink* mpCurrentNode;

    friend class UtlList;
    friend class UtlInit;

    /**
     * removing is called by the UtlList when an element is about to be
     * removed from the container.  The iterator must ensure that the element
     * for the removed node is not returned by any subsequent call.
     */
    virtual void removing(const UtlLink* node);


    static UtlLink const* OFF_LIST_END;
    
/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    
    static OsBSem sIteratorListLock;
} ;

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlListIterator_h_
// 
// 
// Copyright (C) 2005-2006 SIPez LLC.
// Licensed to SIPfoundry under a Contributor Agreement.
// 
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
// 
// Copyright (C) 2004-2006 Pingtel Corp.
// Licensed to SIPfoundry under a Contributor Agreement.
// 
// $$
//////////////////////////////////////////////////////////////////////////////


#ifndef _UtlLongLongInt_h_
#define _UtlLongLongInt_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "os/OsDefs.h"
#include "utl/UtlDefs.h"
#include "utl/UtlContainable.h"

// DEFINES
// MACROS

#if defined( WIN32 ) && !defined( WINCE )
#define strtoll _strtoui64
#endif
// Borrow this from the gcc include file "limits.h".
// LLONG_MIN and LLONG_MAX are defined by the ISO C99 standard but not by C++
// LONG_LONG_MIN and LONG_LONG_MAX are defined by gcc.
#ifndef LLONG_MAX
#  ifdef LONG_LONG_MAX
#    define LLONG_MAX LONG_LONG_MAX
#  else
#    define LLONG_MAX (9223372036854775807L)
#  endif
#endif

#ifndef LLONG_MIN
#  ifdef LONG_LONG_MAX
#    define LLONG_MIN LONG_LONG_MIN
#  else
#    define LLONG_MIN (-LLONG_MAX - 1L)
#  endif
#endif

// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * UtlLongLongInt is a UtlContainable wrapper for a "long long int".
 * This data type is officially part of C99, see http://www.open-std.org/jtc1/sc22/wg14/ .
 * C++ has de facto support as well.  The size of a "long long int" is guaranteed to be at least 64 bits.
 */
class UtlLongLongInt : public UtlContainable
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
    static const UtlContainableType TYPE ;    /**< Class type used for runtime checking */ 

/* ============================ CREATORS ================================== */

    /**
     * Constructor accepting an optional default value.
     */
    UtlLongLongInt(Int64 initialValue = 0) ;
      
    /**
     * Destructor
     */
    virtual ~UtlLongLongInt();

/* ============================ OPERATORS ============================== */

    // Declare prefix and postfix increment operators.
    UtlLongLongInt& operator++();       // Prefix increment operator
    UtlLongLongInt operator++(int);     // Postfix increment operator

    // Declare prefix and postfix decrement operators.
    UtlLongLongInt& operator--();       // Prefix decrement operator
    UtlLongLongInt operator--(int);     // Postfix decrement operator

    // Conversion to long long int
    operator Int64() { return mValue; }

/* ============================ MANIPULATORS ============================== */

    /**
     * Set a new long long int value for this object.
     *
     * @returns the old value
     */
    Int64 setValue(Int64 iValue);

    //! Convert a ascii string rep. to long long int
    static Int64 stringToLongLong(const char* longLongString);

/* ============================ ACCESSORS ================================= */

    /**
     * Get the long long int wrapped by this object.
     */
    Int64 getValue() const ;    

    /**
     * Calculate a unique hash code for this object.  If the equals
     * operator returns true for another object, then both of those
     * objects must return the same hashcode.
     */
    virtual unsigned hash() const ;

    /**
     * Get the ContainableType for a UtlContainable derived class.
     */
    virtual UtlContainableType getContainableType() const;

/* ============================ INQUIRY =================================== */

    /**
     * Compare the this object to another like-object.  Results for 
     * designating a non-like object are undefined.
     *
     * @returns 0 if equal, < 0 if less then and >0 if greater.
     */
    virtual int compareTo(UtlContainable const *) const ;    

    /**
     * Test this object to another like-object for equality.  This method 
     * returns false if unlike-objects are specified.
     */
    virtual UtlBoolean isEqual(UtlContainable const *) const ; 

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    Int64 mValue ;    /** < The long long int wrapped by this object */ 

} ;

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlLongLongInt_h_
//
// Copyright (C) 2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

class UtlObservable;

/**
 * Generic interface for any object which is an observer
 * of an observable.
 */ 
class UtlObserver
{
public:
    /**
     * Notification method which the observer must implement.  The 
     * observable's (also, subject) resposibility is to notify 
     * the observers of state changes.  The observable will notify
     * the observers by invoking this onNotify method.
     *
     * @param subject The observable which invoked this method.
     * @param code An integer notification value.  For example, it
     *                  can be used to indicate the observable's state.
     * @param pUserData A reference to any object that the observable may
     *                  pass to the observer.
     */
    virtual void onNotify(UtlObservable* subject, int code, void *pUserData) = 0;
};

/**
 * Simple interface for any object which is observable,
 * meaning that observers can register to be notified
 * of the observable's state changes.
 */ 
class UtlObservable
{
public:
    /**
     * Registers a listener of this observable.
     * Derived classes of UtlObservable should store
     * its observers in a collection.
     *
     * @param observer The observer that wants to "listen to"
     *                 this observable's state changes.
     */ 
    virtual void registerObserver(UtlObserver* observer) = 0;

    /**
     * Removes a listener of this observable.
     * Derived classes of UtlObservable should remove
     * this observer from it's collection.
     *
     * @param observer The observer that no longer wants to "listen to"
     *                 this observable's state changes.
     */ 
    virtual void removeObserver(UtlObserver* observer) = 0;
protected:
    
    /**
     * The observable calls this to notify its
     * observers of a change.
     * Derived classes should iterate through their collection
     * of observers and call UtlObserver->onNotify .
     * 
     * @param code An integer notification value.  For example, it
     *                  can be used to indicate the observable's state.
     * @param pUserData A reference to any object that the observable may
     *                  pass to the observer.
     */ 
    virtual void notify(int code, void *pUserData) = 0;

};


//
// Copyright (C) 2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlObservableImpl_h_
#define _UtlObservableImpl_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "os/OsLock.h"
#include "os/OsMutex.h"
#include "utl/UtlObservable.h"
#include "utl/UtlSList.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

class UtlObservableImpl : public UtlObservable
{
public:
    /**
     * Constructor.
     */
    UtlObservableImpl();
    
    /**
     * Implementation of UtlObservable::registerObserver.
     * 
     * @param observer The observer that wants to "listen to"
     *                 this observable's state changes.
     */ 
    virtual void registerObserver(UtlObserver* observer) = 0;

    /**
     * Implementation of UtlObservable::removeObserver.
     * 
     * @param observer The observer that no longer wants to "listen to"
     *                 this observable's state changes.
     */ 
    virtual void removeObserver(UtlObserver* observer) = 0;
protected:
    
    /**
     * Implementation of UtlObservable::notify.
     * 
     * @param code An integer notification value.  For example, it
     *                  can be used to indicate the observable's state.
     * @param pUserData A reference to any object that the observable may
     *                  pass to the observer.
     */ 
    virtual void notify(int code, void *pUserData);    
private:
    /**
     * Collection of observers.
     */
    UtlSList mObservers;
    
    /**
     *  For synchronization locking
     */
    OsMutex mMutex;
};

#endif
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlRandom_h_
#define _UtlRandom_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * A simple utility class that provides random number functionality.  
 * Generally, you should create a UtlRandom class for each of your thread
 * contexts.  The implementation uses rand() and srand().
 */
class UtlRandom
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

/* ============================ CREATORS ================================== */

   /**
    * Default constructors, seeds the random number generator with the current
    * time.
    */
   UtlRandom();

   /**
    * Constructor accepting a seed for the random number generator.
    */
   UtlRandom(int seed);
     
   /**
    * Destructor
    */
   virtual ~UtlRandom();

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */

   /**
    * Generate a pseudo-random number between 0 and RAND_MAX (defined in 
    * stdlib.h)
    */
   int rand() ;

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:

};

/* ============================ INLINE METHODS ============================ */

#endif  // _UtlRandom_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _REGEX_H
#define _REGEX_H

#include <string.h>
#include <pcre.h>
#include "utl/UtlString.h"

/**
 * RegEx implements Perl-compatible regular expressions
 *
 * A simple and small C++ wrapper for PCRE.
 * PCRE (or libprce) is the Perl Compatible Regular Expression library.
 * http://www.pcre.org/
 *
 * Adapted for the sipXportLib from the regex.hpp wrapper:
 *
 * regex.hpp 1.0 Copyright (c) 2003 Peter Petersen (pp@on-time.de)
 * Simple C++ wrapper for PCRE
 *
 *   This source file is freeware. You may use it for any purpose without
 *   restriction except that the copyright notice as the top of this file as
 *   well as this paragraph may not be removed or altered.
 *
 * Original wrapper by Peter Petersen, adapted to sipX by Scott Lawrence
 *
 * The regular expression is compiled in the constructor, and then may be applied
 * to target strings using one of the Search interfaces.  The results are obtained
 * using the Results interfaces.
 *
 * This class is a wrapper around the PCRE package (see the project INSTALL for a
 * pointer to where PCRE can be found).  All the Options variables are identical
 * to those in pcre.h
 *
 * @note
 * Compiling the regular expressions is usually expensive compared to executing
 * the actual search, so if an expression is frequently reused, it is best to
 * compile it only once and then construct the expression to use in the search
 * using the copy constructor.
 * 
 *
 * @nosubgrouping
 */
class RegEx
{
 public:

// ================================================================
/** @name    Constructors, Destructor, and Expression Information
 */
///@{
   
   /// Compile a regular expression to create the matching object.
  RegEx( const char * regex, //< the regular expression
         int               options = 0, //< any sum of PCRE options bits
         unsigned long int maxDepth = MAX_RECURSION // see MAX_RECURSION
         );
  /**<
   * If compiling the regular expression fails, an error message string is
   * thrown as an exception.
   * For options documentation, see 'man pcre'
   */

  /// Default maximum for the recursion depth in searches.
  static const unsigned long int MAX_RECURSION;
  /**<
   * The PCRE internal match() function implements some searches by recursion.
   * This value is the default maximumm allowed depth for that recursion.  It can
   * be changed to some other value by passing the maxDepth option argument to the
   * RegEx constructor.  It is set at compile time from the SIPX_MAX_REGEX_RECURSION
   * macro, if that value is defined.
   *
   * If the maximum is exceeded, the match fails.
   *
   * If this or the maxDepth constructor argument are set to zero, then no limit
   * is enforced (use with caution).
   *
   * See the discussions of stack size in the pcre documentation.
   *
   * @note Caution
   * Test your limits carefully - in versions of PCRE prior to 6.5, there is no
   * way to limit recursive matches, so this is implemented as a limit on the
   * total number of calls to 'match' (PCRE_EXTRA_MATCH_LIMIT); this can dramatically
   * shorten the length of the strings that a pattern that has nested parenthesis
   * will match.
   */
  
  /// Construct from a constant regex to save compilation time. 
  RegEx( const RegEx& );
  /**<
   * If you are using the same constant regular expression frequently, you can
   * use this constructor to save the time to compile and study it.  First, declare
   * a private constant copy of your expression - this will be compiled by PCRE
   * just once when it is instantiated:
   * \code
   * static const RegEx FooNumbers("foo([0-9]+)");
   * \endcode
   * Then in your method, construct a copy of it to use when matching strings:
   * \code
   *    RegEx fooNumbers(FooNumbers);
   *    fooNumbers.Search(someString);
   * \endcode
   * Constructing this copy does not require a PCRE call to compile the expression.
   */

  ~RegEx();

  /// Count the number of possible substrings returned by this expression
  int SubStrings(void) const;
  /**<
   *   SubStrings() @returns the number of substrings defined by
   *   the regular expression.
   *
   *   The match of the entire expression is also considered a substring, so the return
   *   value will always be >= 1.
   *
   *   This method is especially useful when the regular expression is loaded
   *   from some external source.  For a hard-coded expression, the return is
   *   a constant, so you really don't need this method.
   */

///@}

// ================================================================
/** @name Searching
 *
 * The searching methods apply a compiled regular expression to a subject
 * string.  All searching methods return a boolean result indicating whether
 * or not some match was found in the subject.  To get information about
 * the match, use the Results methods.
 */
///@{

  /// Search a string for matches to this regular expression
  bool Search( const char * subject,  ///< the string to be searched for a match
               int len = -1,          ///< the length of the subject string
               int options = 0        ///< sum of any PCRE options flags
               );
  /**<
   *    Apply the regular expression to the subject string.
   *    Optional parameter len can be used to pass the subject's length to
   *    Search(). If not specified (or less than 0), strlen() is used
   *    internally to determine the length. Parameter options can contain
   *    any combination of options; for options documentation, see 'man pcre'
   *    @returns true if a match is found.
   */

  /// Search a string starting at some offset for matches to this regular expression
  bool SearchAt(const char* subject,  ///< the string to be searched for a match
                int offset,           ///< offset to begin search in subject string
                int len = -1,         ///< the length of the subject string
                int options = 0       ///< sum of any PCRE options flags
                );
  /**<
   *    Apply the regular expression to the subject string, starting at the given offset.
   *    If the length is not specified, then strlen(subject) is used.
   *    Parameter options can contain
   *    any combination of options; for options documentation, see 'man pcre'
   *    @returns true if a match is found.
   *    @note
   *    The start of this search is not considered the start of the subject for
   *    the purposes of anchoring.  So if the expresssion is "^xx", then subject
   *    "fooxx" will not match, even if offset is passed as '3'.
   *    
   */


  /// Repeat the last search operation, starting immediately after the previous match
  bool SearchAgain( int options = 0        ///< sum of any PCRE options flags
                   );
  /**<
   *    SearchAgain() applies the regular expression to the same
   *    subject last passed to Search or SearchAt, but restarts the search after the last match.
   *    Subsequent calls to SearchAgain() will find all matches in the subject.
   *    @returns true if a further match is found.
   *    Example:
   *    \code
   *       RegEx Pattern("A[0-9]");
   *       const char* value = "xyzA1abcA2def";
   *       for (matched = Pattern.Search(value); matched; matched = Pattern.SearchAgain())
   *       {
   *          printf("%s\n", Pattern.Match());
   *       }
   *    \endcode
   *    Would print "A1\n" and then "A2\n".
   *
   * @note Prefer MatchString over the less efficient Match 
   */

///@}
// ================================================================
/** @name     Results
 *
 * The results methods provide information about the matches based on the
 * results of the most recent Searching method call.  It is an error to
 * call any of these methods unless the most recent Searching call returned
 * 'true'.
 *
 * The substring index must be less than the result of RegEx::SubStrings on
 * the regular expression, but may also be zero or -1 as follows:
 * - (-1) returns the last searched subject.
 * - (0) returns the match of the complete regular expression.
 * - (1) returns $1, etc.
 *
 */
///@{

  /// Get the maximum substring value from the most recent search.
  int Matches();
  /**<
   * May only be called after a successful search using one of the searching interfaces,
   * and applies to the results of that call. 
   * - any negative return indicates a caller error - the preceeding search call did not match
   * - a return value of 1 indicates that the entire pattern matched, but no substrings
   *   within it matched.
   * - a return value of N > 1 indicates that the full string and N-1 substrings are available
   *
   * @note
   * If the expression has internal optional matches, they may not be matched; for example the
   * expression "(foo|(bar))(bing)" matches subject "foobingo", and Matches would return 4
   * because substring 3 "bing" was matched, but substring 2 would be the null string for
   * that match.
   * 
   */


  /// Append a match from the last search operation to a UtlString.
  bool MatchString(UtlString* matched, /**< string to append the match to -
                                        * may be NULL, in which case no string is returned,
                                        * but the return code still indicates whether or not
                                        * this substring was matched.
                                        */
                   int i = 0           /**< which substring to append from the last search
                                        * - Match(-1) returns the last searched subject.
                                        * - Match(0) returns the match of the complete regular expression.
                                        * - Match(i>0) returns $i
                                        */
                   );
  /**<
   * May only be called after a successful search
   * and applies to the results of that call. 
   * @returns true if there was an ith match, false if not
   *
   * Example:@code
   * RegEx matchBs("((B)B+)");
   * UtlString getB;
   * UtlString getBs;
   * if (matchB.Search("xxaBBBBcyy"))
   * {
   *   matchB.MatchString(&getBs,0);
   *   matchB.MatchString(&getB,2);
   * }
   * @endcode
   * would set the UtlStrings
   *  - getBs to "BBBB"
   *  - getB  to "B"
   */
  

  /// Get the position and length of a match in the subject
  bool Match(const int i, ///< input - must be < SubStrings() */
             int& offset, ///< output - offset in last subject of the n'th match
             int& length  ///< output - length in last subject of the n'th match
             );
  /**<
   * May only be called after a successful
   * call to one of the searching methods, and applies to the results of
   * that call.
   *
   * Parameter i must be less than SubStrings().
   * - Match(-1) returns the last searched subject.
   * - Match(0) returns the match of the complete regular expression.
   * - Match(1) returns $1, etc.
   *
   * @returns true if the last search had an n'th match, false if not
   *
   * Example:@code
   * RegEx matchABCs("A+(B+)(C+)");
   * UtlString subject("xAABBBBC");
   * int offset = 1;
   * if (matchABCs.SearchAt(subject, offset))
   * {
   *   int all    = matchABCs.Match(0, allStart, allLength); 
   *   int firstB = matchABCs.Match(1, firstB, numBs); 
   *   int firstC = matchABCs.Match(2, firstC, numCs); 
   * }
   * @endcode
   * would set the values
   *  - allStart = 1, allLength = 2
   *  - firstB = 3, numBs = 4
   *  - firstC = 7, numCs = 1
   * 
   * @note
   * The returned start position is relative to the beginning of the subject string,
   * not from any offset value.
   * 
   */


  /// Get the position of a match in the subject
  int MatchStart(const int i ///< input - must be < SubStrings() */
                 );
  /**<
   * May only be called after a successful call to one of the searching
   * methods, and applies to the results of that call.
   *
   * Parameter i must be less than SubStrings().
   * - Match(-1) returns the last searched subject.
   * - Match(0) returns the match of the complete regular expression.
   * - Match(1) returns $1, etc.
   *
   * This is useful when searching at an offset in a string to check whether or not
   * the match was at the offset or somewhere later in the string.
   *
   * Example:@code
   * RegEx matchABCs("A+(B+)(C+)");
   * UtlString subject("xAABBBBC");
   * int offset = 1;
   * bool result = (   (matchABCs.SearchAt(subject, offset))
   *                && (matchABCs.MatchStart(0) == offset));
   * @endcode
   * Note that this is not the same as haveing written the regular expression so
   * that it is anchored: "^A+(B+)(C+)" because the anchor always refers to the
   * actual start of the string (in the example, before the 'x'), even when used
   * with an offset.  So the 'result' variable in the example would be true.
   */

  /// Append string preceeding the most recently matched value to a UtlString.

  bool BeforeMatchString(UtlString* before /**< string to append to -
                                            * may be NULL, in which case no string is returned,
                                            * but the return code still indicates whether or not
                                            * there was some string preceeding the last match.
                                            */
                         );
  /**<
   * May only be called after a successful search and applies to
   * the results of that call. This is equivalent to the Perl $` variable.
   *
   * @returns true if there was a string before the match, false if not 
   * Example:@code
   * RegEx matchB("B");
   * UtlString getBefore;
   * if (matchB.Search("xxaBcyy"))
   * {
   *   matchB.BeforeMatchString(&getBefore);
   * }
   * @endcode
   *
   * would set the UtlString getBefore to "xxa".
   */
  
  /// Append string following the most recently matched value to a UtlString.
  bool AfterMatchString(UtlString* before /**< string to append to -
                                            * may be NULL, in which case no string is returned,
                                            * but the return code still indicates whether or not
                                            * there was some string following the last match.
                                            */
                         );
  /**<
   * May only be called after a successful search and applies to
   * the results of that call. This is equivalent to the Perl $' variable.
   *
   * @returns true if there was a string following the match, false if not 
   * Example:@code
   * RegEx matchB("B");
   * UtlString getAfter;
   * if (matchB.Search("xxaBcyy"))
   * {
   *   matchB.AfterMatchString(&getAfter);
   * }
   * @endcode
   *
   * would set the UtlString getAfter to "cyy".
   */

  /// Get the offset of the first character past the matched value
  int AfterMatch(int i ///< the substring specifier 
                 );
  /**<
   * May only be called after a successful search and applies to
   * the results of that call. 
   *
   * Example:@code
   * RegEx matchBseq("A+(B+)C+");
   * if (matchBseq.Search("xxAABBBCCCyy"))
   * {
   *   int afterB = matchBseq.AfterMatch(1);
   *   int afterC = matchBseq.AfterMatch(0);
   * }
   * @endcode
   *
   * would set
   * - afterB = 7
   * - afterC = 10
   */
  

  /// Get a string matched by a previous search
  const char * Match(int i = 0 /**< must be < SubStrings() */ );
  /**<
   * @note
   * This does more memory allocation and data copying than any of the other results methods;
   * use one of the others when possible.
   * 
   *
   * May only be called after a successful search, and applies to the results of
   * that call. Parameter i must be less than
   * SubStrings().
   * - Match(-1) returns the last searched subject.
   * - Match(0) returns the match of the complete regular expression.
   * - Match(1) returns $1, etc.
   * @returns a pointer to the ith matched substring.
   */

///@}

 private:
  /*
   * Use the copy constructor above instead of the = operator.
   */
  RegEx& operator=(const char *);

  void ClearMatchList(void);

  pcre * re;
  size_t re_size;
  pcre_extra * pe;
  bool allocated_study;
  size_t  study_size;
  int substrcount;         // maximum substrings in pattern
  const char * subjectStr; // original subject
  int subjectLen;          // original length
  int lastStart;           // offset of start for most recent Search or SearchAgain
  int lastMatches;         // pcre_exec return for most recent Search or SearchAgain
  int * ovector;           // results from (and workspace for) pcre_exec
  const char * * matchlist;// string cache for Match
};

#endif // _REGEX_H
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlRscStore_h_
#define _UtlRscStore_h_

#include "utl/UtlRscTrace.h"

#ifdef RSC_TEST


// SYSTEM INCLUDES
#include "os/OsDefs.h"
#include "os/OsBSem.h"
#include "os/OsRWMutex.h"
#include "os/OsStatus.h"

// APPLICATION INCLUDES
// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlRscTrace;

//:Database of active Rscs.
// The UtlRscStore maintains a database of active Rscs (i.e., those Rscs
// that have been started by the low level OsSysRsc class).  Since the
// OsRscTask is the only task that should be accessing the Rsc database
// there is no need to serialize access (and no locking).<br>
// <br>
// Each entry in the database is a key/value pair where the key corresponds
// to a Rsc ID and the value is the pointer to the corresponding OsRsc
// object.  Duplicate keys are not allowed.
class UtlRscStore
{
friend UtlRscTrace;

/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

   enum StoreInitSize { RSC_STORE_INIT_SIZE = 1000000 };

/* ============================ CREATORS ================================== */

   UtlRscStore(int initialStoreSize = RSC_STORE_INIT_SIZE);
     //:Default constructor

   virtual
   ~UtlRscStore();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   OsStatus insert(int RscId, char* pRsc);
     //:Insert the indicated Rsc into the database of active Rscs.
     // Return OS_SUCCESS if successful, OS_NAME_IN_USE if the key is
     // already in the database.

   OsStatus remove(int RscId);
     //:Remove the indicated Rsc from the database of active Rscs.
     // Return OS_SUCCESS if the indicated RscId is found, return
     // OS_NOT_FOUND if there is no match for the specified key.

   void cleanUp();

/* ============================ ACCESSORS ================================= */

   int getActiveRscs(char* activeRscs[], int size);
     //:Get an array of pointers to the Rscs that are currently active.
     // The caller provides an array that can hold up to <i>size</i> OsRsc
     // pointers. This method will fill in the <i>activeRscs</i> array with
     // up to <i>size</i> pointers. The method returns the number of pointers
     // in the array that were actually filled in.

   void getStoreStats(unsigned& nInserts, unsigned& nRemoves) const;
     //:Get the number of insertions and removals for the Rsc database.

   int numEntries(void) const;
     //:Return the number of key-value pairs in the name database.

/* ============================ INQUIRY =================================== */

   UtlBoolean isEmpty(void) const;
     //:Return TRUE if the Rsc database is empty.

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
   UtlHashMap mDict;          // hash table used to store the key/value
                                    //  pairs
   unsigned long mNumInserts;            // number of insertions into the database
   unsigned long mNumRemoves;            // number of removals from the database

   OsRWMutex mDictRWLock;
   UtlRscStore(const UtlRscStore& rUtlRscStore);
     //:Copy constructor (not implemented for this class)

   UtlRscStore& operator=(const UtlRscStore& rhs);
     //:Assignment operator (not implemented for this class)

#ifdef TEST
   static bool sIsTested;
     //:Set to true after the tests for this class have been executed once

   void test();
     //:Verify assertions for this class

   // Test helper functions
   void testCreators();
   void testManipulators();
   void testAccessors();
   void testInquiry();

#endif TEST
};

/* ============================ INLINE METHODS ============================ */
#endif // RSC_TEST

#endif  // _UtlRscStore_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlRscTrace_h_
#define _UtlRscTrace_h_

#define RSC_TEST
#undef RSC_TEST

#ifdef RSC_TEST

// SYSTEM INCLUDES
#include "utl/UtlRscStore.h"
#include <os/OsMutex.h>

// APPLICATION INCLUDES
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//:A class used to keep track of the number of resource allocations and frees
// This class is used in conjunction with instrumented versions of the global
// new and delete operators.
class UtlRscTrace
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
   static unsigned long sAllocCnt; // Track the number of memory allocs
   static unsigned long sFreeCnt;  // Track the number of memory frees
   static int           sTraceFlag;// If non-zero, print a line of info
                                   //  for every call to new()/delete()
   static unsigned long sStartTime;  // 
   static UtlRscStore mResourceStore;

   enum RscType
   {
          NONE          = 0,
      MEMORY    = 1,   
      OSSOCKET  = 2,       
      OSMSGQ    = 3,  
      OSBSEM    = 4,
          OSCSEM        = 5,
          OSMUTEX       = 6,
          OSRWMUTEX     = 7,
          OSTIMER       = 8,
          OSTASK        = 9
   };


/* ============================ CREATORS ================================== */

   UtlRscTrace();
     //:Default constructor (and take a checkpoint)

   UtlRscTrace(const UtlRscTrace& rRscTrace);
     //:Copy constructor

   virtual
   ~UtlRscTrace();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   UtlRscTrace& operator=(const UtlRscTrace& rhs);
     //:Assignment operator

   virtual void checkpoint();
     //:Remember the count of outstanding memory allocations

   static void setTraceFlag(int flag) { sTraceFlag = flag; };
    //: Set trace flag, if non-zero, print a line of info

   static int enableMemTracking(int taskId = 0);
    //: Set trace flag, if non-zero, print a line of info

   static int enableMsgQTracking(int taskId = 0);
    //: Set trace flag, if non-zero, print a line of info

   static int enableBSemTracking(int taskId = 0);
    //: Set trace flag, if non-zero, print a line of info

   static int enableCSemTracking(int taskId = 0);
    //: Set trace flag, if non-zero, print a line of info

   static int enableMutexTracking(int taskId = 0);
    //: Set trace flag, if non-zero, print a line of info

   static int enableRWMutexTracking(int taskId = 0);
    //: Set trace flag, if non-zero, print a line of info

   static int enableTimerTracking(int taskId = 0);
    //: Set trace flag, if non-zero, print a line of info

   static int enableTaskTracking(int taskId = 0);
    //: Set trace flag, if non-zero, print a line of info

   static int enableSocketTracking(int taskId = 0);
    //: Set trace flag, if non-zero, print a line of info

   static int disableTracking();
    //: Set trace flag, if non-zero, print a line of info

   static void addAllocCnt(int addr,
                                                  int taskId);
    //: Add allocCnt for the task, used for OsSocket tracking

   static void addAllocCnt(int size,
                                                  int addr,
                                                  int taskId);
    //: Add allocCnt for the task, used for memory/OsMutex/OsRWMutex tracking

        static void addAllocCnt(int size,
                                                          int addr,
                                                          const char* name, 
                                                          int pArg, 
                                                          int priority, 
                                                          int options,
                                                          int taskId);
    //: Add allocCnt for the task, used for OsTask tracking

        static void addAllocCnt(int state,
                                                          int addr,
                                                          int timerId, 
                                                          int type, 
                                                          int taskId);
    //: Add allocCnt for the task, used for OsTimer/OsCSem tracking

        static void addAllocCnt(int options,
                                                          int addr,
                                                          int state, 
                                                          int taskId);
    //: Add allocCnt for the task, used for OsBSem tracking

        static void addAllocCnt(int addr,
                                                          const char* name, 
                                                          int taskId);
    //: Add allocCnt for the task, used for OsMsgQ tracking

        static void addFreeCnt(int addr, int taskId = 0);
    //: Add freeCnt for the task

/* ============================ ACCESSORS ================================= */

   static void showMem(int taskId = 0);

   static int delta();
     //:Return the change to the number of outstanding memory allocations
     //:since the last checkpoint.

   static int delta(int taskId);
     //:Return the change to the number of outstanding memory allocations
     //:since the last checkpoint.

   static int allocCnt(int taskId = 0);
     //:Return the number of memory allocations (monotonically increasing)

   static int rscStatus();
     //:Return the number of memory frees (monotonically increasing)

   static int freeCnt(int taskId = 0);
     //:Return the number of memory frees (monotonically increasing)

   static int netAllocCnt();
     //:Return the net number of allocations (allocCnt - freeCnt)

   static int netAllocCnt(int taskId);
     //:Return the net number of allocations (allocCnt - freeCnt)

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
        static long mCheckpoint; // Used to remember the net number of 
                     // allocations at time of checkpoint
        static OsMutex    *mpResourceStoreLock;

        static UtlRscStore mUtlRscStore;

        static int mTaskId;
};


/* ============================ INLINE METHODS ============================ */
#endif // RSC_TEST

#endif  // _UtlRscTrace_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlSList_h_
#define _UtlSList_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlList.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlContainable;

/**
 * UtlSList is a singularly linked list designed to contain any number
 * of UtlContainable derived object.  The list may contain non-like objects 
 * (e.g. UtlInts and UtlVoidPtrs), however, sorting and comparison behavior
 * may be non-obvious.
 * 
 * Most list accessors and inquiry methods are performed by equality as 
 * opposed to by referencing (pointers).  For example, a list.contains(obj) 
 * call will loop through all of the list objects and test equality by calling
 * the isEquals(...) method.  A  list.containsReference(obj) call will search 
 * for a pointer match.
 * 
 * @see UtlSListIterator
 * @see UtlList
 * @see UtlContainer 
 * @see UtlContainable
 */
class UtlSList : public UtlList
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
    static const UtlContainableType TYPE;

/* ============================ CREATORS ================================== */

    /**
     * Default Constructor
     */
    UtlSList();


/* ============================ MANIPULATORS ============================== */

    /**
     * Append the designated containable object to the end of this list.
     * 
     * @return the object if successful, otherwise null
     */
    virtual UtlContainable* append(UtlContainable* obj) ;

    /// Insert the designated containable object at the designated position.
    virtual UtlContainable* insertAt(size_t N,           ///< zero-based position obj should be
                                     UtlContainable* obj ///< object to insert at N
                                     );
    /**<
     * It is an error to specify N > entries()
     *
     * @return obj if successful, NULL if N > entries
     */

    /**
     * Inserts the designated containable object at the end postion (tailer).
     * 
     * @return the object if successful, otherwise null
     */
    virtual UtlContainable* insert(UtlContainable* obj) ;

    /**
     * Remove the designated object by equality (as opposed to by reference).
     */
    virtual UtlContainable* remove(const UtlContainable *);  

    /**
     * Removes the designated objects from the list and frees the object 
     * by calling delete.
     */ 
    virtual UtlBoolean destroy(UtlContainable *);    


/* ============================ ACCESSORS ================================= */


    /**
     * Find the first occurence of the designated object by equality (as 
     * opposed to by reference).
     */
    virtual UtlContainable* find(const UtlContainable *) const ;

/* ============================ INQUIRY =================================== */


    /**
     * Return the number of occurrences of the designated object
     */
    virtual size_t occurrencesOf(const UtlContainable* obj) const ;

    /**
     * Return the list position of the designated object or UTL_NOT_FOUND  if
     * not found.
     */
    virtual size_t index(const UtlContainable* obj) const ;


    /**
     * Get the ContainableType for the hash bag as a contained object.
     */
    virtual UtlContainableType getContainableType() const;

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    friend class UtlSListIterator;


    /**
     * insertAfter is used by UtlListIterator::insertAfterPoint
     */
    virtual UtlContainable* insertAfter(UtlLink* afterNode, UtlContainable* object);
    
/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
        
} ;

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlSList_h_


//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlSListIterator_h_
#define _UtlSListIterator_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlListIterator.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlContainable ;
class UtlSList ;

/**
 * UtlSListIterator allows developers to iterator (walks through) an UtlSList.
 * 
 * @see UtlIterator
 * @see UtlSList
 */
class UtlSListIterator : public UtlListIterator
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

    /**
     * Constructor accepting a source UtlSList 
     */
    UtlSListIterator(const UtlSList& list) ;


    /**
     * Find the designated object, and reset the iterator so that it is the current position.
     * 
     * @return The  element or NULL if no more elements are available.
     */
    virtual UtlContainable* findNext(const UtlContainable* objectToFind) ;

    /**
     * Insert the designated element after the current iterator
     * position.
     */
    UtlContainable* insertAfterPoint(UtlContainable*) ;

/* ============================ ACCESSORS ================================= */


/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    friend class UtlSList;
    

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

} ;

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlSListIterator_h_


//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlSortedList_h_
#define _UtlSortedList_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlList.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlContainable;

/**
 * UtlSortedList is a list that is always sorted
 * 
 * Most list accessors and inquiry methods are performed by equality as 
 * opposed to by referencing (pointers).  For example, a list.contains(obj) 
 * call will loop through all of the list objects and test equality by calling
 * the isEquals(...) method.  A  list.containsReference(obj) call will search 
 * for a pointer match.
 * 
 * @see UtlSListIterator
 * @see UtlList
 * @see UtlContainer
 * @see UtlContainable
 */
class UtlSortedList : public UtlList
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
    static const UtlContainableType TYPE;

/* ============================ CREATORS ================================== */

   /**
    * Default Constructor
    */
   UtlSortedList();

/* ============================ MANIPULATORS ============================== */

    /**
     * Inserts the designated containable object into the list
     * 
     * @return the object if successful, otherwise null
     */
    virtual UtlContainable* insert(UtlContainable* obj);

    /**
     * Remove the designated object by equality (as opposed to by reference).
     */
    virtual UtlContainable* remove(const UtlContainable*);


/* ============================ ACCESSORS ================================= */

    /**
     * Find the first occurrence of the designated object by equality (as 
     * opposed to by reference).
     */
    virtual UtlContainable* find(const UtlContainable*) const;

/* ============================ INQUIRY =================================== */

    /**
     * Return the list position of the designated object or UTL_NOT_FOUND  if
     * not found.
     */
    virtual size_t index(const UtlContainable* obj) const;

    /**
     * Return the number of occurrences of the designated object
     */
    virtual size_t occurrencesOf(const UtlContainable* obj) const;


    /**
     * Get the ContainableType for the list as a contained object.
     */
    UtlContainableType getContainableType() const;
    

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    friend class UtlSortedListIterator;
    
    typedef enum {POSITION, EXACTLY} MatchType;

    /**
     * Return the first UtlLink which is greater or equal to the designated
     * object, or NULL if not found.
     *
     * The caller must hold the mContainerLock
     */
    UtlLink* findNode(UtlLink* starting, MatchType match, const UtlContainable* obj) const;

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    /* for now, don't provide a copy constructor */
    UtlSortedList(UtlSortedList& rhs);
};

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlSortedList_h_


//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlSortedListIterator_h_
#define _UtlSortedListIterator_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlListIterator.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlContainable;
class UtlSortedList;

/**
 * UtlSortedListIterator allows developers to iterator (walks through) an 
 * UtlSortedList.
 * 
 * @see UtlIterator
 * @see UtlSortedList
 */
class UtlSortedListIterator : public UtlListIterator
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

    /**
     * Constructor accepting a source UtlSortedList 
     */
    UtlSortedListIterator(const UtlSortedList& list);
   


/* ============================ MANIPULATORS ============================== */


    /**
     * Find the designated object, and reset the iterator so that it is the current position.
     * 
     * @return The  element or NULL if no more elements are available.
     */
    virtual UtlContainable* findNext(const UtlContainable* objectToFind);

    
/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    friend class UtlSortedList;
    

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

};

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlSortedListIterator_h_


//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlString_h_
#define _UtlString_h_

// SYSTEM INCLUDES
#include "os/OsDefs.h"

// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlCopyableContainable.h"

// DEFINES
#define DEFAULT_UTLSTRING_CAPACITY 100 ///< initial capacity unless overridden by the constructor

// MACROS
// EXTERNAL FUNCTIONS
#if defined(_VXWORKS)
#ifdef __cplusplus
extern "C" {
#endif

extern int strncasecmp( const char *s1, const char *s2, int N );

#ifdef __cplusplus
}
#endif
#endif


// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * UtlString is a resizable string which is also containable in
 * any UtlContainer.  It may include null characters.
 *
 * A UtlString will grow as needed to hold any value stored
 * in it; because this expansion reallocates and copies memory, it is
 * a good idea to specify an expected size either when the object is
 * constructed or using the capacity method.
 *
 * @nosubgrouping
 */
class UtlString : public UtlCopyableContainable
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
    static const UtlContainableType TYPE;    /** < Class type used for runtime checking */

    static const char* ssNull;

    static const size_t UTLSTRING_NOT_FOUND; ///< Returned from a search that failed.

    static const size_t UTLSTRING_TO_END; /**< When specifying the length of a substring,
                                           *   indicates that the substring should extend
                                           *   to the end of the string. */

    /**
     * Flags to the various strip methods
     */
    typedef enum StripType
       {
          leading=1,  /**< only strip from the beginning of the string */
          trailing,   /**< only strip from the end of the string */
          both        /**< strip from both ends of the string */
       } StripType;

    /**
     * Case sensitivity control constants
     */
    typedef enum CompareCase
       {
          matchCase,    /**< Case sensitive comparison */
          ignoreCase    /**< Case insensitive comparison */
       } CompareCase;

// ================================================================
/** @name                  Constructors
 */
///@{

    /// Default Constructor
    UtlString();

    /// Constructor accepting a null terminated source string.
    UtlString(const char* szSource /**< initial string value */ );
    /**<
     * The source string is copied to this object.
     */

    /// Constructor accepting a source string with an explicit length.
    UtlString(const char* szSource, size_t length);
    /**<
     * Any zero byte in the source string is ignored; all length chars of the source
     * string are copied to this object.
     */

    /// Copy the source UtlString.
    UtlString(const UtlString& source);

    /// Copy an initial substring.
    UtlString(const UtlString& source, size_t length);
    /**<
     * Constructor accepting a reference to another string and a length.
     * Up to length characters are copied from the source string into
     * this object.  If length is greater than the length of source
     * this becomes a copy of source with the same data and length.
     */

    /// Clone method for UtlCopyableContainable requirements
    UtlCopyableContainable* clone() const;

///@}
// ================================================================
/** @name                Assignment Operators
 *
 */
///@{

    /// Replace the contents of this string with a null terminated string.
    UtlString& operator=(const char* szStr);

    /// Replace the contents of this string with contents of a UtlString
    UtlString& operator=(const UtlString& str);

///@}
// ================================================================
/** @name              Accessors
 *
 */
///@{

    /// The current length of the string value
    size_t length() const;

    /// Return a read-only pointer to the stored string value..
    const char* data() const;
    /**<
     * This pointer should not be stored, since operations on the UtlString
     * may free it.
     *
     * The returned pointer is never null, even if the UtlString is
     * null or newly-allocated.
     *
     * The stored value will have a null byte at the end, but may also have
     * null bytes at other positions within the value.
     */

    /// Cast to a const char* - identical to the data() method.
    operator const char*() const;
    /**<
     * Cast this object to a const char* pointer.  This is exactly the
     * same as calling data().
     */

    /// Return the current capacity allocated for this string.
    size_t capacity() const;

///@}
// ================================================================
/** @name              Substring Operators
 *
 * Extract a portion of the string value.  
 */
///@{

    /// Allows references of the form stringVar(start,length) - also see append
    UtlString operator() (size_t start, /**< Starting character position
                                         *   (zero based) */
                          size_t len    /**< Number of characters to copy or
                                         *   UTLSTRING_TO_END for
                                         *   "the rest of the string" */
                          ) const;
    /**<
     * An empty string is returned if the start and/or len is invalid.
     *
     * @note
     * This method constructs a temporary UtlString object.  It will usually
     * be more efficient to use the append method taking a UtlString, position,
     * and length.
     * 
     */

    /// Get the character at position N.
    char operator()(size_t N);
    /**
     * @returns the nth character (zero based)
     * @code
     * UtlString aString("abc");
     * char secondChar = aString(1);
     * @endcode
     * Sets secondChar to 'b'
     */

///@}
// ================================================================
/** @name              Comparison Operations
 *
 */
///@{


    /// Return true if this is an empty string.
    UtlBoolean isNull() const;

    /// Compare this string to a null terminated string (case sensitive).
    virtual int compareTo(const char *) const;
    /**<
     * @returns 0 if equal, < 0 if less then and >0 if greater.
     */

    /// Compare this string to a null terminated string, with case sensitivity control
    int compareTo(const char *, CompareCase type) const;

    /// Compare this object to another string, with case sensitivity control
    int compareTo(UtlString const *, CompareCase type) const;
    /**<
     * @returns 0 if equal, < 0 if less then and >0 if greater.
     */

    /// Check for a null terminated value in this string.
    UtlBoolean contains(const char *) const;
    /**<
     * This is equivalent to ( index(str) != UTL_NOT_FOUND )
     *
     * @return true if this string contains the specified string.
     */

    friend UtlBoolean operator!=(const char *, const UtlString& );

    friend UtlBoolean operator!=(const char , const UtlString& );

    friend UtlBoolean operator==(const char , const UtlString& );

    friend UtlBoolean operator==(const char *, const UtlString& );

    UtlBoolean operator==(const char *) const;

    UtlBoolean operator!=(const char *) const;

    UtlBoolean operator==(const UtlString&) const;

    UtlBoolean operator!=(const UtlString&) const;

///@}
// ================================================================
/** @name              Search Operations
 *
 * Also see the regular expression search operations in the RegEx class.
 */
///@{

    /// Find the first instance of a single character.
    size_t index(char c) const;
    /**<
     * @return the offset of the first c or UTL_NOT_FOUND
     */

    /// Find the first instance of a single character starting at a specified offset.
    size_t index(char c, size_t offset) const;
    /**<
     * @return the offset from the beginning of the string of the first c after
     *         offset or UTL_NOT_FOUND
     */

    /// Find the first instance of a single character.
    size_t first(char c) const;
    /**<
     * @return the offset of the first c or UTL_NOT_FOUND
     *
     * (this is the same as index(c) )
     */

    /// Find the first instance of a null terminated string.
    size_t index(const char* ) const;
    /**<
     * @return the offset of the first matching string or UTL_NOT_FOUND
     */

    /// Find the first instance of a specified length string.
    size_t index(const char* , size_t ) const;
    /**<
     * The search target value may contain null characters.
     *
     * @return the offset of the first matching string or UTL_NOT_FOUND
     */

    /// Find the first instance of a specified length string, with case control
    size_t index(const char* , size_t , CompareCase ) const;
    /**<
     * The search target value may contain null characters.
     *
     * @return the offset of the first matching string or UTL_NOT_FOUND
     */

    /// Find the first match for the specified string (which may contain null characters)
    size_t index(const UtlString& ) const;
    /**<
     * The search target value may contain null characters.
     *
     * @return the offset of the first matching string or UTL_NOT_FOUND
     */

    /// Find a match for the specified string starting at offset
    size_t index(const UtlString& match, ///< string value to search for
                 size_t offset           ///< offset in target to start search
                 ) const;
    /**<
     * The search target value (match) may contain null characters.
     *
     * @return the offset from the beginning of the string of the match value
     *         after offset or UTL_NOT_FOUND
     */

    /// Find a match for the specified string starting at offset, with case sensitivity control
    size_t index(const UtlString& , size_t , CompareCase ) const;
    /**<
     * The search target value (match) may contain null characters.
     *
     * @return the offset from the beginning of the string of the match value
     *         after offset or UTL_NOT_FOUND
     */

    /// Find the first instance of a null terminated string
    size_t first(const char* ) const;
    /**<
     * @return the offset of the string or UTL_NOT_FOUND
     */

    /// Find the last instance of a character
    size_t last(char s) const;
    /**<
     * @return the offset of the string or UTL_NOT_FOUND
     */

///@}
// ================================================================
/** @name                  Append Operations
 *
 * Append operations add to the end of the current value of the string.
 */
///@{

    /// Append a null terminated string to the end of the lvalue.
    UtlString& operator+=(const char *);

    /// Append a null terminated string to the end of this string.
    UtlString& append(const char* szStr);

    /// Append a UtlString to this string.
    UtlString& operator+=(const UtlString& s);

    /// Append a UtlString to this string.
    UtlString& append(const UtlString& str ///< source string 
                      );

    /// Append a substring of a UtlString to this string.
    UtlString& append(const UtlString& str, ///< source string 
                      size_t position,      ///< offset into source to start copy
                      size_t length ///< length of substring to copy
                      );
    /**<
     * Note the difference between these two copies:
     * @code
     * UtlString source("0123456789");
     *
     * UtlString destA;
     * destA = source(1,3);
     *
     * UtlString destB;
     * destB.append(source, 6, 2);
     * @endcode
     * The assignment to destA actually constructs a temporary UtlString on the
     * stack as the output of the source(1,3), invokes the copy constructor to
     * copy its contents into destA, and then destructs it.
     *
     * The assignment to destB copies the string contents directly from source
     * to destB.
     */

    /// Append up to N bytes of the designated string to the end of this string.
    UtlString& append(const char* szStr, size_t N);

    /// Append a single character to the end of this string.
    UtlString& operator+=(const char c);

    /// Append a single character to the end of this string.
    UtlString& append(const char c);

///@}
// ================================================================
/** @name              Insertion Operators
 *
 * These methods insert values into the string; the capacity is increased
 * as needed to hold the additional value.
 *
 * Nothing is overwritten - Any existing value at the insertion point is
 * shifted to make room.
 */
///@{

    /// Insert a UtlString
    UtlString& insert(size_t position,     ///< position to insert the src string.
                      const UtlString& src ///< value to be inserted
                      );
    /**<
     * If an invalid position is specified, nothing is performed.
     */

    /// Insert a single character
    UtlString& insert(size_t position,   ///< position to insert newChar.
                      const char newChar ///< character to insert
                      );
    /**<
     * If an invalid position is specified, nothing is performed.
     */

    /// Insert a null terminated string
    UtlString& insert(size_t position,   ///< position to insert src C string
                      const char* src    ///< null terminated string to insert
                      );
     /**<
      * If an invalid position is specified, nothing is performed.
      */

    /// Prepend a null terminated string at the beginning of this string.
    UtlString& prepend(const char* szStr);
    /**< Equivalent to insert(0, szStr); */

    /// Insert arbitrary length value
    UtlString& insert(size_t position,   ///< position to insert src value
                      const char* src,   ///< value to insert (may contain null bytes)
                      size_t sourceLenth ///< number of bytes to insert
                      );
    /**<
     * Insert the value at character position.
     * 
     * If an invalid position is specified, nothing is performed.
     */

///@}
// ================================================================
/** @name              Replacement Operations
 *
 */
///@{

    /// Replace a single character at the designated position.
    void replaceAt(size_t pos,  ///< offset into data to replace - must be < the length
                              char newChar ///< character to be put into that offset
                              );


    /// Replace all instances of character src with character tgt.
    UtlString& replace(const char src, const char tgt);

    /// Replace N characters from a char*.
    UtlString& replace(size_t pos,    ///< position in string to begin replacing
                       size_t N,      ///< number of characters to replace
                       const char* replaceStr ///< replacement value
                       );
    /**<
     * Replace N characters starting at the designated position with the
     * designated replacement string.  Invalid position or length results
     * in no changes.
     */

    /// Replace N characters from a char*, with specified length string.
    UtlString& replace(size_t pos,             ///< starting position of the replacement
                       size_t N,               ///< number of characters to replace
                       const char* replaceStr, ///< target replacement string
                       size_t L                ///< maximum number of characters of the replacement string to use.
                       );
    /**<
     * Replace N characters starting at the designated position with a subset
     * of the designated replacement string.  Invalid position or length results
     * in no changes.
     */

    /// Replace N characters from another UtlString.
    UtlString& replace(size_t pos,    ///< position in string to begin replacing
                       size_t N,      ///< number of characters to replace
                       const UtlString& replaceStr ///< replacement value
                       );
    /**<
     * Replace N characters starting at the designated position with the
     * designated replacement string.  Invalid position or length results
     * in no changes.
     */

///@}
// ================================================================
/** @name              Concatenation Operations
 *
 */
///@{

    /// Concatenate two UtlStrings as: s1 + s2
    friend UtlString operator+(const UtlString& s1, const UtlString& s2);

    /// Concatenate a UtlString with a constant string as: s + c
    friend UtlString operator+(const UtlString& s,  const char* c);

    /// Concatenate a constant string with a UtlString as: c + s
    friend UtlString operator+(const char* c, const UtlString& s);

///@}
// ================================================================
/** @name              Remove Operations
 *
 * Also see Stripping and Trimming, below
 */
///@{

    /// Remove all characters after the specified position.
    UtlString& remove(size_t pos);
    /**<
     * Nothing is performed if the position is invalid.
     */

    /// Remove N characters from this string starting at designated position.
    UtlString& remove(size_t pos, size_t N);
    /**<
     * Invalid position or length results in no changes.
     */

///@}
// ================================================================
/** @name        Stripping and Trimming Operations
 *
 */
///@{

    /// Removes whitespace (space, tab, Cr, Lf) from the end of the string.
    UtlString strip();

    /// Removes whitespace (space, tab, Cr, Lf) from either or both ends of the string.
    UtlString strip(StripType whichEnd);
    /**<
     * Removes whitespace (space, tab, Cr, Lf) from the beginning of the string,
     * from the end of the string, or from both the beginning and end of the
     * string.
     */

    /// Removes all instances of the specified character from either or both ends of the string.
    UtlString strip(StripType whichEnd, char charToStrip);
    /**<
     * Remove the designated character from the beginning of the string,
     * from the end of the string, or from both the beginning and end of
     * the string.
     */

///@}
// ================================================================
/** @name              Case Conversion Operations
 *
 */
///@{

    /**
     * Convert the string to all lower case characters (e.g. AbC1 -> abc1)
     */
    void toLower();

    /**
     * Convert the string to all upper case characters (e.g. AbC1 -> ABC1)
     */
    void toUpper();

///@}
// ================================================================
/** @name              Capacity Management
 *
 */
///@{

    /// Set the minimum capacity a string can hold without reallocation.
    size_t capacity(size_t );
    /**<
     * Set the string's storage capacity to the designated value.
     * This does not modify the value of the string, but rather
     * adjusts the dynamic memory allocated for this string.
     *
     * This never reduces the capacity - any size less then the
     * current capacity is a no-op.
     *
     * @return The new capacity that was set.  In case of success, it
     * may be greater than the requested capacity.  In case of failure,
     * it may be less than the requested capacity.
     */

    /// Set a new size for the string.
    void resize(size_t );
    /**<
     * Resize the string to the specified size.  If the requested size is less
     * then the the current size (string length), the string will be truncated.
     * If larger, the string will be padded with nulls.
     */

///@}
// ================================================================
/** @name           Container Support Operations
 *
 */
///@{

    /// Calculate a hash over the string contents.
    virtual unsigned hash() const;
    /**<
     * If the equals operator returns true for another object, then both
     * objects must return the same hashcode.
     */

    /// Determine whether or not the values in a containable are comparable.
    virtual UtlContainableType getContainableType() const;
    /**<
     * This returns a unique type for UtlString
     */

    /// Compare to any other UtlContainable
    virtual int compareTo(UtlContainable const *other) const;
    /**<
     * Compare this object to another containable object.
     * If the UtlContainableType of the other object is not the UtlString type,
     * this will return unequal.
     *
     * @returns 0 if equal, < 0 if less than, and > 0 if greater.
     */

    virtual UtlBoolean isEqual(UtlContainable const *) const;
    /**<
     * Test this object to another like-object for equality.  This method
     * returns false if unlike-objects are specified.
     */

///@}
// ================================================================
/** @name                   Destructors
 *
 */
///@{

    /// Destructor
    virtual ~UtlString();

///@}

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    char*  mpData;      //: The value of UtlString.
    size_t mSize;       //: The number of bytes of data used.
    size_t mCapacity;   //: The allocated size of data.
    char   mBuiltIn[DEFAULT_UTLSTRING_CAPACITY];
};

/* ============================ INLINE METHODS ============================ */

#endif    // _UtlString_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlTokenizer_h_
#define _UtlTokenizer_h_

// SYSTEM INCLUDES
#include <ctype.h>

// APPLICATION INCLUDES
#include <utl/UtlDefs.h>
#include <os/OsDefs.h>
#include <utl/UtlString.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * C++ version of strtok, but obvisously reentrant.
 */
class UtlTokenizer
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

/* ============================ CREATORS ================================== */

   /**
    * Default constructor
    */
   UtlTokenizer(const UtlString &tokens);
     
   /**
    * Destructor
    */
   virtual ~UtlTokenizer();

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */
   UtlBoolean next(UtlString &token, const char *delim);

/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:

   char *m_tokens;

   int m_tokenPosition;

   /**
    * Copy constructor
    */
   UtlTokenizer(const UtlTokenizer& rUtlTokenizer);     

   /**
    * Assignment operator
    *
    * @param rhs right hand side of the equals operator
    */
   UtlTokenizer& operator=(const UtlTokenizer& rhs);  

   int nextDelim(const char *tokens, const int start, const int len, const char *delim);

   UtlBoolean isDelim(const char c, const char *delim);
};

/* ============================ INLINE METHODS ============================ */

#endif  // _UtlTokenizer_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _UtlVoidPtr_h_
#define _UtlVoidPtr_h_

// SYSTEM INCLUDES
#include "os/OsDefs.h"

// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlContainable.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/// UtlVoidPtr is a UtlContainable wrapper for a void ptr.
/**
 * This class has serious potential to create memory leaks and type casting
 * errors.  Please consider just making the class you want to put into a
 * container a UtlContainable - it just requires implementing a couple of
 * methods, and can often be done by just inheriting from one of the existing
 * UtlContainable classes.  In the simplest case, you can use UtlContainableAtomic;
 * it requires only that you define a new UtlContainableType constant and the
 * method to read it.
 */
class UtlVoidPtr : public UtlContainable
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
    static const UtlContainableType TYPE ;   /** < Class type used for runtime checking */ 

/* ============================ CREATORS ================================== */

    /**
     * Constructor accepting an optional default value.
     */
    UtlVoidPtr(void * pPtr = NULL) ;
     
    /**
     * Destructor
     */
    virtual ~UtlVoidPtr() ;

/* ============================ MANIPULATORS ============================== */

    /**
     * Set a new void ptr value for this object.
     *
     * @returns the old value
     */
    void* setValue(void *) ;

/* ============================ ACCESSORS ================================= */

    /**
     * Get the void ptr wrapped by this object.
     */
    void* getValue() const ;    

    /**
     * Calculate a unique hash code for this object.  If the equals
     * operator returns true for another object, then both of those
     * objects must return the same hashcode.
     */    
    virtual unsigned hash() const ;

    /**
     * Get the ContainableType for a UtlContainable derived class.
     */
    virtual UtlContainableType getContainableType() const;

/* ============================ INQUIRY =================================== */

    /**
     * Compare the this object to another like-objects.  Results for 
     * designating a non-like object are undefined.
     *
     * @returns 0 if equal, < 0 if less then and >0 if greater.
     */
    virtual int compareTo(UtlContainable const *) const ;

  
/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    void* mpValue ;  /** < The void ptr wrapped by this object */
} ;

/* ============================ INLINE METHODS ============================ */

#endif  // _UtlVoidPtr_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _XmlContent_h_
#define _XmlContent_h_

// SYSTEM INCLUDES
#include "os/OsDefs.h"

// APPLICATION INCLUDES
#include "utl/UtlString.h"

// DEFINES
#define XML_VERSION_1_0 "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"


// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * XmlContent provides conversion functions for escaping and unescaping UtlStrings
 * as appropriate for use in XML attribute and element content.
 *
 * At present, this makes no accomodation for character set differences; input is assumed
 * to be 8 bits.  The following characters are encoded using the mandatory character
 * entities:
 *   - < => &lt;
 *   - & => &amp;
 *   - > => &gt;
 *   - ' => &apos;
 *   - " => &quot;
 *
 * Other character values outside the range of valid 8-bit characters in XML:
 * - #x09 | #x0A | #x0D | [#x20-#FF]
 * are encoded using the numeric entity encoding (&#x??;).
 *
 * While this is not strictly XML conformant (in that it does not explicitly deal with
 * larger-size character encodings), it is symmetric (esaping and unescaping any string
 * these routines will always produce the original string), and will interoperate correctly
 * for any 8 bit encoding.
 */

/// Append escaped source string onto destination string
bool XmlEscape(UtlString& destination, const UtlString& source);
/**<
 * The contents of the source string are appended to the destination string, with all
 * characters escaped as described above.
 * @returns true for success, false if an error was returned from any UtlString operation.
 */

/// Append unescaped source string onto destination string
bool XmlUnEscape(UtlString& destination, const UtlString& source);
/**<
 * The contents of the source string are appended to the destination string, with all
 * characters unescaped as described above.
 * @returns true for success, false if an error was returned from any UtlString operation.
 */

/// Append decimal string onto destination string
bool XmlDecimal(UtlString& destination,
                int source,
                const char* format = NULL);
/**<
 * The source value is converted into a decimal string according to
 * "format".  The decimal string is appended to the destination string.  
 * "format" defaults to "%d", and must generate no more than 20 characters,
 * (excluding the ending NUL).
 * @returns true for success, false if an error was returned from any UtlString operation.
 */

#endif    // _XmlContent_h_
