//
// Copyright (C) 2005-2007 SIPez LLC.
// Licensed to SIPfoundry under a Contributor Agreement.
// 
// Copyright (C) 2004-2007 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////
// Author: Dan Petrie (dpetrie AT SIPez DOT com)


#ifndef _HttpBody_h_
#define _HttpBody_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <utl/UtlString.h>
#include <utl/UtlDList.h>

// DEFINES
#define CONTENT_TYPE_TEXT_PLAIN "text/plain"
#define CONTENT_TYPE_TEXT_HTML "text/html"
#define CONTENT_SMIME_PKCS7 "application/pkcs7-mime"
#define CONTENT_TYPE_PIDF "application/pidf+xml"
#define CONTENT_TYPE_MULTIPART "multipart/"
#define CONTENT_TYPE_MULTIPART_RELATED "multipart/related"
#define DIALOG_EVENT_CONTENT_TYPE "application/dialog-info+xml"

#define MULTIPART_BOUNDARY_PARAMETER "boundary"

#define MAX_HTTP_BODY_PARTS 20

// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class MimeBodyPart;

//! class to contain an HTTP body
/*! This is the base class and container for all HTTP (SIP, etc.)
 * message bodies.  This includes multipart MIME bodies, single
 * part MIME and specific MIME types.  The HttpBody is essentially
 * a container for a blob.
 */
class HttpBody : public UtlString
{
   friend class HttpBodyMultipart;

/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    enum BodyClassTypes
    {
        UNKNOWN_BODY_CLASS = 0,
        HTTP_BODY_CLASS,
        SMIME_BODY_CLASS,
        SDP_BODY_CLASS,
        PIDF_BODY_CLASS,
        DIALOG_EVENT_BODY_CLASS
    };

/* ============================ CREATORS ================================== */

   HttpBody(const char* bytes = NULL, 
            int length = -1,
            const char* contentType = NULL);
   //: Construct an HttpBody from a bunch of bytes

   HttpBody(const char* contentType);
   //: Construct a multipart HttpBody with zero parts.
   // contentType should have no "boundary" parameter.

   HttpBody(const HttpBody& rHttpBody);
     //:Copy constructor

   virtual
   ~HttpBody();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   HttpBody& operator=(const HttpBody& rhs);
   //:Assignment operator

   //! Copy the source HttpBody using the correct derived class constructor
   static HttpBody* copyBody(const HttpBody& sourceBody);

   //! Pseudo body factory
   static HttpBody* createBody(const char* bodyBytes,
                               int bodyBytesLength,
                               const char* contentType,
                               const char* contentEncoding);

   //! Append a multipart body part to an existing multiparty body.
   void appendBodyPart(const HttpBody& body,
                       const UtlDList& parameters);

/* ============================ ACCESSORS ================================= */

   virtual int getLength() const;

   // Note: for convenience, bytes is null terminated
   // However depending upon the content type, the body may
   // contain more than one null character.
   // *bytes != NULL, even if *length == 0.
   virtual void getBytes(const char** bytes, int* length) const;
   virtual void getBytes(UtlString* bytes, int* length) const;
   virtual const char* getBytes() const;

   UtlBoolean getMultipartBytes(int partIndex, 
                                const char** bytes,
                                int* length,
                                int* start) const;

   const MimeBodyPart* getMultipart(int partIndex) const;

   int getMultipartCount() const;

   BodyClassTypes getClassType() const;

   //! Get the multipart boundary string.
   // Valid while HttpBody exists and is not modified.
   const char* getMultipartBoundary() const;

   //! Get the content type string.
   // Valid while HttpBody exists and is not modified.
   const char* getContentType() const;

/* ============================ INQUIRY =================================== */

   UtlBoolean isMultipart() const;

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

   int bodyLength;
   UtlString mBody;
   UtlString  mMultipartBoundary;
   int mBodyPartCount;
   MimeBodyPart* mpBodyParts[MAX_HTTP_BODY_PARTS];
   BodyClassTypes mClassType;

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

   // The counter for generating boundary values.
   static unsigned boundaryCounter;
   // Generate the next boundary value.
   static void nextBoundary(UtlString& boundary);
};


// Carrier class to provide a constructor that would otherwise conflict
// with an existing constructor for HttpBody.
class HttpBodyMultipart : public HttpBody
{
  public:

   HttpBodyMultipart(const char* contentType);
   //: Construct a multipart HttpBody with zero parts.
   // contentType should have no "boundary" parameter.
};


/* ============================ INLINE METHODS ============================ */

#endif  // _HttpBody_h_
// 
// Copyright (C) 2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
// 
// Copyright (C) 2006 Pingtel Corp.
// Licensed to SIPfoundry under a Contributor Agreement.
// 
// $$
//////////////////////////////////////////////////////////////////////////////

#ifndef _HttpConnection_h_
#define _HttpConnection_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include <os/OsDefs.h>
#include <net/HttpServer.h>
#include <net/HttpBody.h>
#include <net/NameValuePair.h>
#include <os/OsSocket.h>
#include <os/OsConnectionSocket.h>
#include <os/OsTimeLog.h>
#include <os/OsMsgQ.h>
#include <os/OsTask.h>

// DEFINES

class HttpServer;

class HttpConnection : public OsTask, public UtlString
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
    //! Constructor
    HttpConnection(OsConnectionSocket* requestSocket,
                   HttpServer* httpServer);

    //! Destructor
    virtual ~HttpConnection();

/* ============================ MANIPULATORS ============================== */
    virtual int run(void* runArg);
    
/* ============================ ACCESSORS ================================= */
/* ============================ INQUIRY =================================== */
    bool toBeDeleted() {return mbToBeDeleted;}
/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    OsConnectionSocket* mpRequestSocket;  ///< pointer to request socket
    HttpServer*         mpHttpServer;     ///< pointer HTTP server for callbacks
    bool                mbToBeDeleted;    ///< Indicator if connection can be deleted
    
    /// no copy constructor
    HttpConnection(const HttpConnection& nocopy);

    /// no assignment operator
    HttpConnection& operator=(const HttpConnection& noassignment);        
};

/* ============================ INLINE METHODS ============================ */

#endif  // _HttpConnection_h_
// 
// Copyright (C) 2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
// 
// Copyright (C) 2006 Pingtel Corp.
// Licensed to SIPfoundry under a Contributor Agreement.
// 
// $$
//////////////////////////////////////////////////////////////////////////////

#ifndef _HttpConnectionMap_h_
#define _HttpConnectionMap_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include <os/OsDefs.h>
#include <net/HttpServer.h>
#include <net/HttpBody.h>
#include <net/NameValuePair.h>
#include <os/OsSocket.h>
#include <os/OsConnectionSocket.h>
#include <os/OsTimeLog.h>
#include <os/OsMsgQ.h>
#include <utl/UtlHashMap.h>
#include <os/OsBSem.h>

// DEFINES

class HttpConnectionMapEntry : public UtlString
{
public:
    /// Constructor
    HttpConnectionMapEntry(const UtlString& name);
    
    /// Destructor
    virtual ~HttpConnectionMapEntry();
    
    OsConnectionSocket* mpSocket; //< pointer to a connection socket
    OsBSem              mLock;    //< protects access to the connection
    bool                mbInUse;  //< true if entry is in use, false if not
    static int          count;    //< used to udentify the entry
};

class HttpConnectionMap : public UtlHashMap
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
   /// Get pointer to singleton instance of the connection map
   static HttpConnectionMap* getHttpConnectionMap();
   
   /**<
    * @returns
    * - pointer to the instance of the connectiomn map
    */   
   
   /// Release instance of connection map
   void releaseHttpConnectionMap();
   
   /// Clear all entries in map. Close all sockets and delete them.
   void clearHttpConnectionMap();
   
   /// Return a map entry for an existing connection or NULL. Locks the connection if non-NULL
   HttpConnectionMapEntry* getPersistentConnection(const Url& url, OsConnectionSocket*& socket);
   
   /**<
    * @returns
    * - pointer to a connection map entry and a connection socket. If no entry exists for a 
    *   given URI one will be created and th socket pointer will be set to NULL.
    * - NULL if the connection does not exist
    */      

/* ============================ MANIPULATORS ============================== */
/* ============================ ACCESSORS ================================= */
/* ============================ INQUIRY =================================== */
/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    //! Constructor
    HttpConnectionMap();

    //! Destructor
    virtual ~HttpConnectionMap();
    
    /// Translate Url into key string that will be used for all further access
    void getPersistentUriKey(const Url& url, UtlString& key);       

    static HttpConnectionMap* pInstance; ///< pointer to the instance
    static OsBSem mLock;                 ///< protects access to map
    
    /// no copy constructor
    HttpConnectionMap(const HttpConnectionMap& nocopy);

    /// no assignment operator
    HttpConnectionMap& operator=(const HttpConnectionMap& noassignment);    
};

/* ============================ INLINE METHODS ============================ */

#endif  // _HttpConnectionMap_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

// Author: Dan Petrie (dpetrie AT SIPez DOT com)

#ifndef _HttpMessage_h_
#define _HttpMessage_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include <os/OsDefs.h>

#include <net/HttpBody.h>
#include <net/NameValuePair.h>
#include <os/OsSocket.h>
#include <os/OsTimeLog.h>
#include <os/OsMsgQ.h>
#include <utl/UtlDList.h>

// DEFINES
#define HTTP_NAME_VALUE_DELIMITER ':'
#define HEADER_LINE_PART_DELIMITER ' '
#define END_OF_LINE_DELIMITOR "\r\n"

#define PASSWORD_SECRET                 "xpressa"

#define HTTP_DEFAULT_SOCKET_BUFFER_SIZE 10240

#define HTTP_LONG_INT_CHARS 20

#define HTTP_PROTOCOL_VERSION     "HTTP/1.0"
#define HTTP_PROTOCOL_VERSION_1_1 "HTTP/1.1"

// HTTP Methods
#define HTTP_GET_METHOD "GET"
#define HTTP_PUT_METHOD "PUT"
#define HTTP_POST_METHOD "POST"

// Response codes and text
#define HTTP_OK_CODE 200
#define HTTP_OK_TEXT "OK"
#define HTTP_MOVED_PERMANENTLY_CODE 301
#define HTTP_MOVED_PERMANENTLY_TEXT "Moved Permanently"
#define HTTP_MOVED_TEMPORARILY_CODE 302
#define HTTP_MOVED_TEMPORARILY_TEXT "Moved Temporatily"
#define HTTP_UNAUTHORIZED_CODE 401
#define HTTP_UNAUTHORIZED_TEXT "Unauthorized"
#define HTTP_FORBIDDEN_CODE 403
#define HTTP_FORBIDDEN_TEXT "Forbidden"
#define HTTP_FILE_NOT_FOUND_CODE 404
#define HTTP_FILE_NOT_FOUND_TEXT "File Not Found"
#define HTTP_PROXY_UNAUTHORIZED_CODE 407
#define HTTP_PROXY_UNAUTHORIZED_TEXT "Proxy Authentication Required"
#define HTTP_UNSUPPORTED_METHOD_CODE 501
#define HTTP_UNSUPPORTED_METHOD_TEXT "Not Implemented"
#define HTTP_OUT_OF_RESOURCES_CODE 503
#define HTTP_OUT_OF_RESOURCES_TEXT "Out of Resources"

// Field names
#define HTTP_ACCEPT_LANGUAGE_FIELD "ACCEPT-LANGUAGE"
#define HTTP_ACCEPT_ENCODING_FIELD "ACCEPT-ENCODING"
#define HTTP_AUTHORIZATION_FIELD "AUTHORIZATION"
#define HTTP_DATE_FIELD "DATE"
#define HTTP_CONTENT_DISPOSITION_FIELD "CONTENT-DISPOSITION"
#define HTTP_CONTENT_TRANSFER_ENCODING_FIELD "CONTENT-TRANSFER-ENCODING"
#define HTTP_CONTENT_LENGTH_FIELD "CONTENT-LENGTH"
#define HTTP_CONTENT_TYPE_FIELD "CONTENT-TYPE"
#define HTTP_CONTENT_ID_FIELD "CONTENT-ID"
#define HTTP_LOCATION_FIELD "LOCATION"
#define HTTP_PROXY_AUTHENTICATE_FIELD "PROXY-AUTHENTICATE"
#define HTTP_PROXY_AUTHORIZATION_FIELD "PROXY-AUTHORIZATION"
#define HTTP_REFRESH_FIELD "REFRESH"
#define HTTP_USER_AGENT_FIELD "USER-AGENT"
#define HTTP_WWW_AUTHENTICATE_FIELD "WWW-AUTHENTICATE"
#define HTTP_HOST_FIELD  "HOST"
#define HTTP_ACCEPT_FIELD "ACCEPT"
#define HTTP_CONNECTION_FIELD "CONNECTION"

// Authentication Constants
//    these are by specification case-independant tokens,
//    but we always send the case as used in the examples in
//    the spec (rfc2617)
#define HTTP_BASIC_AUTHENTICATION "Basic"
#define HTTP_DIGEST_AUTHENTICATION "Digest"
#define HTTP_AUTHENTICATION_ALGORITHM_TOKEN "algorithm"
#   define HTTP_MD5_ALGORITHM "MD5"
#   define HTTP_MD5_SESSION_ALGORITHM "MD5-sess"
#define HTTP_AUTHENTICATION_CNONCE_TOKEN     "cnonce"
#define HTTP_AUTHENTICATION_DOMAIN_TOKEN "domain"
#define HTTP_AUTHENTICATION_REALM_TOKEN     "realm"
#define HTTP_AUTHENTICATION_NONCE_TOKEN     "nonce"
#define HTTP_AUTHENTICATION_NONCE_COUNT_TOKEN "nc"
#define HTTP_AUTHENTICATION_OPAQUE_TOKEN    "opaque"
#define HTTP_AUTHENTICATION_QOP_TOKEN  "qop"
#   define HTTP_QOP_AUTH "auth"
#   define HTTP_QOP_AUTH_INTEGRITY "auth-int"
#define HTTP_AUTHENTICATION_USERNAME_TOKEN  "username"
#define HTTP_AUTHENTICATION_URI_TOKEN       "uri"
#define HTTP_AUTHENTICATION_RESPONSE_TOKEN  "response"

// HTTP_CONTENT_TRANSFER_ENCODING types
#define HTTP_CONTENT_TRANSFER_ENCODING_BINARY "binary"
#define HTTP_CONTENT_TRANSFER_ENCODING_BASE64 "base64"

// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
const int HttpMessageRetries = 2;
   
// STRUCTS

// FORWARD DECLARATIONS
class UtlString;
class Url;
class HttpMessage;
class OsConnectionSocket;

// TYPEDEFS
//! Callback method used as part of HttpMessage::get.
//! If the callback method returns FALSE, then the retrieve is aborted.
typedef UtlBoolean (*GetDataCallbackProc)(char* pData,
                                         int iLength,
                                         void* pOptionalData,
                                         HttpMessage* pMsg);


//! HTTP message container
/*! This class is the container with methods for manipulation of a generic
 * HTTP message.  The message is composed of three parts:
 * -# The first header line
 * -# header fields and values (RFC 822 style)
 * -# the optional body (HttpBody)
 * \par
 * The first header line is composed of three white space delimited
 * parts.  The meaning of these parts depends upon whether the
 * the message is a request or a response.  Aside from the first
 * header line, the syntactic and symantic differences are very
 * message specific so a design decision was made to \a not use
 * different subclasses for requests and responses.  This also
 * avoids the multiple inheritance complexity that occurs if you
 * create subclasses for requests, responses and other message
 * types like SipMessage which also have requests and responses.
 * \par
 * The first header line parts can be accessed as follows:
 * - Requests:
 *    -# the request method is retreived via getRequestMethod()
 *    -# the request URI is retreive via getRequestUri()
 *    -# the request protocol is retrieved via getRequestProtocol()
 * - Responses:
 *    -# the response protocol is retrieved via getResponseProtocol()
 *    -# the response code is retrieved via getResponseStatusCode()
 *    -# the response status string is retrieved via getResponseStatusText()
 * \par
 * There are generic getters and setters for the header fields and values
 * However the design philosophy has been to create specialized get and
 * set methods for fields that require any special handling or parsing
 * (i.e. things that are more than opaque tokens or strings).  The generic
 * accessor methods are:
 * - getters:
 *     - getHeaderValue()
 * - setters:
 *     - setHeaderValue()
 *     - addHeaderField()
 *     - insertHeaderField()
 * \par
 * The final part of the HttpMessage is the body.  The body is
 * optional and may not be present.  The accessors for the body
 * (single or multipart) is getBody() and setBody()
 */
class HttpMessage
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    enum HttpEndpointEnum
    {
        SERVER = 0,
        PROXY
    };

/* ============================ CREATORS ================================== */

    //! Construct from a string
        HttpMessage(const char* messageBytes = NULL,
                int byteCount = -1);

    //! Construct from reading from the given socket
        HttpMessage(OsSocket* inSocket,
                int bufferSize = HTTP_DEFAULT_SOCKET_BUFFER_SIZE);

        //!Copy constructor
        HttpMessage(const HttpMessage& rHttpMessage);

    //! Assignment operator
    HttpMessage& operator=(const HttpMessage& rhs);

        //! Destructor
        virtual
        ~HttpMessage();

/* ============================ MANIPULATORS ============================== */

    //! Do an HTTP GET on the given URL
    /*! \param httpUrl - the url to get from the HTTP server.  The URL
     *         may contain a password & user id.
     * \param maxWaitMillSeconds - the maximum time to wait for the response
     * \param bPersistent - use persistent connections if true
     */
    int get(Url& httpUrl,
            int maxWaitMilliSeconds,
            bool bPersistent=true);

    //! Do an HTTP GET on the given URL
    /*! \param httpUrl - the url to get from the HTTP server.  The URL may contain a password & user id.  Note the only thing that may be required of the URL is the host and port as well as the user ID and password if there is a authentication challenge.
     * \param request - the complete HTTP request that will be sent to the HTTP server including the body.
     * \param maxWaitMillSeconds - the maximum time to wait for the response
     * \param bPersistent - use persistent connections if true
     */
    int get(Url& httpUrl,
            HttpMessage& request,
            int maxWaitMilliSeconds,
            bool bPersistent=false);
            

    //!Perform an HTTP GET on the specified URL and pass data to the
    //! specified callbackProc.
    /*!
     * \note If you specify a socket pointer, YOU ARE RESPONSIBLE for
     *       closing and deleting the socket!
     *
     * \param httpUrl - The url to get from the HTTP server.  The URL may
     *        contain a password & user id.
     * \param maxWaitMillSeconds - The maximum time to wait for the response.
     * \param callbackProc - Callback routine that will be invoked with the
     *        body data.
     * \param optionalData - Optional data passed to callbackProc
     * \param socket - Socket used to fetch data.  This is set before any
     *        data is pumped, however, if you specify this socket, it is
     *        the caller's responsibility to delete the OsSocket.
     */
    OsStatus get(Url& httpUrl,
                 int maxWaitMilliSeconds,
                 GetDataCallbackProc callbackProc,
                 void* optionalData = NULL,
                 OsConnectionSocket** socket = NULL) ;

    //! Read HTTP message from socket.
    /*! Convenience function to read from a socket
     * \param inSocket - socket from which to read data
     * \param bufferSize - this is the size of the chunks of data to
     *   be read off the socket.  (It is not the total size of the
     *   message to be read.)
     * \param externalBuffer - a UtlString into which the HTTP message
     *   will be accumulated and via which it will be returned to the
     *   caller.  If this is NULL, the message is not returned.
     *   If externalBuffer contains a string, it is taken as the
     *   initial part of the HTTP message, to be followed by data read
     *   from inSocket.
     * \param maxContentLength - this is the maximum message size that
     *   will be read.  If the message content-length is larger, the
     *   socket is closed and the buffer is cleared.  (This is to protect
     *   against abusive senders.)
     * \return the number of bytes in the message that was read,
     *   or 0 to indicate an error.  If it is less than
     *   externalBuffer.length(), the remaining bytes are the start of
     *   another message.
     */
    int read(OsSocket* inSocket,
             int bufferSize = HTTP_DEFAULT_SOCKET_BUFFER_SIZE,
             UtlString* externalBuffer = NULL,
             int maxContentLength = 6000000);

    //! Will read bytes off the socket until the header of the message is
    //! believed received.
    int readHeader(OsSocket* inSocket, UtlString& buffer);

    //! Read the body of the specified data and deliever via the
    //! callback proc.
    int readBody(OsSocket* inSocket, int length, GetDataCallbackProc callbackProc, void* optionalData);

        //! Write message to socket
        /*! Convenience function to write to a socket
         * \return TRUE if the message was written successfully
     */
    UtlBoolean write(OsSocket* outSocket) const;

    //! Converts the given token to initial cap capitialization
    //! in the style used in RFC 822 header names
    static void cannonizeToken(UtlString& token);

    //! URL unescape the text to human readable form.
    static void unescape(UtlString& escapedText);

    //! Selectively URL escape the text if they are contained in
    //! tobeEscapedChars.
    static void escapeChars(UtlString& unEscapedText, UtlString& tobeEscapedChars);

    //! URL sscape the text.
    static void escape(UtlString& unEscapedText);

    //! Selectively URL escape the text if the char is tobeEscapedChar.
    static void escapeOneChar(UtlString& unEscapedText, char tobeEscapedChar);

    /*! @name Construction helper methods
     *  These methods are mostly for internal use as utilities
     * to the constructor methods
     */
    //@{
    //! Parse the first line of the request or response
    int parseFirstLine(const char* messageBytes, int byteCount);

        //! Parse the message from a byte buffer
        /*! This method reads the top header line, header feilds and
         * the message body if they are present from the buffer assuming
         * HTTP stream format.
     */
    void parseMessage(const char* messageBytes, int byteCount);

    //! Parses the bytes into a single or multipart body.
    void parseBody(const char* messageBodyBytes, int byteCount);

    //! returns: the number of bytes parsed
    static int parseHeaders(const char* headerBytes,
                            int messageLength,
                            UtlDList& headerNameValues);

    //! returns: the number of bytes in the message buffer which constitue the message header
    /*! The end of the headers is determined by the first blank line
     */
    static int findHeaderEnd(const char* messageBytes, int messageLength);

    //@}
/* ============================ ACCESSORS ================================= */

    static int smHttpMessageCount;
    static int getHttpMessageCount();

    const char* getFirstHeaderLine() const;

    //! Set the header line
    /*! \param newHeaderLine - gets copied
    */
    void setFirstHeaderLine(const char* newHeaderLine);


    void setFirstHeaderLine(const char* subfields0,
                            const char* subfield1,
                                                    const char* subfield2);

   //! Get part of header line
   /*! \param partIndex - index into space delimited first header line
    * \param part
    */
    void getFirstHeaderLinePart(int partIndex,
                                UtlString* part,
                                char separator = HEADER_LINE_PART_DELIMITER) const;

    //! @name Transport state accessors
    /*! \note: these are mostly only useful inside servers
     * that keep message state.
     * Used for transport reliablity to tack when this message was
     * sent so that it may be resent or timed-out.
     */
    //@{
    void setTransportTime(long timeStamp);
    void touchTransportTime();
    long getTransportTime() const;

    //!  Used for transport to track reliably the last duration
    //! waited before resending
    void setResendDuration(int resendMSec);
    int getResendDuration() const;

    // Used by transport to track reliably the number of times the
    // message was sent (and resent).
    int getTimesSent() const;
    void incrementTimesSent();
    void setTimesSent(int times = 0);

    // Used by the tranport to track reliably which protocol the
    // message was sent over
    void setSendProtocol(OsSocket::IpProtocolSocketType protocol = OsSocket::TCP);
    OsSocket::IpProtocolSocketType getSendProtocol() const;

    void setFirstSent();
    void setSendAddress(const char* address, int port);
    void getSendAddress(UtlString* address, int* port) const;

    // Resets the tranport state stuff
    void resetTransport();
    //@}

    //! @name Request callback methods
    /*! These methods are used to setup callback functions and data
     * which gets triggered when a response comes back
     */
    //@{

    //! Gets the queue on which responses from the same transaction
    //! are deposited
    OsMsgQ* getResponseListenerQueue() const;

    //! Sets the queue on which responses from the same transaction
    //! are deposited
    void setResponseListenerQueue(OsMsgQ* requestListenerQueue);

    //! Gets the data item to pass to the request listener
    void* getResponseListenerData() const;

    //! Sets the data item to pass to the request listener
    void setResponseListenerData(void* requestListenerData);
    //@}


    //! @name Generic header accessors
    /*! \note many specific header type accessors exist to parse
     * headers which have syntax that is not a simple token or string
     */
    //@{

    //! Find the number of occurrences of header fields with the given name.
    int getCountHeaderFields(const char* name = NULL) const;

    //! Get the value of the header field
    //! (i.e. second header line).
    /*! \param index - index into the header fields or if name is not null
     *        the index into the set of header fields having the given name
     * \param name - string containing the name of the header field
     * \return read only string if a header field exist <br>
     *       null if no header field is found
     */
    const char* getHeaderValue(int index, const char* name = NULL) const;

    //! Sets the value of an existing header field
    /*! If the given name does not exist it creates a new one
     * \param name - header field name
     * \param newValue - the value which gets set for the field
     * \param index - the index into the number of fields with the
     *         given name
     * \note value is copied
     */
    void setHeaderValue(const char* name, const char* newValue, int index = 0);

    //! Adds a new header line
    /*! \param name - header field name
     * \param value - the value which gets set for the field
     * \note name and value are copied
     */
    void addHeaderField(const char* name, const char* value);


    //! Inserts a new header line, shifting existing headers at and
    //! after the secified location down by one
    /*! \param name - header field name
     * \param value - the value which gets set for the field
     * \param index - the location to insert in the list (first by default)
     * \note name and value are copied
     */
    void insertHeaderField(const char* name,
                          const char* value,
                          int index = 0);


    UtlBoolean removeHeader(const char* name, int index);
    //! Remove a header field and value
    /*! \param name - optional header field name NULL if indexing directly
     * \param index - header number or index into headers having the given
     *        name if provided
     */
    //@}

    //! @name Specialized header field accessors
    //@{
    void setContentType(const char* contentType);

    UtlBoolean getContentType(UtlString* contentType) const;

    void setContentLength(int contentLength);

    int getContentLength() const;

        void setUserAgentField(const char* userAgentFieldValue);

        void getUserAgentField(UtlString* userAgentFieldValue) const;

    void setRefresh(int seconds, const char* refreshUrl = NULL);

    UtlBoolean getDateField(long* epochDate) const;

    //! Sets the date field to the current time
    void setDateField();

    void setAcceptLanguageField(const char* acceptLanaguageFieldValue);

    void getAcceptLanguageField(UtlString* acceptLanaguageFieldValue) const;

    UtlBoolean getAcceptField(UtlString& acceptValue) const;

    void setLocationField(const char* locationField);
    //@}

    //! @name Message body accessors
    //@{
    //! Get the body section of the message
    const HttpBody* getBody() const;

    /**
     * Attach the body section of the message. The body is NOT copied
     * this message instance destructor will call delete on body
     * pointer
     */
    void setBody(HttpBody* newBody);
    //@}

    //! Get the bytes for the compete message
    /*! Suitable for streaming or sending over a socket
     * \param bytes - gets allocated and must be freed
     * \param length - the length of bytes
     */
    void getBytes(UtlString* bytes, int* length) const;


   //! @name Authentication access methods
   //@{
    UtlBoolean getAuthenticationScheme(UtlString* scheme,
                                    int authorizationEntity) const;

    UtlBoolean getAuthenticationData(UtlString* scheme,
                                    UtlString* realm,
                                    UtlString* nonce,
                                    UtlString* opaque,
                                    UtlString* algorithm, // MD5 or MD5-sess
                                    UtlString* qop, // may be multiple values
                                    int authorizationEntity) const;

    void setAuthenticationData(const char* scheme, const char* realm,
                                const char* nonce, const char* opaque,
                                const char* domain = NULL,
                                enum HttpEndpointEnum authEntity = SERVER);

   void addAuthenticationField(const char* authenticationField,
                               enum HttpEndpointEnum authType);

   UtlBoolean getAuthenticationField(int index,
                                    enum HttpEndpointEnum authEntity,
                                    const char* authenticationField) const;

   void addAuthenticationField(const char * AuthorizeField,
                                         const char * AuthorizeValue,
                                         UtlBoolean otherAuthentications = TRUE);
    // Authorization methods
    static void buildBasicAuthorizationCookie(const char* user,
                                                const char* password,
                                                UtlString* cookie);

    virtual void setRequestUnauthorized(const HttpMessage* request,
                            const char* authenticationScheme,
                            const char* authenticationRealm,
                            const char* authenticationNonce = NULL,
                            const char* authenticationOpaque = NULL,
                            const char* authenticationDomain = NULL);

    UtlBoolean getAuthorizationUser(UtlString* userId) const;

    UtlBoolean getAuthorizationScheme(UtlString* scheme) const;

    UtlBoolean getAuthorizationField(UtlString* authenticationField,
                                    int authorizationEntity) const;

    void setBasicAuthorization(const char* user, const char* password,
                                int authorizationEntity);

    UtlBoolean getBasicAuthorizationData(UtlString* encodedCookie) const;

    UtlBoolean getBasicAuthorizationData(UtlString* userId,
                                        UtlString* password) const;

    UtlBoolean verifyBasicAuthorization(const char* user,
                                   const char* password) const;

    // Digest Authorization
    void setDigestAuthorizationData(const char* user,
                                    const char* realm,
                                    const char* nonce,
                                    const char* uri,
                                    const char* response,
                                    const char* algorithm,
                                    const char* cnonce,
                                    const char* opaque,
                                    const char* qop,
                                    int nonceCount,
                                    int authorizationEntity);

    UtlBoolean getDigestAuthorizationData(UtlString* user,
                                         UtlString* realm = NULL,
                                         UtlString* nonce = NULL,
                                         UtlString* opaque = NULL,
                                         UtlString* response = NULL,
                                         UtlString* uri = NULL,
                                                                                 int authorizationEntity = HttpMessage::PROXY ,
                                         int index = 0) const;

    static void buildMd5UserPasswordDigest(const char* user,
                                           const char* realm,
                                           const char* password,
                                           UtlString& userPasswordDigest);

    static void buildMd5Digest(const char* userPasswordDigest,
                               const char* algorithm,
                               const char* nonce,
                               const char* cnonce,
                               int nonceCount,
                               const char* qop,
                               const char* method,
                               const char* uri,
                               const char* bodyDigest,
                               UtlString* responseToken);

    UtlBoolean verifyMd5Authorization(const char* userId,
                                     const char* password,
                                     const char* nonce,
                                     const char* realm,
                                     const char* thisMessageMethod = NULL,
                                     const char* thisMessageUri = NULL,
                                     enum HttpEndpointEnum authEntity = SERVER) const;

    UtlBoolean verifyMd5Authorization(const char* userPasswordDigest,
                                     const char* nonce,
                                     const char* thisMessageMethod = NULL,
                                     const char* thisMessageUri = NULL) const;

    //@}

    //! @name Response first header line access methods
    //@{
    void setResponseFirstHeaderLine(const char* protocol,
                                    int statusCode,
                                    const char* statusText);

    //! Get this response's message protocol
    void getResponseProtocol(UtlString* protocol) const;

    //! Get this response's status code
    int getResponseStatusCode() const;

    //! Get this response's status code text
        void getResponseStatusText(UtlString* text) const;
    //@}



        /*! @name Request first header line access methods
     */
    //@{
    void setRequestFirstHeaderLine(const char* method,
                                   const char* uri,
                                   const char* protocol);

    //! Get this request's method
    void getRequestMethod(UtlString* method) const;

    //! Get this request's URI
    void getRequestUri(UtlString* uri) const;

    //! Get this request's application layer protocol type
    void getRequestProtocol(UtlString* protocol) const;

    //! Change this request's URI
    void changeRequestUri(const char* newUri);
    //@}

     // Time logging
     void logTimeEvent(const char* eventName);
     void dumpTimeLog() const;

/* ============================ INQUIRY =================================== */

     static UtlBoolean isWholeMessage(const char* messageBuffer,
                              int bufferLength,
                              int& numberBytesChecked,
                              int& contentLength);

    UtlBoolean isFirstSend() const;

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
   UtlDList mNameValues;
   UtlString mFirstHeaderLine;
   UtlBoolean mHeaderCacheClean;

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

   HttpBody* body;
   long transportTimeStamp;
   int lastResendDuration;
   OsSocket::IpProtocolSocketType transportProtocol;
   int timesSent;
   UtlBoolean mFirstSent;
   UtlString mSendAddress;
   int mSendPort;
   OsMsgQ* mpResponseListenerQueue;
   void* mResponseListenerData;
#ifdef HTTP_TIMELOG
   OsTimeLog mTimeLog;
#endif

   //! Internal utility
   NameValuePair* getHeaderField(int index, const char* name = NULL) const;


};

/* ============================ INLINE METHODS ============================ */

#endif  // _HttpMessage_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _HttpRequestContext_h_
#define _HttpRequestContext_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include "utl/UtlString.h"
#include "utl/UtlSList.h"
#include "net/HttpMessage.h"

// DEFINES


// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class HttpBody;

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class HttpRequestContext
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
    enum RequestEnvironmentVariables
    {
        // Environment variables:
        HTTP_ENV_RAW_URL = 0,   // The url provided in the request
        HTTP_ENV_UNMAPPED_FILE, // The file part of the raw URL
        HTTP_ENV_MAPPED_FILE,   // The file part of the url mapped to the real location
        HTTP_ENV_QUERY_STRING,  // The query part of the URL (if GET) Note: the individual variables are retreiveable via getCgiVariables
        HTTP_ENV_SERVER_NAME,   // The Server name part of the URL
        HTTP_ENV_REQUEST_METHOD,// The request method (i.e. GET, PUT, POST)
        HTTP_ENV_USER,          // The user name (if this request required authorization)


        HTTP_ENV_LAST // Note: this is a dummy variable indicating the last var
    };

/* ============================ CREATORS ================================== */

   /// Construct the context for an HTTP request.
   HttpRequestContext( const char* requestMethod = NULL
                      ,const char* rawUrl = NULL
                      ,const char* mappedFile = NULL
                      ,const char* serverName = NULL
                      ,const char* userId = NULL
                      ,const OsConnectionSocket* connection = NULL
                      );
     //:Default constructor


   virtual
   ~HttpRequestContext();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   void extractPostCgiVariables(const HttpBody& body);
   // Extracts the CGI variables from the request body.

   typedef void (*UnEscapeFunction)(UtlString&);
   static void parseCgiVariables(const char* queryString,
                                 UtlList& cgiVariableList,
                                 const char* pairSeparator = "&",
                                 const char* namValueSeparator = "=",
                                 UtlBoolean nameIsCaseInsensitive = TRUE,
                                 UnEscapeFunction unescape =
                                     &HttpMessage::unescape);
   // If nameIsCaseInsensitive == TRUE, puts NameValuePairInsensitive's
   // into cgiVariableList rather than NameValuePair's.

   HttpRequestContext(const HttpRequestContext& rHttpRequestContext);
     //:Copy constructor
   HttpRequestContext& operator=(const HttpRequestContext& rhs);
     //:Assignment operator

/* ============================ ACCESSORS ================================= */

   void getEnvironmentVariable(enum RequestEnvironmentVariables envVariable, UtlString& value) const;
   //: Get Environment and context variables related to this request
   // See the RequestEnvironmentVariables enumeration for the complete list.

   UtlBoolean getCgiVariable(const char* name, UtlString& value, int occurance = 0) const;
   //: Get CGI/Form variables provided in this POST or GET request.
   // As it is possible to have multiple occurances of a named value
   // the occurance argument indicates which occurance.  The default is the first.
   //! returns: TRUE/FALSE if the occurance of the named variable exists

   UtlBoolean getCgiVariable(int index, UtlString& name, UtlString& value) const;
   //: Get the name and value of the variable at the given index

   /// Test whether or not the client connection is encrypted.
   bool isEncrypted() const;

   /// Test whether or not the given name is the SSL client that sent this request.
   bool isTrustedPeer( const UtlString& peername ) const;
   /**<
    * This tests the host identity provided by the SSL handshake; it does not
    * test the HTTP user identity.
    * @returns
    * - true if the connection is SSL and the peername matches a name in the peer certificate.
    * - false if not.
    */

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

   void parseCgiVariables(const char* queryString);
   //: Parse the CGI/form variables from the &,= delineated name, value pairs and unescape the name and values.

   UtlSList mCgiVariableList;
   bool     mUsingInsensitive;
   UtlString mEnvironmentVars[HTTP_ENV_LAST];
   bool     mConnectionEncrypted;
   bool     mPeerCertTrusted;
   UtlSList mPeerIdentities;

};

/* ============================ INLINE METHODS ============================ */

#endif  // _HttpRequestContext_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _HttpServer_h_
#define _HttpServer_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <utl/UtlInt.h>
#include <utl/UtlHashMap.h>
#include <utl/UtlHashBag.h>
#include <os/OsTask.h>
#include <os/OsConfigDb.h>
#include <net/HttpConnection.h>

// DEFINES
#define MAX_PERSISTENT_HTTP_CONNECTIONS  5

// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class HttpMessage;
class HttpBody;
class OsServerSocket;
class OsConnectionSocket;
class HttpRequestContext;
class HttpService;
class HttpConnection;

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class HttpServer : public OsTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
   friend class HttpConnection;

/* ============================ CREATORS ================================== */

   HttpServer(OsServerSocket *pSocket, OsConfigDb* userPasswordDb,
                       const char* realm, OsConfigDb* validIpAddressDB = NULL,
                       bool bPersistentConnection = false);
     //:Default constructor

   virtual
   ~HttpServer();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

    virtual int run(void* runArg);

    // Request processors
    static void processPostFile(const HttpRequestContext& requestContext,
                                const HttpMessage& request,
                                HttpMessage*& response);
    static int doPostFile(const HttpRequestContext& requestContext,
                                const HttpMessage& request,
                                HttpMessage*& response,
                                                                UtlString& status);

    static void processFileRequest(const HttpRequestContext& requestContext,
                                const HttpMessage& request,
                                HttpMessage*& response);

    // Error request processors
    static void processNotSupportedRequest(const HttpRequestContext& requestContext,
                                const HttpMessage& request,
                                HttpMessage*& response);
    static void processFileNotFound(const HttpRequestContext& requestContext,
                                const HttpMessage& request,
                                HttpMessage*& response);

        static void processUserNotAuthorized(const HttpRequestContext& requestContext,
                                     const HttpMessage& request,
                                     HttpMessage*& response,
                                     const char* text = 0);

    static void createHtmlResponse(int responseCode, const char* responseCodeText,
                   const char* htmlBodyText, HttpMessage*& response);

    static void testCgiRequest(const HttpRequestContext& requestContext,
                                const HttpMessage& request,
                                HttpMessage*& response);

    static UtlBoolean mapUri(OsConfigDb& configDb, const char* uri, UtlString& mappedUri);

    void addUriMap(const char* fromUri, const char* toUri);

    typedef void RequestProcessor(const HttpRequestContext& requestContext,
                                  const HttpMessage& request,
                                  HttpMessage*& response
                                  );
    
    void addRequestProcessor(const char* fileUrl, RequestProcessor* requestProcessor);

    void addHttpService(const char* fileUrl, HttpService* service);

    /// set permission for access to mapped file names
    void allowFileAccess(bool fileAccess ///< true => allow access, false => disallow access
                         );
    
    void setPasswordDigest(const char* user, const char* password,
                           UtlString& userPasswordDigest);


        void setPasswordDigest(const char* user, const char* passwordDigest);
          //: Sets the password, given an already digested password.



        void getDigest(const char* user, const char* password,
                                   UtlString& userPasswordDigest) ;

        void setPasswordBasic(const char* user, const char* password);

        void removeUser(const char* user, const char* password) ;

        static void constructFileList(UtlString & indexText, UtlString uri, UtlString uriFilename) ;

        //get current http server status
        OsStatus getStatus();


/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

    void processRequest(const HttpMessage& request,          ///< request to be dispatched
                        HttpMessage*& response,              ///< build response in this message
                        const OsConnectionSocket* connection ///< for access to security info
                        );

    UtlBoolean processRequestIpAddr(const UtlString& remoteIp,
       const HttpMessage& request,
       HttpMessage*& response);


    UtlBoolean isRequestAuthorized(const HttpMessage& request,
                                  HttpMessage*& response,
                                  UtlString& userId);

    void processPutRequest(const HttpRequestContext& requestContext,
                           const HttpMessage& request,
                           HttpMessage*& response);

    void getFile(const char* fileName, HttpBody*& body);

    void putFile(const char* fileName, HttpBody& body);

    UtlBoolean findRequestProcessor(const char* fileUri,
                                    RequestProcessor*& requestProcessor
                                    );

    UtlBoolean findHttpService(const char* fileUri, HttpService*& service);

    void loadValidIpAddrList();
    
/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
   HttpServer(const HttpServer& rHttpServer);
     //:Copy constructor (disabled)
   HttpServer& operator=(const HttpServer& rhs);
     //:Assignment operator (disabled)
   OsStatus httpStatus;
   int mServerPort;
   OsServerSocket* mpServerSocket;
   OsConfigDb * mpUserPasswordDigestDb;
   OsConfigDb * mpUserPasswordBasicDb;
   OsConfigDb * mpValidIpAddressDB;
   OsConfigDb mUriMaps;
   OsConfigDb * mpNonceDb;
   UtlString mRealm;
   UtlHashMap mRequestProcessorMethods;
   UtlHashMap mHttpServices;
   bool       mAllowMappedFiles;
   UtlHashBag mValidIpAddrList;
   UtlBoolean mbPersistentConnection;
   int mHttpConnections;
   UtlSList* mpHttpConnectionList;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _HttpServer_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _HTTPSERVICE_H_
#define _HTTPSERVICE_H_

// SYSTEM INCLUDES

// APPLICATION INCLUDES

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class HttpMessage;
class HttpRequestContext;

/**
 * A HttpService is a dynamically loaded object that is invoked by the HttpServer
 * during the runtime.
 *
 * This class is the abstract base from which all Http services must inherit. One
 * method must be implemented by the subclasses:
 * - processRequest() is for HttpServer to process the request and send back
 * the response to the client side
 *
 */

class HttpService
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   /// Constructor
   HttpService();
  
   /// Destructor
   virtual ~HttpService();

   /// Process request. Subclasses must provide a definition for this method.
   virtual void processRequest(const HttpRequestContext& requestContext,
                               const HttpMessage& request,
                               HttpMessage*& response
                               ) = 0;

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */


/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

   /// Disabled copy constructor
   HttpService(const HttpService& rHttpService);

   /// Disabled assignment operator
   HttpService& operator=(const HttpService& rhs);
   
};

/* ============================ INLINE METHODS ============================ */

#endif  // _HTTPSERVICE_H_


//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

// MailAttachment class declaration for Mailer

#ifndef __MAILATTACHMENT_H__
#define __MAILATTACHMENT_H__

#include "os/OsDefs.h"
#include "os/OsFS.h"

class MailAttachment
{
public:
    MailAttachment() { m_Base64 = NULL; }
    ~MailAttachment();
    MailAttachment(const MailAttachment &original);
    bool Load(const UtlString &filename);
    bool Load(const unsigned char *data, const size_t& rDatalength, const UtlString &rFilename );
    UtlString Base64Data() const { return UtlString(m_Base64); }
    UtlString Filename() const { return m_Filename; }
    UtlString MIMEtype() const { return m_MIMEtype; }

private:
    void Base64Encode(const unsigned char *buffer, unsigned long buflen);
    char *m_Base64;

    UtlString m_Filename;
    UtlString m_MIMEtype;
};

#endif
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

//Example:
/*

        MailMessage message("XXX",
                        "XXX@pingtel.com",
                        "XXX.pingtel.com");
        message.Body("this is a test message");
        message.Subject("Hello World!");
        message.To("XXX","XXX@pingtel.com");
        message.Send();

       
*/


// MailMessage class declaration for Mailer

#ifndef __MAILMESSAGE_H__
#define __MAILMESSAGE_H__

#include "os/OsDefs.h"
#include "MailAttachment.h"

#include <vector>
using namespace std;

class MailMessage
{
public:
    MailMessage(const UtlString &rFromName,
                         const UtlString &rFromAddress,
                         const UtlString &rSmtpServer)
    {
        UtlString fromName = rFromName.data();
        m_From.Name = fromName.data();
        UtlString fromAddress = rFromAddress.data();
        m_From.Address = fromAddress;
        UtlString smtpServer = rSmtpServer.data();
        m_Server = smtpServer;
    }

    void To(const UtlString &rName, const UtlString &rAddress)
    { 
        UtlString name = rName.data();
        UtlString address = rAddress.data();
        m_vecTo.push_back(MailAddress(name,address)); 
    }

    void Cc(const UtlString &rName, const UtlString &rAddress)
    { 
        UtlString name = rName.data();
        UtlString address = rAddress.data();
        m_vecCc.push_back(MailAddress(name,address)); 
    }

    void Bcc(const UtlString &rName, const UtlString &rAddress)
    { 
        UtlString name = rName.data();
        UtlString address = rAddress.data();
        m_vecBcc.push_back(MailAddress(name,address)); 
    }
    
    void Subject(const UtlString &rSubject)
    { 
        UtlString subject = rSubject.data();
        m_Subject = subject; 
    }
    
    void Body(const UtlString &rText);
    
    void Body(const UtlString &rText, const UtlString &rHtml);

    bool Attach(const UtlString &rFilename);
    
    bool Attach(const unsigned char *data, const int& rDatalength, const UtlString &rFilename );

    // Send the message to the SMTP server specified in the constructor.
    // Return either "" or an error message.
    UtlString Send();

private:
    UtlString FormatForSending();

    struct MailAddress
    {
        MailAddress() {;}
        MailAddress(const UtlString &name, const UtlString &address)
            { Name=name; Address=address; }
        UtlString toString() const
            { 
                UtlString str = "\"";
                str += Name;
                str += "\" <";
                str += Address;
                str += ">";
                return str;
            }
        UtlString Name;
        UtlString Address;
    };

    MailAddress m_From;
    vector<MailAddress> m_vecTo;
    vector<MailAddress> m_vecCc;
    vector<MailAddress> m_vecBcc;
    UtlString m_Subject;
    UtlString m_ContentType;
    UtlString m_Body;
    vector<MailAttachment> m_vecAttachment;
    UtlString m_Server;
};

#endif
//
// Copyright (C) 2004-2007 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _MimeBodyPart_h_
#define _MimeBodyPart_h_

// SYSTEM INCLUDES
//#include <...>
#include "utl/UtlDList.h"

// APPLICATION INCLUDES
#include <net/HttpBody.h>


// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//:One part of a multipart Mime body
// This is a child part of a multipart MIME body
class MimeBodyPart : public HttpBody
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   MimeBodyPart(const HttpBody* parent = NULL,
                int parentBodyStartIndex = 0,
                int rawBodyLength = 0);
     //:Default constructor

   //! Construct a MimeBodyPart from an HttpBody and a list of parameters.
   MimeBodyPart(const HttpBody& httpBody,
                //< Provides the bytes of the body.
                const UtlDList& parameters
                //< Provides the parameters.
      );
   /**< Does not attach the MimeBodyPart to a parent, or set the members
    *   showing its location in the parent.  For that you need attach().
    */

   MimeBodyPart(const MimeBodyPart& rMimeBodyPart);
     //:Copy constructor

   virtual
   ~MimeBodyPart();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   MimeBodyPart& operator=(const MimeBodyPart& rhs);
     //:Assignment operator

   /** Update the members that locate this MimeBodyPart within its parent
    *  HttpBody.
    */
   void attach(HttpBody* parent,
               int rawPartStart, int rawPartLength,
               int partStart, int partLength);

/* ============================ ACCESSORS ================================= */

   // Get the various indexes from the object.
   int getRawStart() const;
   int getRawLength() const;
   int getStart() const;
   int getLength() const;

   virtual void getBytes(const char** bytes, int* length) const;

   UtlBoolean getPartHeaderValue(const char* headerName,
                                 UtlString& headerValue) const;

   UtlDList* getParameters();

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    UtlDList mNameValues;
    const HttpBody* mpParentBody;
    int mParentBodyRawStartIndex;
    int mRawBodyLength;
    int mParentBodyStartIndex;
    int mBodyLength;

};

/* ============================ INLINE METHODS ============================ */

inline int MimeBodyPart::getRawStart() const
{
   return mParentBodyRawStartIndex;
}

inline int MimeBodyPart::getRawLength() const
{
   return mRawBodyLength;
}

inline int MimeBodyPart::getStart() const
{
   return mParentBodyStartIndex;
}

inline int MimeBodyPart::getLength() const
{
   return mBodyLength;
}

inline UtlDList* MimeBodyPart::getParameters()
{
   return &mNameValues;
}

#endif  // _MimeBodyPart_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _NameValuePair_h_
#define _NameValuePair_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include "utl/UtlString.h"

#include <os/OsMutex.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//: Name Value pair
// for storing string values associated with a key or name
class NameValuePair : public UtlString
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   NameValuePair(const char* name, const char* value = NULL);
   //: Construct a pair
   // Data is copied not attached or freed
   //! param: name - the key for this object, null terminated string
   //! param: value - the data or value for this object, null
   //! param:   terminated string

   virtual
   ~NameValuePair();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   NameValuePair& operator=(const NameValuePair& rhs);
     //:Assignment operator

   NameValuePair(const NameValuePair& rNameValuePair);
     //: Copy constructor

/* ============================ ACCESSORS ================================= */

   const char* getValue();
   //: get value string
   //! returns: the null terminated string containing the value <br>
   //! Note: this should not be freed as it is part of this object

   void setValue(const char*);

/* ============================ INQUIRY =================================== */
public:
        static int count;

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
   char* valueString;

   NameValuePair();
     //: Hide Default constructor

        static OsMutex    mCountLock;

};

/* ============================ INLINE METHODS ============================ */

#endif  // _NameValuePair_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _NameValuePairInsensitive_h_
#define _NameValuePairInsensitive_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include "net/NameValuePair.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//: For storing string values associated with a key or name.
//  Functions like NameValuePair, but the name (key) is case-insensitive.
class NameValuePairInsensitive : public NameValuePair
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   NameValuePairInsensitive(const char* name, const char* value = NULL);
   //: Construct a pair
   // Data is copied, not attached or freed
   //! param: name - the key for this object, null terminated string
   //! param: value - the data or value for this object, null
   //! param:   terminated string

   virtual
   ~NameValuePairInsensitive();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   NameValuePairInsensitive& operator=(const NameValuePairInsensitive& rhs);
     //:Assignment operator

   NameValuePairInsensitive(const NameValuePairInsensitive& rNameValuePairInsensitive);
     //: Copy constructor

/* ============================ ACCESSORS ================================= */

   const char* getValue();
   //: get value string
   //! returns: the null terminated string containing the value <br>
   //! Note: this should not be freed as it is part of this object

   void setValue(const char*);

/* ============================ INQUIRY =================================== */
public:

   // Redefine all the container support operations to be case-insenstive,
   // rather than the case-sensitive operations on keys that NameValuePair
   // inherits from UtlString.

    /// Calculate a hash over the string contents.
    virtual unsigned hash() const;
    /**<
     * If the equals operator returns true for another object, then both
     * objects must return the same hashcode.
     */

    /// Return the unique type value for this class.
    virtual UtlContainableType getContainableType() const;

    /// Compare to any other UtlContainable
    virtual int compareTo(UtlContainable const *other) const;
    /**<
     * Compare this object to another containable object.
     * If the UtlContainableType of the other object is not the UtlString type,
     * this will return unequal.
     *
     * @returns 0 if equal, < 0 if less than, and > 0 if greater.
     */

    virtual UtlBoolean isEqual(UtlContainable const *) const;
    /**<
     * Test this object to another like-object for equality.  This method
     * returns false if unlike-objects are specified.
     */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

    static UtlContainableType TYPE;    /** < Class type used for runtime checking */

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

};

/* ============================ INLINE METHODS ============================ */

#endif  // _NameValuePairInsensitive_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _NameValueTokenizer_h_
#define _NameValueTokenizer_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include "utl/UtlString.h"

// DEFINES
#define NEWLINE '\n'
#define CARRIAGE_RETURN '\r'
#define CARRIAGE_RETURN_NEWLINE "\r\n"

// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//: Parses name value pairs from multiple lines of text
//
class NameValueTokenizer
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   NameValueTokenizer(const char* multiLineText, int textLength = -1);
     //:Default constructor



   virtual
   ~NameValueTokenizer();
     //:Destructor

/* ============================ MANIPULATORS ============================== */
   static int findNextLineTerminator(const char* text, int length,
                                     int* nextLineIndex);
   //: Finds the index to the next line terminator
   //! param: text - the char array in which to search for the
   // terminator
   //! param: length - the length of the text array
   //! param: nextLineIndex - the index to the begining of the next
   // line.  This may be -1 if the end of the string is encountered
   //! returns: index into the text char array to the line terminator
   // Note: the line terminator may be 1 or 2 characters

   static void frontTrim(UtlString* string, const char* whiteSpace);
   static void backTrim(UtlString* string, const char* whiteSpace);
   static void frontBackTrim(UtlString* string, const char* whiteSpace);

   static UtlBoolean getSubField(const char* textField,
                                 int subfieldIndex,
                                 const char* subfieldSeparator,
                                 UtlString* subfieldText,
                                 int* lastCharIndex = NULL);

   static UtlBoolean getSubField(const char* textField,
                                 int textFieldLength,
                                 int subfieldIndex,
                                 const char* subfieldSeparators,
                                 const char*& subfieldPtr,
                                 int& subFieldLength,
                                 int* lastCharIndex);

   UtlBoolean getNextPair(char separator, UtlString* name, UtlString* value);

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */
    UtlBoolean isAtEnd();
    int getProcessedIndex();

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    const char* textPtr;
    int textLen;
    int bytesConsumed;

    NameValueTokenizer(const NameValueTokenizer& rNameValueTokenizer);
    //:disable Copy constructor

    NameValueTokenizer& operator=(const NameValueTokenizer& rhs);
    //: disable Assignment operator

};

/* ============================ INLINE METHODS ============================ */

#endif  // _NameValueTokenizer_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _NetAttributeTokenizer_h_
#define _NetAttributeTokenizer_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <utl/UtlString.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlList;

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class NetAttributeTokenizer
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   NetAttributeTokenizer(const char* parseString = NULL);
     //:Default constructor

   virtual
   ~NetAttributeTokenizer();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   UtlBoolean getNextAttribute(UtlString& attributeName, UtlString& attributeValue);
   // Retrieve the next attribute name and value if present

   UtlBoolean getAttributes(UtlList& attributeList);
   // Retrieve all of the attributes in the collection of NameValuePair(s)

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    UtlString attributeParseString;
    int parseIndex;

   NetAttributeTokenizer(const NetAttributeTokenizer& rNetAttributeTokenizer);
     //:Copy constructor (disabled)
   NetAttributeTokenizer& operator=(const NetAttributeTokenizer& rhs);
     //:Assignment operator (disabled)

};

/* ============================ INLINE METHODS ============================ */

#endif  // _NetAttributeTokenizer_h_
//
// Copyright (C) 2005-2007 SIPfoundry Inc.
// License by SIPfoundry under the LGPL license.
// 
// Copyright (C) 2004 Pingtel Corp.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// Copyright (C) 2007 SIPez, LLC.
// Licensed to SIPfoundry under a Contributor Agreement.
//
////////////////////////////////////////////////////////////////////////

#ifndef _NetBase64Codec_h_
#define _NetBase64Codec_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include "utl/UtlString.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS


/// Provides methods for translating to and from base64 encoding.
/**
 * Base 64 is a convenient encoding used to translate arbitrary binary
 * data into a fixed 64 character subset of ascii (plus one additional
 * character used to indicate padding).  This implementation* uses the
 * alphabet specified in Table 1 of RFC 3548 (which is the standard MIME
 * alphabet).
 *
 * @nosubgrouping
 */
class NetBase64Codec
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

/* ============================ CREATORS ================================== */

   // ================================================================
   /** @name                  Encoding Operations
    *
    * These methods translate from the binary data to the encodedData string
    */
   ///@{

   /// Encode from one array into another
   static void encode(int dataSize,         ///< the size of the binary data in octets         
                      const char data[],    ///< the binary data - not null terminated         
                      int& encodedDataSize, ///< output: the size of the encoded data in octets
                      char encodedData[]    ///< output: the encoded data                      
                      );

   /// Encode from an array into a UtlString
   static void encode(int dataSize,          ///< the size of the binary data in octets
                      const char data[],     ///< the binary data - not null terminated
                      UtlString& encodedData ///< output: the encoded data
                      );

   /// Encode from one UtlString into another.
   static void encode(const UtlString& data, ///< size is data.length(), not null terminated
                      UtlString& encodedData ///< output: the encoded data
                      )
   {
      NetBase64Codec::encode(data.length(),data.data(),encodedData);
   };
   
   /// @returns the number of encoded octets for given number of input binary octets
   static int encodedSize(int dataSize);

   ///@}
   
   // ================================================================
   /** @name                  Decoding Operations
    *
    * The decoding methods translate from the encoded parameter to the binary data
    * All return false if the encoded data value contained any characters
    * that are not legal in the base64 alphabet.
    */
   ///@{

   /// @returns true iff the encoded data is syntactically valid.
   static bool isValid(int encodedDataSize,      ///< the size of the encoded data in octets
                       const char encodedData[]  ///< the encoded data 
                       )
   {
      return validEncodingBytes(encodedDataSize, encodedData) > 0;
   }
   

   /// @returns true iff the encoded data is syntactically valid.
   static bool isValid(const UtlString& encodedData ///< size is data.length(), not null terminated
                       )
   {
      return validEncodingBytes(encodedData.length(), encodedData.data()) > 0;
   }
   
   /// Decode from the character encodedData to the binary data array.
   static bool decode(int encodedDataSize,      ///< the size of the encoded data in octets
                      const char encodedData[], ///< the encoded data 
                      int& dataSize,            ///< output: the size of the binary data in octets
                      char data[]               ///< output: the binary data - not null terminated
                      );
   ///< @returns false and no data if the encodedData contains any invalid characters.

   /// Decode from one UtlString into another
   static bool decode(const UtlString& encodedData, ///< size is data.length(), not null terminated
                      UtlString& data               ///< output: the decoded data
                      );
   ///< @returns false and no data if the encodedData contains any invalid characters.
   
   /// Compute the number of output binary octets for given set of encoded octets.
   static int decodedSize(int encodedDataSize,
                          const char encodedData[]
                          );
   ///< @returns zero if the encodedData contains any invalid characters.

   /// Compute the number of output binary octets for given set of encoded octets.
   static int decodedSize(const UtlString& encodedData  ///< size is data.length()
                          )
   {
      ///< @returns zero if the encodedData contains any invalid characters.
      return decodedSize(encodedData.length(), encodedData.data());
   }
   

  private:
   
   static const char* Base64Codes;

   inline static char decodeChar(const char encoded);

   /// @returns > 0 iff the encoded data is syntactically valid, 0 if not.
   static size_t validEncodingBytes(int encodedDataSize, ///< number of encoded octets
                                    const char encodedData[]  ///< the encoded data 
                                    );

   ///@}

   // @cond INCLUDENOCOPY
   NetBase64Codec();
   //:Default constructor (disabled)


   virtual
      ~NetBase64Codec();
   
   NetBase64Codec(const NetBase64Codec& rNetBase64Codec);
   //:Copy constructor (disabled)

   NetBase64Codec& operator=(const NetBase64Codec& rhs);
   //:Assignment operator (disabled)

   // @endcond     
};

#endif  // _NetBase64Codec_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _NetMd5Codec_h_
#define _NetMd5Codec_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <utl/UtlString.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
const size_t MD5_SIZE = 32;

// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class NetMd5Codec
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   NetMd5Codec();
     //:Default constructor


   virtual
   ~NetMd5Codec();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   static void encode(const char* test, UtlString& encodedText);

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
   NetMd5Codec(const NetMd5Codec& rNetMd5Codec);
     //:Copy constructor (disabled)

   NetMd5Codec& operator=(const NetMd5Codec& rhs);
     //:Assignment operator (disabled)

};

/* ============================ INLINE METHODS ============================ */
/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
 */

#ifdef __cplusplus
   extern "C" {
#endif

/* PROTOTYPES should be set to one if and only if the compiler supports
  function argument prototyping.
The following makes PROTOTYPES default to 0 if it has not already
  been defined with C compiler flags.
 */
#ifndef PROTOTYPES
#define PROTOTYPES 1
#endif

/* POINTER defines a generic pointer type */
typedef unsigned char *POINTER;

/* UINT2 defines a two byte word */
typedef unsigned short int UINT2;

/* UINT4 defines a four byte word */
typedef unsigned long int UINT4;

/* PROTO_LIST is defined depending on how PROTOTYPES is defined above.
If using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
  returns an empty list.
 */
#if PROTOTYPES
#define PROTO_LIST(list) list
#else
#define PROTO_LIST(list) ()
#endif


/* MD5 context. */
typedef struct {
  UINT4 state[4];                                   /* state (ABCD) */
  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];                         /* input buffer */
} MD5_CTX_PT;

void MD5Init PROTO_LIST ((MD5_CTX_PT *));
void MD5Update PROTO_LIST
  ((MD5_CTX_PT *, unsigned char *, unsigned int));
void MD5Final PROTO_LIST ((unsigned char [16], MD5_CTX_PT *));

#ifdef __cplusplus
   }
#endif

#endif  // _NetMd5Codec_h_
// 
// Copyright (C) 2005 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
// 
// Copyright (C) 2005 SIPez LLC.
// Licensed to SIPfoundry under a Contributor Agreement.
// 
// $$
//////////////////////////////////////////////////////////////////////////////

// Author: Daniel Petrie (dpetrie AT SIPez DOT com)


#ifndef _PidfBody_h_
#define _PidfBody_h_

// SYSTEM INCLUDES


// APPLICATION INCLUDES
#include <net/HttpBody.h>
#include <utl/UtlDList.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//! class to contain an PIDF presense state body
/*! 
 */
class PidfBody : public HttpBody
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:


/* ============================ CREATORS ================================== */

    //! Default constructor
    PidfBody(const char* resourceAor = NULL);

    //! Construct an PidfBody from body bytes
    PidfBody(const char* bytes, 
             int length,
             const char* contentEncodingValueString);

    //! Copy constructor
    PidfBody(const PidfBody& rPidfBody);

    //! Destructor
    virtual ~PidfBody();

/* ============================ MANIPULATORS ============================== */

    //! Assignment operator
    PidfBody& operator=(const PidfBody& rhs);

    //! Render the PIDF data into the XML format of the body
    /*! The PidfBody MUST be rendered if you set or change any
     *  of the PIDF information.  getBytes does this automatically
     *  if the data has changed.
     */
    void render();


    static int parseXmlToPidfProperties(const char* bytes, 
                                        int length, 
                                        const char* contentEncodingValueString,
                                        UtlString& entityAor,
                                        UtlDList& tuples);

/* ============================ ACCESSORS ================================= */

    //! Get the AOR (PIDF presence element, entity attribute) for the PIDF doc.
    void getEntityAor(UtlString& entityAor) const;

    //! get the body content of the PIDF body.
    /*! Renders the body into the mBody member if PIDF content
     *  has been changed via the accessors.
     */
    virtual void getBytes(const char** bytes, int* length) const;
    virtual void getBytes(UtlString* bytes, int* length) const;

       //! Get the presense status/state
    /*! Get the value of the status element of the tuple indicated by
     *  tupleIndex.
     *  \param tupleIndex - indicates which tuple to get the status from
     *  \param tuple - the value of the tupleId attribute of the indicated tuple
     *  \param basicStatus - the value of the <basic> element in the <status>
     *         element of the tuple.
     */
    UtlBoolean getBasicStatus(int tupleIndex, 
                                UtlString& tupleId, 
                                UtlBoolean& isTupleStatusBasicOpen,
                                UtlString& contact,
                                UtlString& tupleNote) const;

    //! Set the presence status/state
    void addBasicStatus(const UtlString& tupleId, 
                        const UtlBoolean& isTupleStatusBasicOpen,
                        const UtlString& contact,
                        const UtlString& tupleNote);

    //! Change the basic element value in the indicated tuple element
    UtlBoolean changeBasicStatus(int tupleIndex,
                                 UtlBoolean isTupleStatusBasicOpen);

/* ============================ INQUIRY =================================== */



/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:


/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    // These will probably need to be lists
    UtlString mEntityAor; // Address of Record
    UtlDList mTuples;

    UtlBoolean mRendered;  // Has been rendered to XML body string in mBody

    void renderPidfXmlHeader(const UtlString& entityAor);
    void renderPidfTuple(const UtlString& tupleId,
                         const UtlBoolean isTupleStatusBasicOpen,
                         const UtlString& tupleContact,
                         const UtlString& tupleNote);
    void renderPidfXmlFooter();

    void copyTuples(const UtlDList& sourceList, UtlDList& targetList);
};

/* ============================ INLINE METHODS ============================ */

#endif  // _PidfBody_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#include "nspr.h"
#include "secutil.h"
#include "pk11func.h"
#include "pkcs12.h"
#include "p12plcy.h"
#include "nss.h"
#include "secport.h"
#include "certdb.h"

bool P12Wrapper_Init(char *dir, char *dbprefix);

SECStatus P12Wrapper_ImportPKCS12ObjectFromBuffer(char *pkcs12Buffer, int pkcs12Size, PK11SlotInfo *slot,
			SECItem *slotPw, SECItem *p12FilePw);
			
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _ProvisioningAgent_h_
#define _ProvisioningAgent_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include <os/OsFS.h>
#include <os/OsStatus.h>
#include <utl/UtlString.h>
#include <utl/UtlHashMap.h>
#include "net/ProvisioningAttrList.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class TiXmlDocument;
class ProvisioningClass;

/**
 * 
 */
class ProvisioningAgent {
public:
/* //////////////////////////// PUBLIC //////////////////////////////////// */
   enum ReturnCodes {
      UNDEFINED      = 0,
      SUCCESS        = 1,
      FAILURE        = 2,
      READONLY       = 3,
      UNKNOWN_OBJECT = 4,
      UNKNOWN_CLASS  = 5,
      INVALID_ATTR   = 6,
      MISSING_ATTR   = 7,
      DUPLICATE      = 8,
      CREATE_FAILURE = 9
   };

/* ============================ CREATORS ================================== */

   /**
    * Default constructor
    */
   ProvisioningAgent(const char* pServerClass = NULL, bool persistentStore = FALSE);

   /**
    * Destructor
    */
   ~ProvisioningAgent();

/* ============================ MANIPULATORS ============================== */
   OsStatus registerClass(ProvisioningClass* pProvisioningClass);
   OsStatus unregisterClass(ProvisioningClass* pProvisioningClass);

   ProvisioningAttrList* Create(ProvisioningAttrList& rRequestAttributes);
   ProvisioningAttrList* Delete(ProvisioningAttrList& rRequestAttributes);
   ProvisioningAttrList* Set(ProvisioningAttrList& rRequestAttributes);
   ProvisioningAttrList* Get(ProvisioningAttrList& rRequestAttributes);
   ProvisioningAttrList* Action(ProvisioningAttrList& rRequestAttributes);


/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
   ProvisioningClass* lookupProvisioningClass(ProvisioningAttrList& rRequestAttributes);

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
   UtlString       mServerClass;       /* The name of the server class that
                                        * this agent is provisioning. */
   OsPath*         mpConfigFile;       /* The path and name of the xml config
                                        * file for this Provisioning Agent. */
   TiXmlDocument*  mpXmlConfigDoc;     /* The TinyXml persistant store for
                                        * this Provisioning Agent. */
   UtlHashMap      mRegisteredClasses; /* Provisioning Classes that are retistered
                                        * with this Provisioning Agent. */
};

#endif  // _ProvisioningAgent_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _ProvisioningAgentXmlRpcAdapter_h_
#define _ProvisioningAgentXmlRpcAdapter_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "net/XmlRpcMethod.h"

// DEFINES
#define EXPECTED_STRUCT_FAULT_CODE 1
#define EXPECTED_STRUCT_FAULT_STRING "Argument type error: expected a struct."

#define METHOD_DISPATCH_FAULT_CODE 2
#define METHOD_DISPATCH_FAULT_STRING "Failed to dispatch the target method procedure."

// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlSList;
class UtlContainable;
class HttpRequestContext;
class XmlRpcDispatch;
class XmlRpcResponse;

/**
 * This class implements the mapping between the XmlRpc procedure "create" and
 * the ProvisioningAgent::create() member function.
 */
class ProvisioningAgentXmlRpcAdapter {
public:
/* //////////////////////////// PUBLIC //////////////////////////////////// */

/* ============================ CREATORS ================================== */

   /**
    * Default constructor
    */
   ProvisioningAgentXmlRpcAdapter(const ProvisioningAgent* pProvisioningAgent,
                                  int serverPort,
                                  bool secureTransport = false);

   /**
    * Destructor
    */
   virtual ~ProvisioningAgentXmlRpcAdapter();

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
   XmlRpcDispatch* mpXmlRpcServer;


   ProvisioningAgentXmlRpcAdapter(const ProvisioningAgentXmlRpcAdapter& rProvisioningAgentXmlRpcAdapter);
   //:Copy constructor (not implemented for this class)

   ProvisioningAgentXmlRpcAdapter& operator=(const ProvisioningAgentXmlRpcAdapter& rhs);
   //:Assignment operator (not implemented for this class)
};


/**
 * This class implements the mapping between the XmlRpc procedure "create" and
 * the ProvisioningAgent::create() member function.
 */
class ProvisioningAgentXmlRpcCreate : public XmlRpcMethod {
public:
/* //////////////////////////// PUBLIC //////////////////////////////////// */

/* ============================ CREATORS ================================== */

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */
/**
 * Create a dynamic instance of this class and return the pointer to it.
 */
   static ProvisioningAgentXmlRpcCreate* get(void) {
      return new ProvisioningAgentXmlRpcCreate;
   }

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
/**
 * This is the actual method called by the underlying XmlRpc Dispatcher in
 * response to receiving a <methodCall>.  It will call the corresponding
 * ProvisioningAgent method whos instance is supplied in the
 * provisioningAgentInstance argument.
 */
   bool execute(const HttpRequestContext&      rContext,
                UtlSList&                      rParameters,
                void*                          pProvisioningAgentInstance,
                XmlRpcResponse&                rResponse,
                XmlRpcMethod::ExecutionStatus& rStatus);

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
};


/**
 * This class implements the mapping between the XmlRpc procedure "delete" and
 * the ProvisioningAgent::delete() member function.
 */
class ProvisioningAgentXmlRpcDelete : public XmlRpcMethod {
public:
/* //////////////////////////// PUBLIC //////////////////////////////////// */

/* ============================ CREATORS ================================== */

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */
/**
 * Create a dynamic instance of this class and return the pointer to it.
 */
   static ProvisioningAgentXmlRpcDelete* get(void) {
      return new ProvisioningAgentXmlRpcDelete;
   }

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
/**
 * This is the actual method called by the underlying XmlRpc Dispatcher in
 * response to receiving a <methodCall>.  It will call the corresponding
 * ProvisioningAgent method whos instance is supplied in the
 * provisioningAgentInstance argument.
 */
   bool execute(const HttpRequestContext&      rContext,
                UtlSList&                      rParameters,
                void*                          pProvisioningAgentInstance,
                XmlRpcResponse&                rResponse,
                XmlRpcMethod::ExecutionStatus& rStatus);

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
};


/**
 * This class implements the mapping between the XmlRpc procedure "set" and
 * the ProvisioningAgent::set() member function.
 */
class ProvisioningAgentXmlRpcSet : public XmlRpcMethod {
public:
/* //////////////////////////// PUBLIC //////////////////////////////////// */

/* ============================ CREATORS ================================== */

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */
/**
 * Create a dynamic instance of this class and return the pointer to it.
 */
   static ProvisioningAgentXmlRpcSet* get(void) {
      return new ProvisioningAgentXmlRpcSet;
   }

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
/**
 * This is the actual method called by the underlying XmlRpc Dispatcher in
 * response to receiving a <methodCall>.  It will call the corresponding
 * ProvisioningAgent method whos instance is supplied in the
 * provisioningAgentInstance argument.
 */
   bool execute(const HttpRequestContext&      rContext,
                UtlSList&                      rParameters,
                void*                          pProvisioningAgentInstance,
                XmlRpcResponse&                rResponse,
                XmlRpcMethod::ExecutionStatus& rStatus);

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
};


/**
 * This class implements the mapping between the XmlRpc procedure "get" and
 * the ProvisioningAgent::get() member function.
 */
class ProvisioningAgentXmlRpcGet : public XmlRpcMethod {
public:
/* //////////////////////////// PUBLIC //////////////////////////////////// */

/* ============================ CREATORS ================================== */

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */
/**
 * Create a dynamic instance of this class and return the pointer to it.
 */
   static ProvisioningAgentXmlRpcGet* get(void) {
      return new ProvisioningAgentXmlRpcGet;
   }

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
/**
 * This is the actual method called by the underlying XmlRpc Dispatcher in
 * response to receiving a <methodCall>.  It will call the corresponding
 * ProvisioningAgent method whos instance is supplied in the
 * provisioningAgentInstance argument.
 */
   bool execute(const HttpRequestContext&      rContext,
                UtlSList&                      rParameters,
                void*                          pProvisioningAgentInstance,
                XmlRpcResponse&                rResponse,
                XmlRpcMethod::ExecutionStatus& rStatus);

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
};


/**
 * This class implements the mapping between the XmlRpc procedure "action" and
 * the ProvisioningAgent::action() member function.
 */
class ProvisioningAgentXmlRpcAction : public XmlRpcMethod {
public:
/* //////////////////////////// PUBLIC //////////////////////////////////// */

/* ============================ CREATORS ================================== */

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */
/**
 * Create a dynamic instance of this class and return the pointer to it.
 */
   static ProvisioningAgentXmlRpcAction* get(void) {
      return new ProvisioningAgentXmlRpcAction;
   }

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
/**
 * This is the actual method called by the underlying XmlRpc Dispatcher in
 * response to receiving a <methodCall>.  It will call the corresponding
 * ProvisioningAgent method whos instance is supplied in the
 * provisioningAgentInstance argument.
 */
   bool execute(const HttpRequestContext&      rContext,
                UtlSList&                      rParameters,
                void*                          pProvisioningAgentInstance,
                XmlRpcResponse&                rResponse,
                XmlRpcMethod::ExecutionStatus& rStatus);

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
};

#endif  // _ProvisioningAgentXmlRpcAdapter_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _ProvisioningAttrList_h_
#define _ProvisioningAttrList_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include <utl/UtlString.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class UtlHashMap;
class UtlSList;
class UtlContainable;

/**
 * 
 */
class ProvisioningAttrList {
public:
/* //////////////////////////// PUBLIC //////////////////////////////////// */

   enum eAttributeType {
      INT,
      BOOL,
      STRING
   };

/* ============================ CREATORS ================================== */

   /**
    * Default constructor
    */
   ProvisioningAttrList(void);

   /**
    * Reference constructor
    */
   ProvisioningAttrList(UtlHashMap* pData);

   /**
    * Destructor
    */
   virtual ~ProvisioningAttrList();

/* ============================ MANIPULATORS ============================== */

   bool setAttribute(const char* pKey, UtlSList* pValue);
   bool setAttribute(const char* pKey, const UtlString& rValue);
   bool setAttribute(const char* pKey, const char* pValue);
   bool setAttribute(const char* pKey, int value);
   bool setAttribute(const char* pKey, bool value);

/* ============================ ACCESSORS ================================= */

   UtlContainable* getAttribute(const char* pKey);
   UtlContainable* operator[](const char* pKey) { return getAttribute(pKey);}
   bool getAttribute(const char* pKey, UtlString& rValue);
   bool getAttribute(const char* pKey, const char*& prValue);
   bool getAttribute(const char* pKey, int& rValue);
   bool getAttribute(const char* pKey, bool& rValue);
   UtlHashMap* getData(void) { return mpData;}
   void dumpAttributes(void);

/* ============================ INQUIRY =================================== */

   bool attributeMissing(const char* pKey);
   bool attributePresent(const char* pKey);
   void validateAttribute(const char* pKey, eAttributeType type, bool ignoreMissing = false);
   void validateAttributeType(const char* pKey, eAttributeType type);

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
   void deleteAttrElements(UtlContainable* pAttrElements);
   static void dumpAttributes(const UtlContainable* pAttribute);

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
   UtlHashMap*         mpData;               /* Pointer to the containing data. */
   bool                mIsReference;         /* Is mpData a reference ? */
};

#endif  // _ProvisioningAttrList_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _ProvisioningClass_h_
#define _ProvisioningClass_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include <utl/UtlString.h>
#include <utl/UtlContainable.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class TiXmlNode;
class TiXmlDocument;
class ProvisioningServer;
class ProvisioningAttrList;


class ProvisioningClass : public UtlContainable {
public:
/* //////////////////////////// PUBLIC //////////////////////////////////// */

/* ============================ CREATORS ================================== */

   /**
    * Default constructor
    */
   ProvisioningClass(const char* pClassName);

   /**
    * Destructor
    */
   virtual ~ProvisioningClass();

/* ============================ MANIPULATORS ============================== */
   virtual ProvisioningAttrList* Create(ProvisioningAttrList& rRequestAttributes);
   virtual ProvisioningAttrList* Delete(ProvisioningAttrList& rRequestAttributes);
   virtual ProvisioningAttrList* Set(ProvisioningAttrList& rRequestAttributes);
   virtual ProvisioningAttrList* Get(ProvisioningAttrList& rRequestAttributes);
   virtual ProvisioningAttrList* Action(ProvisioningAttrList& rRequestAttributes);

   void    setXmlConfigDoc(TiXmlDocument* pConfigDoc);

   virtual bool loadConfiguration(void);

/* ============================ ACCESSORS ================================= */

   TiXmlNode* findPSInstance(const char* pClassName, const char* pIndexAttr = NULL, const char* pIndexValue = NULL);
   TiXmlNode* createPSInstance(const char* pClassName, const char* pIndexAttr, const char* pIndexValue);
   bool       deletePSInstance(const char* pClassName, const char* pIndexAttr, const char* pIndexValue);

   bool       setPSAttribute(TiXmlNode* pClassInstance, const char* pAttribute, UtlString& rValue);
   bool       setPSAttribute(TiXmlNode* pClassInstance, const char* pAttribute, const char* pValue);
   bool       setPSAttribute(TiXmlNode* pClassInstance, const char* pAttribute, int value);
   bool       setPSAttribute(TiXmlNode* pClassInstance, const char* pAttribute, bool value);

//   bool       getPSAttribute(TiXmlNode* pClassInstance, const char* pAttribute, const char*& prValue);
   bool       getPSAttribute(TiXmlNode* pClassInstance, const char* pAttribute, UtlString& rValue);
   bool       getPSAttribute(TiXmlNode* pClassInstance, const char* pAttribute, int& rValue);
   bool       getPSAttribute(TiXmlNode* pClassInstance, const char* pAttribute, bool& rValue);

   const UtlString* getClassName(void);

   /**
    * Calculate a unique hash code for this object.  If the equals
    * operator returns true for another object, then both of those
    * objects must return the same hashcode.
    */    
   virtual unsigned hash() const;

   /**
    * Get the ContainableType for a UtlContainable derived class.
    */
   virtual UtlContainableType getContainableType() const;

/* ============================ INQUIRY =================================== */

   /**
    * Compare the this object to another like-objects.  Results for 
    * designating a non-like object are undefined.
    *
    * @returns 0 if equal, < 0 if less then and >0 if greater.
    */
   virtual int compareTo(UtlContainable const *) const;

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
   static const UtlContainableType TYPE;           /** < Class type used for runtime checking */ 

   TiXmlDocument*      mpXmlConfigDoc;       /* The TinyXml persistant store for
                                              * this Provisioning Class. */
   ProvisioningServer* mpProvisioningServer; /* The reference to the Provisioning
                                              * Server that this is registered with. */
   bool                mConfigurationLoaded; /** < Flag indicating if configuration has been loaded. */

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
   UtlString           mClassName;           /* The name of the provisioning class
                                              * that this is managing. */
};

#endif  // _ProvisioningClass_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _QoS_h_
#define _QoS_h_

// DEFINES
#define QOS_LAYER2_LOW_DELAY_PRIO   5
#define QOS_LAYER3_LOW_DELAY_IP_TOS 0xb8
#define QOS_LAYER3_HIGH_RELIABILITY 0x64

#endif  // _QoS_h_
//
// Copyright (C) 2005 SIPez LLC.
// Licensed to SIPfoundry under a Contributor Agreement.
// 
// Copyright (C) 2004 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
//////////////////////////////////////////////////////////////////////////////
// Author: Daniel Petrie (dpetrie AT SIPez DOT com)

#ifndef _SdpBody_h_
#define _SdpBody_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlSListIterator.h"
#include "os/OsSocket.h"
#include "os/OsNatConnectionSocket.h"
#include <tapi/sipXtapiEvents.h>

#include <net/HttpBody.h>
#include <net/NameValuePair.h>
#include <sdp/SdpCodec.h>

// DEFINES
#define SDP_AUDIO_MEDIA_TYPE "audio"
#define SDP_VIDEO_MEDIA_TYPE "video"
#define SDP_APPLICATION_MEDIA_TYPE "application"

// Crypto suites
#define AES_CM_128_HMAC_SHA1_80   1
#define AES_CM_128_HMAC_SHA1_32   2
#define F8_128_HMAC_SHA1_80       3
// Protection level
#define SRTP_ENCRYPTION           0x0001
#define SRTP_AUTHENTICATION       0x0002
#define SRTP_SEND                 0x0004
#define SRTP_RECEIVE              0x0008
#define SRTP_OFF                  0
#define SRTP_ON                   (SRTP_ENCRYPTION|SRTP_AUTHENTICATION|SRTP_SEND|SRTP_RECEIVE)
#define SRTP_SECURITY_MASK        (SRTP_ENCRYPTION|SRTP_AUTHENTICATION)
// Key length       
#define SRTP_KEY_LENGTH          30

// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
#define SDP_CONTENT_TYPE "application/sdp"
// STRUCTS
// TYPEDEFS
typedef struct SdpSrtpParameters
{
    int cipherType;
    int securityLevel;
    unsigned char masterKey[SRTP_KEY_LENGTH+1];
} SdpSrtpParameters;


// FORWARD DECLARATIONS
class SdpCodecFactory;

/// Container for MIME type application/sdp.
/**
 * This body type gets constructed when a HttpBody is a single
 * part MIME or multipart MIME which has a part of type
 * application/sdp.  This object has methods to manipulate,
 * iterate and construct SDP fields and media stream definitions
 *
 * In the descriptions below:
 *
 * * A 'valid field string' is any sequence of UTF-8 encoded ISO 10646 characters
 *   except 0x00 (Nul), 0x0A (LF), and 0x0D (CR).
 *   For other character sets, see RFC 2327.
 *
 * * An 'IP address' is in the canonical text format:
 *   For IP4 this is of the format:
 *   nnn.nnn.nnn.nnn where nnn is 0 to 255
 *
 * * The 'network type' and 'address type' are strings as defined
 *   in rfc 2327; should probably be "IN" and "IP4" respectively for now.
 *
 */
class SdpBody : public HttpBody
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

/** 
 * @name ====================== Constructors and Destructors
 * @{
 */
   /// Construct from an existing SDP message value, or create an empty body. 
   SdpBody(const char* bytes = NULL, ///< NULL creates an empty body             
           int byteCount = -1        ///< -1 means treat bytes as null terminated
           );

   /// Copy constructor
   SdpBody(const SdpBody& rSdpBody);

   /// Destructor
   virtual
      ~SdpBody();

///@}
   
/**
 * @name ====================== Message Serialization Interfaces
 *
 * @{
 */

   /// Get the string length this body would be if serialized
   virtual int getLength() const;

   /// Get the serialized string representation of this SDP message.
   virtual void getBytes(const char** bytes, ///< buffer space where SDP is written, null terminated
                         int* length         ///< number of bytes written (not including the null terminator)
                         ) const;

   /// Get the serialized string representation of this SDP message.
   virtual void getBytes(UtlString* bytes, ///< message output
                         int* length       ///< number of bytes in message
                         ) const;

///@}

/**
 * @name ====================== Header Setting Interfaces
 *
 * These methods set the standard header fields (the ones not in a media set)
 *
 * @{
 */

   void setStandardHeaderFields(const char* sessionName,  ///< any valid field string
                                const char* emailAddress, ///< email address per rfc 2327
                                const char* phoneNumber,  ///< phone number address per rfc 2327
                                const char* originatorAddress ///< IP address
                                );


   void setSessionNameField(const char* sessionName);

   void setOriginator(const char* userId,/**< user id of caller or "-" if host does not support
                                          *   the idea of user logon */
                      int sessionId,     ///< unique id for this call session
                      int sessionVersion,/**< number to get incremented each time
                                          *   the SDP data gets modified for this call session */
                      const char* address///< IP address
                      );

   void setEmailAddressField(const char* emailAddress);

   void setPhoneNumberField(const char* phoneNumber);

   // Append a 't' field after any existing times, converting from epoch->ntp time.
   void addEpochTime(unsigned long epochStartTime,
                     unsigned long epochEndTime = 0
                     );

   // Append a 't' field after any existing times.
   void addNtpTime(unsigned long ntpStartTime,
                   unsigned long ntpEndTime = 0
                   );

   // set all media attributes to either a=setup:actpass, a=setup:active, or a=setup:passive
   void setRtpTcpRole(RtpTcpRoles role);                   
   UtlString getRtpTcpRole();

///@}

/**
 * @name ====================== Media Setting Interfaces
 *
 * These interfaces are used to build up media descriptions
 *
 * @{
 */

   /// Create a set of media codec and address entries
   void addCodecsOffer(int iNumAddresses,
                       UtlString mediaAddresses[],
                       int rtpAudioPorts[],
                       int rtcpAudioPorts[],
                       int rtpVideoPorts[],
                       int rtcpVideoPorts[],
                       RTP_TRANSPORT transportTypes[],
                       int numRtpCodecs,
                       SdpCodec* rtpCodecs[],
                       SdpSrtpParameters& srtpParams,
                       int videoBandwidth,
                       int videoFramerate,
                       RTP_TRANSPORT transportOffering
                       );

   /**<
    * This method is for building a SdpBody which is in response
    * to a SdpBody send from the other side
    */

   /// Create a response to a set of media codec and address entries.
   void addCodecsAnswer(int iNumAddresses,
                       UtlString mediaAddresses[],
                       int rtpAudioPorts[],
                       int rtcpAudioPorts[],
                       int rtpVideoPorts[],
                       int rtcpVideoPorts[],
                       RTP_TRANSPORT transportTypes[],
                       int numRtpCodecs, 
                       SdpCodec* rtpCodecs[],
                       SdpSrtpParameters& srtpParams,
                       int videoBandwidth,
                       int videoFramerate,
                       const SdpBody* sdpRequest  ///< Sdp we are responding to
                       ); 
   /**<
    * This method is for building a SdpBody which is in response
    * to a SdpBody send from the other side
    */



   /// Create a new media set for SDP message.
   void addMediaData(const char* mediaType, ///< "audio", "video", "application", "data", "control"
                     int portNumber,        ///< TCP or UDP port number for the media stream
                     int portPairCount,     ///< the number of PAIRS of ports to be used for the media stream.
                     const char* mediaTransportType, ///< i.e. "RTP/AVP"
                     int numPayloadTypes,   ///< entries in the payloadType parameter 
                     int payloadType[]      /**< format specifier specific to context
                                             * of mediaTransportType.
                                             * (i.e. for TRP/AVP u-law this is 0, a-law is 14).
                                             * see RFC 1890 for the Payload Type numbers
                                             */
                     );

   void addCodecParameters(int numRtpCodecs,
                           SdpCodec* rtpCodecs[],
                           const char* szMimeType = "audio",
                           const int videoFramerate = 0
                           );

   /// Set address.
   void addConnectionAddress(const char* ipAddress /**< for IP4 this is of the format:
                                              * nnn.nnn.nnn.nnn where nnn is 0 to 255 */
                       );
    /**<
     * Set address for SDP message header or specific media set if called
     * after addAddressData.
     */

   void addConnectionAddress(const char* networkType, ///< network type - should be "IN"
                       const char* addressType, ///< address type - should be "IP4"
                       const char* ipAddress    ///< IP address
                       );

   /// Set address.
   void setConnectionAddress(const char* ipAddress /**< for IP4 this is of the format:
                                              * nnn.nnn.nnn.nnn where nnn is 0 to 255 */
                       );
    /**<
     * Set address for SDP message header or specific media set if called
     * after addAddressData.
     */
   void setConnectionAddress(const char* networkType, ///< network type - should be "IN"
                       const char* addressType, ///< address type - should be "IP4"
                       const char* ipAddress    ///< IP address
                       );

   void addRtpmap(int payloadType,
                  const char* mimeSubtype,
                  int sampleRate,
                  int numChannels
                  );

   void addSrtpCryptoField(SdpSrtpParameters& params);

   void addFormatParameters(int payloadType,
                            const char* formatParameters
                            );

   /// Add a "a" field for the given ptime value in milliseconds
   void addPtime(int pTime);

    /**
     * Set the candidate attribute per draft-ietf-mmusic-ice-05
     */
    void addCandidateAttribute(int         candidateId, 
                               const char* transportId, 
                               const char* transportType,
                               double      qValue, 
                               const char* candidateIp, 
                               int         candidatePort) ;

///@}
   
/**
 * @name ====================== Field Reading Interfaces
 *
 * Use these interfaces to get field values rather than the generic interfaces below.
 *
 * @{
 */

   //! Get the number of media description sets
   int getMediaSetCount() const;

   /// Get the index to the next media set of the given type.
   int findMediaType(const char* mediaType,  ///< the media type to search for
                     int startMediaIndex = 0 ///< start searching from here
                     ) const;
   /**<
    * The default is to start from the begining.  The resulting
    * index may be the start index if it is of the given type.
    *
    * @return the media index if it exists, -1 if it does not exist.
    */

   /// Read a full media line.
   UtlBoolean getMediaData(int mediaIndex, ///< the index of the media to read (the nth m line)
                           UtlString* mediaType,
                           int* mediaPort,
                           int* mediaPortPairs,
                           UtlString* mediaTransportType,
                           int maxPayloadTypes,
                           int* numPayloadTypes,
                           int payloadTypes[]) const;

   /// Inspects whether the given transport type and media type combination is specified 
   /// as an m-line in the sdp
   const bool isTransportAvailable(const OsSocket::IpProtocolSocketType protocol,
                                   const SIPX_MEDIA_TYPE mediaType) const;
                                   
   /// Read whether the media network type is IP4 or IP6.
   UtlBoolean getMediaNetworkType(int mediaIndex, ///< which media description set to read
                                  UtlString* networkType) const;

   /// Get IP address for the indicated media stream.
   UtlBoolean getMediaAddress(int mediaIndex, ///< which media description set to read
                              UtlString* address) const;

   /// Get the media type for the indicated  media stream.
   UtlBoolean getMediaType(int mediaIndex, ///< which media description set to read
                           UtlString* mediaType ///< audio, video, application, etc.
                           ) const;

   /// Get the port number for the indicated media stream.
   UtlBoolean getMediaPort(int mediaIndex, ///< which media description set to read
                           int* port) const;

   // Get the rtcp port number of the indicated media stream.
   UtlBoolean getMediaRtcpPort(int mediaIndex, ///< which media description set to read
                               int* port) const ;

   /// Get the number of port pairs in media stream.
   UtlBoolean getMediaPortCount(int mediaIndex, ///< which media description set to read
                                int* numPorts) const;
   /**<
    * Stream pairs start with the port number given by getMediaPort
    * and are incremented from there to derive the additional
    * port numbers
    */

   /// Get the transport protocol for the indicated media stream.
   UtlBoolean getMediaProtocol(int mediaIndex, ///< which media description set to read
                               UtlString* transportProtocol
                               ) const;

   /// Get the payload types for the indicated media stream.
   UtlBoolean getMediaPayloadType(int mediaIndex, ///< which media description set to read
                                  int maxTypes,   ///< size of the payloadTypes array
                                  int* numTypes,  ///< number of entries returned in payloadTypes
                                  int payloadTypes[] ///< array of integer payload types
                                  ) const;

   /// Get the ptime field for the given media set
   UtlBoolean getPtime(int mediaInded, int& ptime) const;

   /// Media field accessor utility.
   UtlBoolean getMediaSubfield(int mediaIndex,
                               int subfieldIndex,
                               UtlString* subField
                               ) const;

   /// Get the subfields of the rtpmap field.
   UtlBoolean getPayloadRtpMap(int payloadType,        ///< which rtp map to read
                               UtlString& mimeSubtype, ///< the codec name (mime subtype)
                               int& sampleRate,        ///< the number of samples/sec. (-1 if not set)
                               int& numChannels        ///< the number of channels (-1 if not set)
                               ) const;

   // Get the fmtp parameter
   UtlBoolean getPayloadFormat(int payloadType,
                               UtlString& fmtp,
                               int& valueFmtp,
                               int& numVideoSizes,
                               int videoSizes[]) const;

   // Get the crypto field for SRTP
   UtlBoolean getSrtpCryptoField(int mediaIndex,                  ///< mediaIndex of crypto field
                                 int index,                       ///< Index inside of media type
                                 SdpSrtpParameters& params) const;

   // Get the framerate field if there
   UtlBoolean getFramerateField(int mediaIndex,
                                int& videoFramerate) const;

   UtlBoolean getBandwidthField(int& bandwidth) const;

   /**<
    * Find the "a" record containing an rtpmap for the given
    * payload type id, parse it and return the parameters for it.
    */


   /// Find the send and receive codecs from the rtpCodecs array which are compatible with this SdpBody..
   void getBestAudioCodecs(int numRtpCodecs,
                           SdpCodec rtpCodecs[],
                           UtlString* rtpAddress,
                           int* rtpPort,
                           int* sendCodecIndex,
                           int* receiveCodecIndex) const;
   ///< It is assumed that the best matches are first in the body



   /// Find the send and receive codecs from the rtpCodecs array which are compatible with this SdpBody.
   void getBestAudioCodecs(SdpCodecFactory& localRtpCodecs,
                           int& numCodecsInCommon,
                           SdpCodec**& commonCodecsForEncoder,
                           SdpCodec**& commonCodecsForDecoder,
                           UtlString& rtpAddress, 
                           int& rtpPort,
                           int& rtcpPort,
                           int& videoRtpPort,
                           int& videoRtcpPort,
                           SdpSrtpParameters& localSrtpParams,
                           SdpSrtpParameters& matchingSrtpParams,
                           int localBandwidth,
                           int& matchingBandwidth,
                           int localVideoFramerate,
                           int& matchingVideoFramerate) const;
             
   ///< It is assumed that the best are matches are first in the body.

   void getCodecsInCommon(int audioPayloadIdCount,
                          int videoPayloadIdCount,
                          int audioPayloadTypes[],
                          int videoPayloadTypes[],
                          int videoRtpPort,
                          SdpCodecFactory& localRtpCodecs,
                          int& numCodecsInCommon,
                          SdpCodec* commonCodecsForEncoder[],
                          SdpCodec* commonCodecsForDecoder[]) const;

   // Find common encryption suites
   void getEncryptionInCommon(SdpSrtpParameters& audioParams,
                              SdpSrtpParameters& remoteParams,
                              SdpSrtpParameters& commonAudioParms) const;

   // Find common bandwidth
   void getBandwidthInCommon(int localBandwidth,
                             int remoteBandwidth,
                             int& commonBandwidth) const;

   // Find a common video framerate
   void getVideoFramerateInCommon(int localVideoFramerate,
                                  int remoteVideoFramerate,
                                  int& commonVideoFramerate) const;

    /**
     * Get the candidate attribute per draft-ietf-mmusic-ice-05
     */
    UtlBoolean getCandidateAttribute(int mediaIndex,
                                     int candidateIndex,
                                     int& rCandidateId,
                                     UtlString& rTransportId,
                                     UtlString& rTransportType,
                                     double& rQvalue, 
                                     UtlString& rCandidateIp, 
                                     int& rCandidatePort) const ;


   UtlBoolean getCandidateAttributes(const char* szMimeType,
                                     int         nMaxAddresses,                                     
                                     int         candidateIds[],
                                     UtlString   transportIds[],
                                     UtlString   transportTypes[],
                                     double      qvalues[], 
                                     UtlString   candidateIps[], 
                                     int         candidatePorts[],
                                     int&        nActualAddresses) const ;

   UtlBoolean getCandidateAttributes(int         mediaIndex,
                                     int         nMaxAddresses,                                     
                                     int         candidateIds[],
                                     UtlString   transportIds[],
                                     UtlString   transportTypes[],
                                     double      qvalues[], 
                                     UtlString   candidateIps[], 
                                     int         candidatePorts[],
                                     int&        nActualAddresses) const ;

   /**
     * Locates a specific value for an attribute field
     * Used to locate sendonly and recvonly in case if hold and unhold INVITE messages
     */
   UtlBoolean findValueInField(const char* pField, const char* pvalue) const;


///@}

/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:
   friend class SdpBodyTest;
   
   /**
    * @name ====================== Generic SDP field accessors
    *
    * It is better to use the more specific accessor methods above for the field type you need
    * than to use these generic interfaces.  These may be deprecated in the future.
    *
    * @{
    */

   /// Return the number of fields in the body.
   int getFieldCount() const;

   /// Return the name and value of the nth field in the body.
   UtlBoolean getValue(int fieldIndex,
                       UtlString* name,
                       UtlString* value) const;
   /**<
    * It is better to use a more specific accessor method for the field type you need
    * than to iterate over all fields using this interface.
    *
    * @return FALSE if there are not enough fields
    */

   /// Set a specific field.
   void setValue(const char* name,       ///< field name to set
                 const char* value       ///< value for the named field
                 );

///@}

   /// Parse an existing string into the internal representation.
   void parseBody(const char* bytes = NULL, ///< NULL creates an empty body             
                  int byteCount = -1        ///< -1 means treat bytes as null terminated
                  );


/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:

   /// Get the position of the first of a set of headers, checking in order.
   size_t findFirstOf( const char* headers /**< null terminated set of single-character header names */);
   /**<
    * @returns The index of the first of the headers found, or UTL_NOT_FOUND if none are present.
    *
    * Example:
    * @code
    * 
    *    size_t timeLocation = findFirstOf("zkam");
    *    addValue("t", value.data(), timeLocation);
    * 
    * @endcode
    */
   
   /// Is the named field optional according to RFC 2327? true==optional.
   bool isOptionalField(const char* name) const;

   /// Add the given name/value pair to the body at the specified position.
   void addValue(const char* name, 
                 const char* value = NULL, 
                 int fieldIndex = UTL_NOT_FOUND /**< UTL_NOT_FOUND == at the end */
                 );
   
   UtlSList* sdpFields;

   /// Position to the field instance.
   static NameValuePair* positionFieldInstance(int fieldInstanceIndex, ///< field instance of interest starting a zero
                                               UtlSListIterator* iter, /**< an iterator on sipFields. The search will
                                                                        *  start at the begining.*/
                                               const char* fieldName
                                               );
   /**<
    * Positions the given iterator to the to the nth instance of fieldName.
    * @return the field name value pair if it exists leaving the iterator positioned there.
    */

   static NameValuePair* findFieldNameBefore(UtlSListIterator* iter,
                                             const char* targetFieldName,
                                             const char* beforeFieldName);

   //! Disabled assignment operator
   SdpBody& operator=(const SdpBody& rhs);

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SdpBody_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SdpCodecFactory_h_
#define _SdpCodecFactory_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include "utl/UtlDList.h"

#include <os/OsBSem.h>
#include <os/OsRWMutex.h>

#include <sdp/SdpCodec.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//: Factory and container for all supported codec types

// Class detailed description which may extend to multiple lines
class SdpCodecFactory
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   static SdpCodecFactory* getSdpCodecFactory();
   //: Get singleton instance
   // Note: This class can be used in non-singleton mode
   // by avoiding the use of this one method.

   SdpCodecFactory(int numCodecs = 0,
                   SdpCodec* codecArray[] = NULL);
     //:Default constructor

   SdpCodecFactory(const SdpCodecFactory& rSdpCodecFactory);
     //:Copy constructor

   SdpCodecFactory& operator=(const SdpCodecFactory& rhs);
     //:Assignment operator

   virtual
   ~SdpCodecFactory();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   void addCodec(SdpCodec& newCodec);
   //: Add a new codec type to the list of known codecs

   void addCodecs(int numCodecs, SdpCodec* newCodecs[]);
   //: Add copies of the array of codecs

   void bindPayloadTypes();
   // Assign any unset payload type ids

   void copyPayloadType(SdpCodec& codec);
   //: If there is a matching codec in this factory, set its payload type to that of the given codec

   void copyPayloadTypes(int numCodecs, SdpCodec* codecArray[]);
   //: For all matching codecs, copy the payload type from the codecArray to the matching codec in this factory

   void clearCodecs(void);
   //: Discard all codecs

   int buildSdpCodecFactory(UtlString &codecList);
   //: Function just called other buildSdpCodecFactory. Here for compatibility

   int buildSdpCodecFactory(int codecCount, SdpCodec::SdpCodecTypes codecTypes[]);
   //: Add the default set of codecs specified in list; returns 0 if OK.

   void setCodecCPULimit(int iLimit);
     //:Limits the advertised codec by CPU limit level.
     //!param (in) iLimit - The limit level for codecs.  A value of 
     //       SDP_CODEC_CPU_LOW indicates only low cpu intensity codecs and
     //       a value of SDP_CODEC_CPU_HIGH indicates either low or high
     //       cpu intensity.


/* ============================ ACCESSORS ================================= */

   const SdpCodec* getCodec(SdpCodec::SdpCodecTypes internalCodecId);
   //: Get a codec given an internal codec id

   const SdpCodec* getCodecByType(int payloadTypeId);
   //: Get a codec given the payload type id

   const SdpCodec* getCodec(const char* mimeType, 
                            const char* mimeSubType);
   //: Get a codec given the mime type and subtype

   int getCodecCount();
   //: Get the number of codecs

   int getCodecCount(const char* mimeType);
   //: Get the number of codecs by mime type

   void getCodecs(int& numCodecs,
                  SdpCodec**& codecArray);

   void getCodecs(int& numCodecs,
                  SdpCodec**& codecArray,
                  const char* mimeType);

   void getCodecs(int& numCodecs, 
                  SdpCodec**& codecArray,
                  const char* mimeType,
                  const char* subMimeType);
   //: Returns a copy of all the codecs

   void toString(UtlString& serializedFactory);
   //: String representation of factory and codecs
   
   static SdpCodec::SdpCodecTypes getCodecType(const char* pCodecName);
   //: Converts the readable text codec name into an enum defined in Sdpcodec.h

   int getCodecCPULimit();
     //:Gets the codec CPU limit level

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
   void addCodecNoLock(SdpCodec& newCodec);
   //: Add a new codec type to the list of known codecs

   UtlDList mCodecs;
   OsRWMutex mReadWriteMutex;
   int mCodecCPULimit ;

   // Note: the follwing are only needed for the
   // singleton instance method getSdpCodecFactory.
   // This class can be used in non-singleton mode
   // by avoiding the use of this one method.
   static SdpCodecFactory* spInstance;
   static OsBSem       sLock;       // semaphore used to ensure that there
                                    //  is only one instance of this class

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SdpCodecFactory_h_
//
// Copyright (C) 2007 Plantronics
// Licensed to SIPfoundry under a Contributor Agreement.
// 
// Copyright (C) 2007 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// $$
///////////////////////////////////////////////////////////////////////////////
// Author: Scott Godin (sgodin AT SipSpectrum DOT com)

#ifndef _SdpHelper_h_
#define _SdpHelper_h_

#ifndef EXCLUDE_SIPX_SDP_HELPER

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <net/SdpBody.h>
#include <sdp/Sdp.h>
#include <sdp/SdpMediaLine.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//: Container for SdpHelper specification
// This class holds the information related to an SdpHelper.
// Included in this information is:  TODO
//

class SdpHelper
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

/* ============================ MANIPULATORS ============================== */
   static SdpMediaLine::SdpCryptoSuiteType convertCryptoSuiteType(int sdpBodyType);
   static Sdp* createSdpFromSdpBody(SdpBody& sdpBody);

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */


/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
};

/* ============================ INLINE METHODS ============================ */

#endif // #ifndef EXCLUDE_SIPX_SDP_HELPER

#endif  // _SdpHelper_h_

//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipClient_h_
#define _SipClient_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <os/OsSocket.h>
#include <os/OsTask.h>
#include <os/OsServerTask.h>
#include <os/OsBSem.h>
#include <net/SipMessage.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class SipUserAgentBase;
class OsEvent;

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class SipClient : public OsTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   SipClient(OsSocket* socket = NULL);
     //:Default constructor


   virtual
   ~SipClient();
     //:Destructor

/* ============================ MANIPULATORS ============================== */
        UtlBoolean send(SipMessage* message);

    UtlBoolean sendTo(const SipMessage& message,
                     const char* address,
                     int port);

        void setUserAgent(SipUserAgentBase* sipUA);
        //void addEventConsumer(OsServerTask* messageEventListener);
        //void removeEventConsumer(OsServerTask* messageEventListener);


        virtual int run(void* pArg);

        UtlBoolean sendInvite(char* toAddress, char* callId, int rtpPort,
                                                                int numCodecs, int rtpCodecs[],
                                                                int sequenceNumber = 1);

    void touch();
    //: Set the time when this client was last used
    // This is potentially used for garbage collection

    void notifyWhenAvailableForWrite(OsEvent& availableEvent);
    //: The given event is signaled when this SipClient is not busy

    void signalNextAvailableForWrite();

    void signalAllAvailableForWrite();

    void setSharedSocket(UtlBoolean bShared) ;

/* ============================ ACCESSORS ================================= */

    //void getHostIp(UtlString* hostAddress) const;
    void getClientNames(UtlString& clientNames) const;
    long getLastTouchedTime() const;
    //int getHostPort() const;
    const UtlString& getLocalIp();

    void markInUseForWrite();
    void markAvailbleForWrite();


/* ============================ INQUIRY =================================== */

    UtlBoolean isOk();

    UtlBoolean isConnectedTo(UtlString& hostName, int hostPort);

    int isInUseForWrite();

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    // Test whether the socket is ready to read.  (Does not block.)
        UtlBoolean isReadyToRead();
    // Wait until the socket is ready to read (or has an error).
    UtlBoolean waitForReadyToRead();

    OsSocket* clientSocket;
    OsSocket::IpProtocolSocketType mSocketType;
    SipUserAgentBase* sipUserAgent;
    UtlString mRemoteHostName;
    UtlString mRemoteViaAddress;
    UtlString mRemoteSocketAddress;
    UtlString mReceivedAddress;
    int mRemoteViaPort;
    int mRemoteHostPort;
    int mRemoteReceivedPort;
        long touchedTime;
    OsBSem mSocketLock;
    int mFirstResendTimeoutMs;
    int mInUseForWrite;
    UtlSList* mWaitingList;  // Events waiting until this is available
    UtlBoolean mbSharedSocket; // Shared socket-- do not delete or close (UDP / rport)

    SipClient(const SipClient& rSipClient);
     //:disable Copy constructor

    SipClient& operator=(const SipClient& rhs);
     //:disable Assignment operator

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipClient_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SipConfigServerAgent_h_
#define _SipConfigServerAgent_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <os/OsServerTask.h>
#include <net/SipMessage.h>
#include <os/OsBSem.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
typedef int (*EnrollmentCallbackFunc)(const SipMessage& subscribeRequest);
// Note this function will need to parse out the following:
//  from the From header field URL: 
//      fromUser, fromAddress, fromPort
//  from the From header field parameters (Url:getHeaderFieldParameter):
//      vender, model, version,  mac,  serial
// from the Config-Requires header field:
//      numProfiles, profiles[]
// from the Config-Allow  header field
//      numProcols, protocols[]
// from the Config-Expires header field:
//      expirationSeconds
// Note: #defines exist in SipMessage.h for these header field names:
// SIP_FROM_FIELD, SIP_TO_FIELD,
// SIP_CONFIG_ALLOW_FIELD, SIP_CONFIG_REQUIRE_FIELD

typedef void (*NotifyResponseCallbackFunc)(const SipMessage& notifyResponse);
// Note: this function will need to parse out the
// following data from the SipMessage:
// from the header response status code: notifyChangeResponseCode
// from the header response status text: notifyChangeResponseText


// FORWARD DECLARATIONS
class SipUserAgent;
class OsConfigDb;


//:This class is the SIP configuation agent for the deployment serve
// From the SIP messaging perspective there are two types of messages
// related to configuration: 
// 1) Enrollment from the SIP UA/device to the server in the form of SUBSCRIBE
// 2) Configuration change notification from the config server to the device
//    in the form of a NOTIFY request
// <BR>
// The following message flow illustrates the communications
// between this object, the config. server and the managed
// SIP UA device.
//
// config.          SipConfigServerAgent       UA device              
// server
//                        <------------------SUBSCRIBE (enrollment)
//   <--------------EnrollmentCallbackFunc
//   return code --------->
//                  SUBSCRIBE response ---------->
// ...
// sendChangeNotification->
//                  NOTIFY (config change) ------>
//                        <------------------NOTIFY response
//   <--------------NotifyResponseCallbackFunc
//
// <BR>
// Enrollment is initiated by the device sending the SUBSCRIBE to the config
// server.  When the SipConfigServerAgent receives the SUBSCRIBE it calls
// the callback: EnrollmentCallbackFunc to provide the entollement data
// to the config. server.  The config. server must return the response
// code to be used for the SUBSCRIBE response.  Typically this will
// be: 202 Acepted for success, 400 Bad Request, etc. see SipMessage.h
// Included is a subscribe context that is needed if the config. server
// is to send change notifications.
// <BR>
// Later when the config. server wishes to send the config profile
// URLs, it calls the sendChangeNotification method.  This method
// returns a boolean indicating whether the NOTIFY was sent or
// not.  This does not indicate the request was received or not
// by the SIP UA device.  The final outcome is indicated to the
// config. server via the callaback: NotifyResponseCallbackFunc
// Note: I have not come up with a convenient means of matching
// the invocations of this call back with the sendChangeNotification
// invocation (i.e. same transaction).  So for now I won't implement
// this callback.

class SipConfigServerAgent : public OsServerTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   SipConfigServerAgent(SipUserAgent* userAgent);
     //:Default constructor

   virtual
   ~SipConfigServerAgent();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   virtual UtlBoolean handleMessage(OsMsg& eventMessage);

   UtlBoolean sendChangeNotification(SipMessage& notifyRequest);
   //: Sends an config. change notification (NOTIFY) to the SIP UA device indicated in subscriberContext
   //! param: subscribeContext - text serialization of the enrollment SUBSCRIBE
   //! param: notifyCSeqence - the Csequence number for the NOTIFY request.  This can be random for the very first NOTIFY sent to a UA and should be incremented by one for each NOTIFY afterwards.
   //! param: configLicenseSeconds - the period of time after which the UA should consider the configuration to be stale.
   //! param: notifyBody - the contents for the NOTIFY request body.  zero or more lines of the format: <profile-name>: Sequence=<serial-config-id>;Url=<profile-config-url>

   // Note the application is responsible for keeping a copy of the
   // original request as it will need to copy and reverse the
   // To & From fields..  It should construct the proper route
   // field if there was a record-route field in the subscribe
   // request.  Each notify request should have an incremented
   // CSeq header field.  The NOTIFY body should contain the
   // profile urls and sequence numbers.

   // Note: we need a asychronous meand of letting the
   // caller of this method know that the message failed to send.

/* ============================ ACCESSORS ================================= */

   void setEnrollmentCallback(EnrollmentCallbackFunc callback);
   //: Sets the function which gets called when an enrollment SUBSCRIBE comes in

   void setChangeNotifyStatusCallback(NotifyResponseCallbackFunc callback);
   //: Sets the function which gets called when a response is received for a change notification

   static SipConfigServerAgent* getSipConfigServerAgent();
    //: Returns a singleton reference to the Sip Config Server Agent

   SipUserAgent* getSipUserAgent();
    //: Returns a reference to the Sip User Agent

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    static SipConfigServerAgent* startAgents(const char* configFileName) ;
    //: Starts up the SipUserAgent and the SipConfigServerAgent

    SipConfigServerAgent(const SipConfigServerAgent& rSipConfigServerAgent);
    //:Copy constructor diabled

    SipConfigServerAgent& operator=(const SipConfigServerAgent& rhs);
    //:Assignment operator diabled

    static SipConfigServerAgent* spInstance ;
    //: Singleton instance to ourself
    static OsBSem sLock;
    //: Semaphore guarding start up
    SipUserAgent* mpSipUserAgent;
    //: Reference to the Sip User Agent
    EnrollmentCallbackFunc mfpEnrollmentCallbackFunc;
    NotifyResponseCallbackFunc mfpNotifyResponseCallbackFunc;

    void static initializeLog(OsConfigDb* pConfigDb) ;
      //: Initialize the OsSysLog 

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipConfigServerAgent_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipContactDb_h_
#define _SipContactDb_h_

// SYSTEM INCLUDES
//#include <...>
#include <utl/UtlString.h>
#include <utl/UtlHashMap.h>
#include <os/OsMutex.h>
#include <os/OsSocket.h>
#include "tapi/sipXtapi.h"

// APPLICATION INCLUDES
// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS



// FORWARD DECLARATIONS

class SipContactDb
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */
    SipContactDb();

    virtual
    ~SipContactDb();

    /**
     * Inserts a contact into the contact table.  Fails if there is
     * already an entry with the same port and IP address.
     * If the ID of the incoming CONTACT_ADDRESS is less that 1,
     * which it should be, then this method will assign
     * a contact id.
     * @param contact Reference to a contact structure, which will be
     *        copied, and the copy will be added to the DB.
     */   
    const bool addContact(SIPX_CONTACT_ADDRESS& contact);


    /**
     * Searches for a similar contact and the datebase and updates the
     * address/port.
     * 
     * @param contact Reference to a contact structure
     */   
    const bool updateContact(SIPX_CONTACT_ADDRESS& contact);

    /**
     * Removes a contact record from the DB.  
     *
     * @param id Key value (the contact id) used to find
     *        a matching record for deletion.
     */
    const UtlBoolean deleteContact(const SIPX_CONTACT_ID id);
    
    /** 
     * Finds a contact in the DB, by SIPX_CONTACT_ID.
     *
     * @param id The SIPX_CONTACT_ID of the record to find.
     */
    SIPX_CONTACT_ADDRESS* find(SIPX_CONTACT_ID id);

    /** 
     * Finds a contact in the DB, by IP address.
     *
     * @param id The IP Address of the record to find.
     */    
	SIPX_CONTACT_ADDRESS* find(const UtlString szIpAddress, const int port, SIPX_CONTACT_TYPE type);

    /**
     * Finds the first contact by a given contact type
     */
    SIPX_CONTACT_ADDRESS* findByType(SIPX_CONTACT_TYPE type, SIPX_TRANSPORT_TYPE transportType, UtlString sCustomTransport = "") ;

    /**
     * Return a transport type given the specified transport name.  The name 
     * could be tls, tcp, udp, or a custom transport type.
     */
    SIPX_TRANSPORT_TYPE findTransportType(const char* transportName) ;

    /*
     * Find the local contact from a contact id.
     */
    SIPX_CONTACT_ADDRESS* getLocalContact(SIPX_CONTACT_ID id) ;
    
    /**
     * Populates a CONTACT_ADDRESS array with all of the contacts
     * stored in this DB.
     *
     * @param contacts Pre-allocated array of CONTACT_ADDRESS pointers.
              Should be allocated using the MAX_IP_ADDRESSES for the size.
     * @param actualNum The number of contacts.
     */
    void getAll(SIPX_CONTACT_ADDRESS* contacts[], int& actualNum) const;
    
    
    /**
     * Populates a CONTACT_ADDRESS array with all of the contacts
     * stored in this DB that match a particular adapter name.
     *
     * @param contacts Pre-allocated array of CONTACT_ADDRESS pointers.
              Should be allocated using the MAX_IP_ADDRESSES for the size.
     * @param szAdapter Adapter name for which to look-up contacts.
     * @param actualNum The number of contacts.
     */
    void getAllForAdapter(const SIPX_CONTACT_ADDRESS* contacts[],
                          const char* szAdapter,
                          int& actualNum,
                          SIPX_CONTACT_TYPE typeFilter = CONTACT_ALL) const;
                                    
    const bool getRecordForAdapter(SIPX_CONTACT_ADDRESS& contact,
                                   const char* szAdapter,
                                   const SIPX_CONTACT_TYPE contactFilter) const;

    const bool getRecordForAdapter(SIPX_CONTACT_ADDRESS& contact,
                                   const char* szAdapter,
                                   const SIPX_CONTACT_TYPE contactFilter,
                                   const SIPX_TRANSPORT_TYPE transportFilter) const;

    
    void replicateForTransport(const SIPX_TRANSPORT_TYPE originalTransport, 
                               const SIPX_TRANSPORT_TYPE newTransport,
                               const char* szTransport,
                               const char* szRoutingID);

    void removeForTransport(const SIPX_TRANSPORT_TYPE transport);

    void dump(UtlString& output) ;

/* ============================ MANIPULATORS ============================== */

    void enableTurn(bool bEnable) ;


/* ============================ ACCESSORS ================================= */


/* ============================ INQUIRY =================================== */


/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:



/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    /** Disabled copy constructor */
    SipContactDb(const SipContactDb& rSipContactDb);

    //** Disabled assignment operator */
    SipContactDb& operator=(const SipContactDb& rhs);
    
    /** Checks this database for a duplicate record by key */
    const bool isDuplicate(const SIPX_CONTACT_ID id);
    
    /** Checks this database for a duplicate record by ipAddress and port */
    const bool isDuplicate(const UtlString& ipAddress, const int port, SIPX_CONTACT_TYPE type, SIPX_TRANSPORT_TYPE transportType);

    /**
     * Given a contact record containing an ID which is set
     * to a value less than 1, this method will generate a contact 
     * ID.
     * 
     * @param contact Reference to the CONTACT_ADDRESS object to be
     *        modified.
     */
    const bool assignContactId(SIPX_CONTACT_ADDRESS& contact);

    /** hash map storage for contact information, keyed by Contact Record ID */
    UtlHashMap mContacts;   

    int mNextContactId;
    
    mutable OsMutex mLock;

    bool mbTurnEnabled ;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipContactDb_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////
// Author: Dan Petrie (dpetrie AT SIPez DOT com)

#ifndef _SipDialog_h_
#define _SipDialog_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES

#include <os/OsDefs.h>
#include <utl/UtlHashMap.h>
#include <net/Url.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
#define DIALOG_HANDLE_SEPARATOR ','

// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class SipMessage;

//! Class for containing SIP dialog state information
/*! In SIP a dialog is defined by the SIP Call-Id
 *  header and the tag parameter from the SIP To
 *  and From header fields.  An early dialog has
 *  has only the tag set on one side, the transaction
 *  originator side.  In the initial transaction the
 *  the originator tag in in the From header field.
 *  The final destination sets the To header field
 *  tag in the initial transaction.
 *
 * \par Local and Remote
 *  As the To and From fields get swapped depending
 *  upon which side initiates a transaction (i.e.
 *  sends a request) local and remote are used in
 *  SipDialog to label tags, fields and information.
 *  Local and Remote are unabiquous when used in
 *  an end point.  In a proxy context the SipDialog
 *  can still be used.  One can visualize the
 *  sides of the dialog by thinking Left and Right
 *  instead of local and remote.
 *
 *  This class is intended to depricate the SipSession
 *  class.
 */
class SipDialog : public UtlString
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    enum DialogState
    {
        DIALOG_UNKNOWN,
        DIALOG_EARLY,
        DIALOG_ESTABLISHED,
        DIALOG_FAILED,
        DIALOG_TERMINATED
    };

/* ============================ CREATORS ================================== */

    //! Default Dialog constructor
    /*! Optionally construct a dialog from the given message
     *
     * \param initialMessage - message to initiate the dialog, typically this
     *        is a request.
     * \param isFromLocal - The message was sent from this side of the transaction.
     *        When the SipDialog is used in a proxy context, local and remote
     *        is not obvious.  A way to think about it in a proxy scenario is
     *        to think of local to be the left side and remote to be the right
     *        side of the transaction.
     */
    SipDialog(const SipMessage* initialMessage = NULL,
              UtlBoolean isFromLocal = TRUE);

    //! Constructor accepting the basic pieces of a session callId, toUrl, and from Url.
    /*! Optionally construct a dialog from the given message
     *
     * \param callId - sip message call-id header value
     * \param localField - sip message To or From field value representing the 
     *        local side of the dialog.
     * \param remoteField - sip message To or From field value representing the 
     *        remote side of the dialog.
     */
    SipDialog(const char* callId, const char* localField, const char* remoteField); 

    //! Destructor
    virtual
    ~SipDialog();


/* ============================ MANIPULATORS ============================== */

    //! update the dialog information based upon the given message
    /*! Typically this updates things like the Contact, CSeq headers and 
     *  tag information for the dialog.
     *  \param message - SIP message which is assumed to be part of this
     *         dialog.
     */
    void updateDialogData(const SipMessage& message);

    //! Set fields in next SIP request for this dialog
    /*! Set the request URI, call-id, To, From, Route and Cseq headers
     *  fields for the given request to be sent in the given dialog.  The
     *  last local cseq of the dialog is incremented and set in the request.
     *  \param method - the sip request method for this request.
     *  \param request - the request which is to be part of this dialog
     *         and sent as orginating from the local side of the dialog.
     */
    void setRequestData(SipMessage& request, const char* method);

/* ============================ ACCESSORS ================================= */


    //! Gets a string handle that can be used to uniquely identify this dialog
    void getHandle(UtlString& dialogHandle) const;

    //! Get the early dialog handle for this dialog
    void getEarlyHandle(UtlString& earlyDialogHandle) const;

    //! Gets the call-id, and tags from the dialogHandle
    static void parseHandle(const char* dialogHandle,
                            UtlString& callId,
                            UtlString& localTag,
                            UtlString& remoteTag);

    //! Reverse the order of the tags in the handle
    static void reverseTags(const char* dialogHandle,
                            UtlString& reversedHandle);

    //! Get the SIP call-id header value for this dialog
    void getCallId(UtlString& callId) const;
    //! Set the SIP call-id header value for this dialog
    void setCallId(const char* callId);

    //! Get the SIP To/From header value for the local side of this dialog
    void getLocalField(Url& localUrl) const;
    //! Get the tag from the SIP To/From header value for the local side of this dialog
    void getLocalTag(UtlString& localTag) const;
    //! Set the SIP To/From header value for the local side of this dialog
    void setLocalField(const Url& localUrl);

    //! Get the SIP To/From header value for the remote side of this dialog
    void getRemoteField(Url& remoteUrl) const;
    //! Get the tag from the SIP To/From header value for the remote side of this dialog
    void getRemoteTag(UtlString& remoteTag) const;
    //! Set the SIP To/From header value for the remote side of this dialog
    void setRemoteField(const Url& remoteUrl);

    //! Get the SIP Contact header value for the remote side of this dialog
    void getRemoteContact(Url& remoteContact) const;
    //! Set the SIP Contact header value for the remote side of this dialog
    void setRemoteContact(const Url& remoteContact);

    //! Get the SIP Contact header value for the local side of this dialog
    void getLocalContact(Url& localContact) const;
    //! Get the SIP Contact header value for the remote side of this dialog
    void setLocalContact(const Url& localContact);

    //! Get the SIP method of the request that initiated this dialog
    void getInitialMethod(UtlString& method) const;
    //! Set the SIP method of the request that initiated this dialog
    void setInitialMethod(const char* method);

    //! Get the next (incremented) SIP Cseq number for the local side
    int getNextLocalCseq();
    //! Get the last used SIP Cseq number for the local side
    int getLastLocalCseq() const;
    //! Set the last used SIP Cseq number for the local side
    void setLastLocalCseq(int seqNum);

    //! Get the last used SIP Cseq number for the remote side
    int getLastRemoteCseq() const;
    //! Set the last used SIP Cseq number for the remote side
    void setLastRemoteCseq(int seqNum);

    //! Get the request URI for the local side
    /*! This may be different than the local contact.  This is
     *  what was received in the last request from the remote 
     *  side.
     */
    void getLocalRequestUri(UtlString& requestUri) const;
    //! Set the request URI for the local side
    void setLocalRequestUri(const UtlString& requestUri);
    //! Get the request URI for the remote side
    /*! This is typically meaningless for the remote side
     *  when observed from the local end point as it should
     *  not be different than the local contact.  However 
     *  in some applications it may be possible to observe
     *  what the request URI is on the remote side or in
     *  a proxy in which case this may be interesting.
     */
    void getRemoteRequestUri(UtlString& requestUri) const;
    //! Set the request URI for the remote side
    void setRemoteRequestUri(const UtlString& requestUri);

    //int getDialogState() const;

    //! Debug method to dump the contents of this SipDialog into a string
    void toString(UtlString& dialogDumpString);

    //! Get a string representation for the state value
    static void getStateString(DialogState state, 
                               UtlString& stateString);

/* ============================ INQUIRY =================================== */

    //! Compare the message to see if it matches this dialog
    /*! A dialog matches if the SIP Call-Id header and
     *  the tags from the SIP message To and From field
     *  match those of this dialog.  The tags are compared in
     * both directions.
     */
    UtlBoolean isSameDialog(const SipMessage& message) const;

    //! Compare the given dialog indentifiers match those of this dialog
    /*! The tags are compared in both directions.
     */
    UtlBoolean isSameDialog(const UtlString& callId,
                            const UtlString& localTag,
                            const UtlString& remoteTag) const;

    //! Compare the given dialog handle with that of this dialog
    /*! The tags are compared in both directions.
     */
    UtlBoolean isSameDialog(const char* dialogHandle);

    //! Determine if this is an early dialog
    UtlBoolean isEarlyDialog() const;

    //! Determine if the given handle is for an early dialog
    /*! That is check if one of the tags is null
     */
    static UtlBoolean isEarlyDialog(const char* dialogHandle);

    //! Checks if this is an early dialog for the given SIP message
    UtlBoolean isEarlyDialogFor(const SipMessage& message) const;

    //! Checks if this is an early dialog for the given SIP message
    UtlBoolean isEarlyDialogFor(const UtlString& callId,
                                const UtlString& localTag,
                                const UtlString& remoteTag) const;

    //! Checks if this was an early dialog for the given SIP message
    /*! This dialog is considered to have been an early dialog if
     *  the SIP Call-Id and one of the given tags matches one of
     *  the tags of this dialog.
     */
    UtlBoolean wasEarlyDialogFor(const UtlString& callId,
                                 const UtlString& localTag,
                                 const UtlString& remoteTag) const;

    //! Query if the transaction request was sent from the local side
    /*! If the request was sent from the local side, the fromTag will
     *  match the local tag.
     */
    UtlBoolean isTransactionLocallyInitiated(const UtlString& callId,
                                             const UtlString& fromTag,
                                             const UtlString& toTag) const;

    //! Query if the transaction request was sent from the remote side
    /*! If the request was sent from the local side, the fromTag will
     *  match the remote tag.
     */
    UtlBoolean isTransactionRemotelyInitiated(const UtlString& callId,
                                              const UtlString& fromTag,
                                              const UtlString& toTag) const;

    //! Check if message and SIP local Cseq match
    UtlBoolean isSameLocalCseq(const SipMessage& message) const;

    //! Check if message and SIP remote Cseq match
    UtlBoolean isSameRemoteCseq(const SipMessage& message) const;

    //! Check if mesage cseq is after the last local transaction
    UtlBoolean isNextLocalCseq(const SipMessage& message) const;

    //! Check if mesage cseq is after the last remote transaction
    UtlBoolean isNextRemoteCseq(const SipMessage& message) const;

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    //! Copy constructor
    SipDialog(const SipDialog& rSipDialog);

    //! Assignment operator
    SipDialog& operator=(const SipDialog& rhs);

    // The callId is stored in the UtlString base class data element
    Url mLocalField; // To or From depending on who initiated the transaction
    Url mRemoteField; // To or From depending on who initiated the transaction
    UtlString mLocalTag;
    UtlString mRemoteTag;
    Url mLocalContact;
    Url mRemoteContact;
    UtlString mRouteSet;
    UtlString mInitialMethod;
    UtlString msLocalRequestUri;
    UtlString msRemoteRequestUri;
    UtlBoolean mLocalInitatedDialog;
    int mInitialLocalCseq;
    int mInitialRemoteCseq;
    int mLastLocalCseq;
    int mLastRemoteCseq;
    int mDialogState;

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipDialog_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SipDialogEvent_h_
#define _SipDialogEvent_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include <utl/UtlSList.h>
#include <utl/UtlSListIterator.h>
#include <net/HttpBody.h>
#include <net/Url.h>
#include <os/OsDateTime.h>
#include <os/OsBSem.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS


#define DIALOG_EVENT_TYPE "dialog"

#define BEGIN_DIALOG_INFO "<dialog-info xmlns=\"urn:ietf:params:xml:ns:dialog-info\""
#define END_DIALOG_INFO "</dialog-info>\n"

#define VERSION_EQUAL " version="
#define STATE_EQUAL " state="
#define ENTITY_EQUAL " entity="

#define DOUBLE_QUOTE "\""
#define END_BRACKET ">"
#define END_LINE ">\n"

#define BEGIN_DIALOG "<dialog id="
#define CALL_ID_EQUAL " call-id="
#define LOCAL_TAG_EQUAL " local-tag="
#define REMOTE_TAG_EQUAL " remote-tag="
#define DIRECTION_EQUAL " direction="
#define END_DIALOG "</dialog>\n"

#define BEGIN_STATE "<state"
#define EVENT_EQUAL " event="
#define CODE_EQUAL " code="
#define END_STATE "</state>\n"

#define BEGIN_DURATION "<duration>"
#define END_DURATION "</duration>\n"

#define BEGIN_LOCAL "<local>\n"
#define END_LOCAL "</local>\n"

#define BEGIN_REMOTE "<remote>\n"
#define END_REMOTE "</remote>\n"

#define BEGIN_IDENTITY "<identity"
#define DISPLAY_EQUAL " display="
#define END_IDENTITY "</identity>\n"

#define BEGIN_TARTGET "<target uri=\""
#define END_TARGET "\"/>\n"


#define STATE_TRYING "trying"
#define STATE_PROCEEDING "proceeding"
#define STATE_EARLY "early"
#define STATE_CONFIRMED "confirmed"
#define STATE_TERMINATED "terminated"

// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//! Container for dialog element in the dialog event package
/**
 * This class contains all the contents presented in a dialog element of the
 * dialog event package described in draft-ietf-sipping-dialog-package-06.txt
 * (An INVITE Initiated Dialog Event Package for SIP). This class has the
 * methods to construct and manipulate the dialog and its sub-elements.
 */

class Dialog : public UtlContainable
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

/** 
 * @name ====================== Constructors and Destructors
 * @{
 */
   /// Constructor
   Dialog(const char* dialogId,
          const char* callId, 
          const char* localTag, 
          const char* remoteTag, 
          const char* direction);

   /// Destructor
   ~Dialog();

   virtual UtlContainableType getContainableType() const;

   static const UtlContainableType TYPE;

   virtual unsigned int hash() const;

   int compareTo(const UtlContainable *b) const;

///@}
   
/**
 * @name ====================== Dialog Setting Interfaces
 *
 * These methods set/get the dialog element and sub-elements.
 *
 * @{
 */

   void getDialog(UtlString& dialogId,
                  UtlString& callId, 
                  UtlString& localTag, 
                  UtlString& remoteTag, 
                  UtlString& direction) const;
                  
   void getCallId(UtlString& callId) const;

   void setDialogId(const char* dialogId);

   void getDialogId(UtlString& dialogId) const;

   void setState(const char* state, const char* event, const char* code);

   void setTags(const char* local, const char* remote);

   void getState(UtlString& state, UtlString& event, UtlString& code) const;

   void setDuration(const unsigned long duration);

   unsigned long getDuration() const;

   void setReplaces(const char* callId,
                    const char* localTag,
                    const char* remoteTag);

   void getReplaces(UtlString& callId,
                    UtlString& localTag,
                    UtlString& remoteTag) const;

   void setReferredBy(const char* url,
                      const char* display);

   void getReferredBy(UtlString& url,
                      UtlString& display) const;

   void setLocalIdentity(const char* identity,
                         const char* display);

   void getLocalIdentity(UtlString& identity,
                         UtlString& display) const;

   void setRemoteIdentity(const char* identity,
                          const char* display);

   void getRemoteIdentity(UtlString& identity,
                          UtlString& display) const;

   void setLocalTarget(const char* url);

   void getLocalTarget(UtlString& url) const;

   void setRemoteTarget(const char* url);

   void getRemoteTarget(UtlString& url) const;

///@}
   
/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:

   // Set the unique identifier member by concatenating the call-id,
   // to-tag, and from-tag.
   void setIdentifier();

/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:

   // Variables for dialog element
   UtlString mId;
   UtlString mCallId;
   UtlString mLocalTag;
   UtlString mRemoteTag;
   UtlString mDirection;
   // Unique identifier of the dialog
   UtlString mIdentifier;

   // Variables for state element
   UtlString mState;
   UtlString mEvent;
   UtlString mCode;

   // Variables for duration element
   long mDuration;

   // Variables for replaces element
   UtlString mNewCallId;
   UtlString mNewLocalTag;
   UtlString mNewRemoteTag;

   // Variables for referred-by element
   UtlString mReferredBy;
   UtlString mDisplay;

   // Variables for local element
   UtlString mLocalIdentity;
   UtlString mLocalDisplay;
   UtlString mLocalTarget;
   UtlString mLocalSessionDescription;

   // Variables for remote element
   UtlString mRemoteIdentity;
   UtlString mRemoteDisplay;
   UtlString mRemoteTarget;
   UtlString mRemoteSessionDescription;

   // Disabled copy constructor
   Dialog(const Dialog& rDialog);

   // Disabled assignment operator
   Dialog& operator=(const Dialog& rhs);
};


//! Container for MIME type application/dialog-info+xml.
/**
 * This class contains all the contents presented in a dialog event package
 * described in draft-ietf-sipping-dialog-package-06.txt (An INVITE Initiated
 * Dialog Event Package for SIP). This class has the methods to construct and
 * manipulate the dialog events in a dialog event package.
 */
class SipDialogEvent : public HttpBody
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

/** 
 * @name ====================== Constructors and Destructors
 * @{
 */
   //! Construct an empty body of a dialog event package
   SipDialogEvent(const char* state,
                  const char* entity);

   //! Construct from an existing dialog event package in XML format
   SipDialogEvent(const char* bodyBytes);

   //! Destructor that will free up the memory allocated for dialog contents if it is not being deleted
   virtual
      ~SipDialogEvent();

///@}
   
/**
 * @name ====================== Dialog Event Serialization Interfaces
 *
 * @{
 */

   //! Build the body of this object
   void buildBody() const;

   //! Get the string length of this object
   virtual int getLength() const;

   //! Get the serialized char representation of this dialog event.
   /*! \param bytes - pointer to the body text of the dialog event will
    *       be placed here.
    *  \param length - the number of bytes written (not including the
    *       null terminator).
    */
   virtual void getBytes(const char** bytes,
                         int* length) const;

   //! Get the serialized string representation of this dialog event.
   /*! \param bytes - UtlString into which the body text will be copied.
    *  \param length - the number of bytes written (not including the
    *       null terminator).
    */
   virtual void getBytes(UtlString* bytes,
                         int* length) const;
   // Import HttpBody's getBytes methods, except as overridden here.
   using HttpBody::getBytes;

   void setEntity(const char* entity);

   void getEntity(UtlString& entity) const;

   void setState(const char* state);

   void getState(UtlString& state) const;

///@}

/**
 * @name ====================== Dialog Setting Interfaces
 *
 * These methods set/get the dialog element.
 *
 * @{
 */

   //! Insert a Dialog object
   void insertDialog(Dialog* dialog);

   //! Get the Dialog object from the hash table based on the callId
   //and tags.  If the mRemoteTag of a Dialog object in the hash table
   //is empty, then testing for match is only done on callId and
   //localTag.  Otherwise, all three fields are used.
   Dialog* getDialog(UtlString& callId,
                     UtlString& localTag,
                     UtlString& remoteTag);

   //! In the case where a empty SipDialog object is retrieved from the
   //DialogEventPublisher in handling a DISCONNECTED or FAILED message
   //the publisher still needs to find the dialog, even if it is just 
   //by the callId. Work-around for XCL-98.
   Dialog* getDialogByCallId(UtlString& callId);
   
   //! Remove a Dialog object
   Dialog* removeDialog(Dialog* dialog);
   
   //! Check whether there is are any dialogs or not
   UtlBoolean isEmpty();

   //! Return an iterator that will retrieve all dialogs in the event.
   // This iterator is only valid as long as the SipDialogEvent is not
   // modified, and must be deleted by the caller before the SipDialogEvent
   // is deleted.
   UtlSListIterator* getDialogIterator();

///@}
   
/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:
   
   /// Parse an existing dialog event package from xml format into the internal representation.
   void parseBody(const char* bytes);


/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:

   //! Variables for dialog-info
   int mVersion;
   UtlString mDialogState;
   UtlString mEntity;

   //! Variables for dialog element
   UtlSList mDialogs;

    //! reader/writer lock for synchronization
    OsBSem mLock;

   //! Disabled copy constructor
   SipDialogEvent(const SipDialogEvent& rSipDialogEvent);

   //! Disabled assignment operator
   SipDialogEvent& operator=(const SipDialogEvent& rhs);

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipDialogEvent_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////
// Author: Dan Petrie (dpetrie AT SIPez DOT com)

#ifndef _SipDialogMgr_h_
#define _SipDialogMgr_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES

#include <os/OsDefs.h>
#include <os/OsMutex.h>
#include <utl/UtlString.h>
#include <utl/UtlHashBag.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// FORWARD DECLARATIONS
class SipMessage;
class SipDialog;

// TYPEDEFS

//! Class for refreshing SIP subscriptions and registrations
/*! This is currently verified for SUBSCRIPTIONS ONLY.
 *  This class is intended to replace the SipRefreshMgr.
 *
 * \par 
 */
class SipDialogMgr
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

    //! Default Dialog constructor
    SipDialogMgr();


    //! Destructor
    virtual
    ~SipDialogMgr();


/* ============================ MANIPULATORS ============================== */

    //! Create a new dialog for the given SIP message
    UtlBoolean createDialog(const SipMessage& message, 
                            UtlBoolean messageIsFromLocalSide,
                            const char* dialogHandle = NULL);

    //! Update the dialog information for the given message
    /*! If a dialog matches this message update the dialog information
     *  otherwise if this message is part of an established dialog and 
     *  matches an early dialog change the dialog to established and 
     *  update the dialog information.
     */
    UtlBoolean updateDialog(const SipMessage& message, 
                            const char* dialogHandle = NULL);

    //! Delete the dialog for the given dialog handle
    UtlBoolean deleteDialog(const char* dialogHandle);


    //! Get the dialog related fields and set them in the given request
    /*! Increments the dialogs local Cseq as well.
     */
    UtlBoolean setNextLocalTransactionInfo(SipMessage& request,
                                           const char* method = NULL,
                                           const char* dialogHandle = NULL);

    /* ============================ ACCESSORS ================================= */

    //! Get the early dialog handle for the given established dialog handle
    /*! This works even if the SipDialog is an early dialog that has not yet 
     *  been updated to be an established dialog. */
    UtlBoolean getEarlyDialogHandleFor(const char* establishedDialogHandle, 
                                       UtlString& earlyDialogHandle);

    //! Get the established dialog for the given early dialog
    UtlBoolean getEstablishedDialogHandleFor(const char* earlyDialogHandle,
                                             UtlString& establishedDialogHandle);

    //! Get a count of the SipDialogs
    int countDialogs() const;

    //! Get dump string of dialogs
    int toString(UtlString& dumpString);

/* ============================ INQUIRY =================================== */

    //! Is there an early dialog that matches this early dialogHandle
    /*! If earlyDialogHandle is not an early dialog, no matches are
     * considered to exist.
     */
    UtlBoolean earlyDialogExists(const char* earlyDialogHandle);

    //! Is there an early dialog that matches this established dialogHandle
    /*! If establishedDialogHandle is not an established dialog, no matches are
     * considered to exist.
     */
    UtlBoolean earlyDialogExistsFor(const char* establishedDialogHandle);

    //! Is there a dialog that matches this dialogHandle
    /*! If the dialog handle is an early dialog, it will only match
     *  early dialogs.  If the dialog handle is an established dialog
     *  it will only match established dialogs.
     */
    UtlBoolean dialogExists(const char* dialogHandle);

    //! Checks to see if the given message matches the last local transaction
    UtlBoolean isLastLocalTransaction(const SipMessage& message, 
                                      const char* dialogHandle = NULL);

    //! Check if the message is part of a new remote transaction
    /*! The cseq of the message is greater than the last known cseq
     *  of the remote side of the dialog
     */
    UtlBoolean isNewRemoteTransaction(const SipMessage& sipMessage);

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    //! Copy constructor NOT ALLOWED
    SipDialogMgr(const SipDialogMgr& rSipDialogMgr);

    //! Assignment operator NOT ALLOWED
    SipDialogMgr& operator=(const SipDialogMgr& rhs);

    //! Find a dialog that matches, optionally look for an early dialog if exact match does not exist
    /*! Checks tags in both directions
     */
    SipDialog* findDialog(UtlString& dialogHandle,
                          UtlBoolean ifHandleEstablishedFindEarlyDialog,
                          UtlBoolean ifHandleEarlyFindEstablishedDialog);

    //! Find a dialog that matches, optionally look for an early dialog if exact match does not exist
    /*! Checks tags in both directions
     */
    SipDialog* findDialog(UtlString& callId,
                          UtlString& localTag,
                          UtlString& remoteTag,
                          UtlBoolean ifHandleEstablishedFindEarlyDialog,
                          UtlBoolean ifHandleEarlyFindEstablishedDialog);

    //! lock for single thread use
    void lock();

    //! unlock for use
    void unlock();

    OsMutex mDialogMgrMutex;
    UtlHashBag mDialogs; 
};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipDialogMgr_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SIPDIALOGMONITOR_H_
#define _SIPDIALOGMONITOR_H_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <os/OsBSem.h>
#include <net/StateChangeNotifier.h>
#include <net/SipUserAgent.h>
#include <net/SipDialogMgr.h>
#include <net/SipSubscriptionMgr.h>
#include <net/SipSubscribeServerEventHandler.h>
#include <net/SipSubscribeServer.h>
#include <net/SipRefreshManager.h>
#include <net/SipSubscribeClient.h>
#include <net/SipPublishContentMgr.h>
#include <net/SipDialogEvent.h>
#include <utl/UtlSList.h>
#include <utl/UtlHashMap.h>

// DEFINES
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * A SipDialogMonitor object monitors the on/off hook status of all the SIP user
 * agents for a set of URIs by subscribing to dialog events for the URIs and
 * processing the resulting dialog events.
 *
 * The URI is considered to be off-hook if there are any active
 * dialogs (dialogs with state != 'terminated') on any of the UAs that send
 * NOTIFYs in response to a SUBSCRIBE to the URI.
 *
 * When status is updated, the information will be reported to all the
 * notifiers that have been registered using addStateChangeNotifier.
 *
 * Also, if toBePublished (mToBePublished) is set, the dialog status of
 * any groups of URIs containing the URI that has changed will be published
 * to any subscribers via a SipPublishContentMgr.
 * (This is not completely implemented.)
 */

class SipDialogMonitor
{
  public:

   SipDialogMonitor(SipUserAgent* userAgent, /**<
                                               * Sip user agent for sending out
                                               * SUBSCRIBEs and receiving NOTIFYs
                                               */
                    UtlString& domainName,   ///< sipX domain name
                    int hostPort,            ///< Host port
                    int refreshTimeout,      ///< refresh timeout for SUBSCRIBEs
                    bool toBePublished);     ///< option to publish for other subscriptions

   virtual ~SipDialogMonitor();

   /** URIs are added and deleted from groups, which are identified by
    *  names.  Each group has independent membership, and they may
    * overlap (which results in multiple subscriptions to that URI).
    * Groups are not evident in the events presented to notifiers
    * (except that a URI in multiple groups will be reported to a
    * notifier multiply), but they are central to published status, as
    * the groups are the "resource lists" which this object will be a
    * subscription server for.
    *
    * Note:  Groups should not overlap, as mDialogHandleList is indexed
    * by AOR only, and not group-and-AOR.
    */

   /// Add a URI to a group to be monitored
   // Return true if successful, false if not.
   bool addExtension(UtlString& groupName, Url& contactUrl);

   /// Remove a URI from a group to be monitored
   // Note:  Only removes the URI from the group specified.
   // Return true if successful, false if not.
   bool removeExtension(UtlString& groupName, Url& contactUrl);
  
   /// Register a StateChangeNotifier
   // notifier() will be called for every change in status of any URI that
   // has been added with addExtension().
   // Only one notifier is allowed per listUri.
   void addStateChangeNotifier(const char* listUri,
                               StateChangeNotifier* notifier);

   /// Unregister a StateChangeNotifier
   void removeStateChangeNotifier(const char* listUri);

  protected:
   friend class SipDialogMonitorTest;

   /// Add 'dialogEvent' as the last dialog event for AOR 'contact'.
   void addDialogEvent(UtlString& contact,
                       SipDialogEvent* dialogEvent,
                       const char* earlyDialogHandle,
                       const char* dialogHandle);

   /// Publish the dialog event package to the resource list
   void publishContent(UtlString& contact, SipDialogEvent* dialogEvent);

   /// Send the state change to the notifier
   void notifyStateChange(UtlString& contact, StateChangeNotifier::Status);

   /// Callback to handle notification of changes in the states of subscriptions.
   static void subscriptionStateCallback(SipSubscribeClient::SubscriptionState newState,
                                         const char* earlyDialogHandle,
                                         const char* dialogHandle,
                                         void* applicationData,
                                         int responseCode,
                                         const char* responseText,
                                         long expiration,
                                         const SipMessage* subscribeResponse);

   /// Callback to handle incoming NOTIFYs.
   static void notifyEventCallback(const char* earlyDialogHandle,
                                   const char* dialogHandle,
                                   void* applicationData,
                                   const SipMessage* notifyRequest);
                                   
   /// Non-static callback to handle incoming NOTIFYs.
   void handleNotifyMessage(const SipMessage* notifyMessage,
                            const char* earlyDialogHandle,
                            const char* dialogHandle);

   /// Merge information from a dialogEvent into mDialogState.
   // Return StateChangeNotifier::ON_HOOK/OFF_HOOK depending on whether there
   // are any active dialogs for the subscription.
   // If the earlyDialogHandle is not in mDialogState, ignore the event, as
   // this is a NOTIFY due to an un-SUBSCRIBE.
   StateChangeNotifier::Status mergeEventInformation(SipDialogEvent* dialogEvent,
                                                     const char* earlyDialogHandle,
                                                     const char* dialogHandle);

   /// Create the dialog event state record for the SUBSCRIBE earlyDialogHandle.
   void createDialogState(UtlString* earlyDialogHandle);

   /// Delete the dialog event state record for the SUBSCRIBE earlyDialogHandle.
   void destroyDialogState(UtlString* earlyDialogHandle);

  private:

   // User agent to send SUBSCRIBEs and receive NOTIFYs.
   SipUserAgent* mpUserAgent;  
   // The SIP domain used to construct the identity URI for the user agent.
   UtlString mDomainName;
   // The Contact URI for the user agent.
   UtlString mContact;
   // The (maximum) subscription refresh time for our subscriptions.
   int mRefreshTimeout;
   bool mToBePublished;
   
   OsBSem mLock;
   
   SipDialogMgr mDialogManager;
   SipRefreshManager* mpRefreshMgr;
   SipSubscribeClient* mpSipSubscribeClient;
      
   SipDialogMgr mDialogMgr;
   SipSubscriptionMgr* mpSubscriptionMgr;
   SipSubscribeServerEventHandler mPolicyHolder;
   SipPublishContentMgr mSipPublishContentMgr;
   SipSubscribeServer* mpSubscribeServer;

   // UtlHashMap mapping group names to SipResourceList's of URIs in
   // the groups.
   UtlHashMap mMonitoredLists;
   // The last dialogEvent received for each AOR that we are watching.
   UtlHashMap mDialogEventList;
   UtlHashMap mDialogHandleList;
   UtlHashMap mStateChangeNotifiers;   
   // UtlHashMap mapping SUBSCRIBEs (via early dialog handles) to
   // UtlHashBag's that list the identifiers of all non-terminated dialogs
   // on the UAs for the subscribed-to URI.
   // Dialogs are identified by the string
   // "<dialog id (as given in the dialog event)><ctrl-A><dialog handle>".
   UtlHashMap mDialogState;

   /// Disabled copy constructor
   SipDialogMonitor(const SipDialogMonitor& rSipDialogMonitor);

   /// Disabled assignment operator
   SipDialogMonitor& operator=(const SipDialogMonitor& rhs);
};

#endif // _SIPDIALOGMONITOR_H_
//
// Copyright (C) 2007 Jaroslav Libak
// Licensed under the LGPL license.
//
// Copyright (C) 2005-2007 SIPez LLC.
// Licensed to SIPfoundry under a Contributor Agreement.
// 
// Copyright (C) 2004-2007 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef SipInfoStatusEventListener_h__
#define SipInfoStatusEventListener_h__

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include <utl/UtlString.h>
#include "tapi/sipXtapiEvents.h"

// DEFINES
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// FORWARD DECLARATIONS
// STRUCTS
// TYPEDEFS
// MACROS
// GLOBAL VARIABLES
// GLOBAL FUNCTIONS

class SipInfoStatusEvent
{
public:
   SIPX_INFOSTATUS_EVENT m_Event;
   SIPX_MESSAGE_STATUS m_Status;
   int m_iResponseCode;
   UtlString m_sResponseText;  
};


/**
* Listener for Info events
*/
class SipInfoStatusEventListener
{
   /* //////////////////////////// PUBLIC //////////////////////////////////// */

   /* ============================ CREATORS ================================== */
public:
   SipInfoStatusEventListener() {}
   virtual ~SipInfoStatusEventListener() {}

   /* ============================ MANIPULATORS ============================== */

   virtual void OnResponse(const SipInfoStatusEvent& event) = 0;

   virtual void OnNetworkError(const SipInfoStatusEvent& event) = 0;

   /* ============================ ACCESSORS ================================= */

   /* ============================ INQUIRY =================================== */

   /* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

   /* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

};

#endif // SipInfoStatusEventListener_h__
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_SIPLINE_H__6AD8439B_AA8A_4F09_B5C4_44A3BA9C7AC6__INCLUDED_)
#define AFX_SIPLINE_H__6AD8439B_AA8A_4F09_B5C4_44A3BA9C7AC6__INCLUDED_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <utl/UtlHashBag.h>
#include "HttpMessage.h"
#include "net/Url.h"


// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS

/**
 * Line contact type: Use the local address or a NAT-derived address 
 * (e.g. STUN)
 */
typedef enum LINE_CONTACT_TYPE
{
    LINE_CONTACT_LOCAL,          /**< Use the local IP address */
    LINE_CONTACT_NAT_MAPPED     /**< Use the NAT-derived IP address */

} LINE_CONTACT_TYPE ;

//STATE TRANSITION//
/*
                                                        |----1/2refresh time--|
                                                        |--------------refresh time-------------|
 ---------             ------------           --------          ---------
 | TRYING| --------->  |REGISTERED| --------->|FAILED| -------->|EXPIRED|
 ---------             ------------           --------          ---------
        |                                                       |       ^                                                               ^
        |                                                       |___|                                                           |
        |                                                                                                                               |
    |______________________failed the first time____________________|

*/

class SipLine
{
public:

   //utility functions
        enum LineStates
        {
                LINE_STATE_UNKNOWN  = 0,
                LINE_STATE_REGISTERED,  //sucessfull registeration , registration no expried on server
                LINE_STATE_DISABLED,    //not registering
                LINE_STATE_FAILED,              //failed registration
                LINE_STATE_PROVISIONED, //dont send registration , but enabled because server provisioned it.
                LINE_STATE_TRYING,              //registration message sent , awaiting response
                LINE_STATE_EXPIRED              //registration expried on server
        };

        SipLine(Url userEnteredUrl = "",
                Url identityUri = "",
        UtlString user ="",
                UtlBoolean visible = TRUE,
                int state = LINE_STATE_REGISTERED,
                UtlBoolean isAutoEnabled = TRUE,
                UtlBoolean useCallHandling = FALSE);

        virtual ~SipLine();
        SipLine(const SipLine& rSipLine);
        SipLine& operator=(const SipLine& rSipLine);


    UtlBoolean isDeviceLine() ;
    //: Determine if this line is a device line.  Presently, a line is
    //  considered a device line if it's user is "Device"

        UtlBoolean IsDuplicateRealm(const UtlString realm , const UtlString scheme = HTTP_DIGEST_AUTHENTICATION);

        UtlString& getLineId();


        int getState() ;
        void setState(int state) ;

        //who does the line belong to
        UtlString& getUser();
        void setUser(const UtlString user);

        //line identily or name - just the Uri
   void getIdentityAndUrl(Url &identity, Url &userEnteredUrl) ;
        void setIdentityAndUrl(Url identity, Url userEnteredUrl) ;
   Url& getUserEnteredUrl() ;
   Url& getIdentity() ;
   Url& getCanonicalUrl() ;

        //if line will get enabled after reboot - ( ie it is persitant)
        void setAutoEnableStatus( UtlBoolean isAutoEnabled);
        UtlBoolean getAutoEnableStatus();

        //to use the call handling of the owner or not
        UtlBoolean getCallHandling();
        void setCallHandling( UtlBoolean useCallHandling = TRUE);

        //if line is visible in the line list to the user
        UtlBoolean getVisibility();
        void setVisibility( UtlBoolean isEnable = TRUE);

        //for use from GUI
        int GetNumOfCredentials();

        UtlBoolean addCredentials(const UtlString& strRealm,
                const UtlString& strUserID,
                const UtlString& strPassword,
                const UtlString& Type);

        UtlBoolean getCredentials(const UtlString& type /*[in]*/,
                const UtlString& realm /*[in]*/,
                UtlString* userID /*[out]*/,
                UtlString* MD5_token /*[out]*/);

   UtlBoolean getDuplicateCredentials(const UtlString& type /*[in]*/,
                                      const UtlString& realm /*[in]*/);

   UtlBoolean getAllCredentials( int MaxEnteries/*[in]*/ ,
      int& actualEnteries /*[out/int]*/,
      UtlString realms[]/*[out/int]*/,
      UtlString UserId[]/*[out/int]*/,
          UtlString type[]/*[out/int]*/,
      UtlString passtoken[]/*[out/int]*/);

        //removes credetials for a particular realm
        void removeCredential(const UtlString* realm);
        //removes all credentials for this line
        void removeAllCredentials();

    void setPreferredContactUri(const Url& preferredContactUri) ;
      //: Set the preferred host/ip for the contact in subsequent registers
    UtlBoolean getPreferredContactUri(Url& preferredContactUri) const ;
      //: Get Preferred host/ip for the contact in subsequent registers

    LINE_CONTACT_TYPE getContactType() const ;
    void setContactType(LINE_CONTACT_TYPE eContactType) ;

protected:

        UtlBoolean mIsVisible;
        UtlBoolean mIsAutoEnabled;
        UtlBoolean mIsUsingCallHandling;
        Url mIdentity; //line key which is the canonical URL stripped of display name, angle brackets and field parameters (basically the URI).
    Url mUserEnteredUrl; //user entered URL string (could be incomplete "sip:444@")
    Url mCanonicalUrl; //The canonical URL which is the URL string with the host and port filled in if they were missing.
    LINE_CONTACT_TYPE meContactType;  /**< Type of of contact address (either LOCAL or NAT_MAPPED) */

        UtlString mUser;
    UtlString mLineId;
        int mCurrentState;
    Url mPreferredContactUri ;

        UtlHashBag mCredentials;

    void copyCredentials(const SipLine& rSipLine);
    void generateLineID(UtlString& lineId);
};

#endif // !defined(AFX_SIPLINE_H__6AD8439B_AA8A_4F09_B5C4_44A3BA9C7AC6__INCLUDED_)
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////



#if !defined(AFX_SIPLINECREDENTIALS_H__8B43463B_8F7F_426B_94F5_B60164A76DF3__INCLUDED_)
#define AFX_SIPLINECREDENTIALS_H__8B43463B_8F7F_426B_94F5_B60164A76DF3__INCLUDED_


#include <net/Url.h>
#include <net/HttpMessage.h>

class SipLineCredentials : public UtlString
{
public:

        SipLineCredentials(const UtlString realm,
                const UtlString userId,
                const UtlString passwordToken,
                const UtlString type);

        virtual ~SipLineCredentials();
        void getRealm(UtlString* realm);
        void getUserId(UtlString* UserId);
        void getPasswordToken(UtlString* passToken);
        void getType(UtlString* type);

private:

        UtlString mType;
        UtlString mPasswordToken;
        UtlString mUserId;
        UtlString mRealm;

};

#endif // !defined(AFX_SIPLINECREDENTIALS_H__8B43463B_8F7F_426B_94F5_B60164A76DF3__INCLUDED_)
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#if !defined(AFX_SIPLINEEVENT_H__E2361046_5679_4988_A2CD_7564686A3EE4__INCLUDED_)
#define AFX_SIPLINEEVENT_H__E2361046_5679_4988_A2CD_7564686A3EE4__INCLUDED_

// APPLICATION INCLUDES
#include <net/SipLine.h>
#include <os/OsMsg.h>
#include <net/SipMessage.h>


class SipLineEvent : public OsMsg  
{
public:
   enum EventSubTypes
   {
      SIP_LINE_EVENT_SUCCESS = 0,
      SIP_LINE_EVENT_FAILED,
      SIP_LINE_EVENT_NO_RESPONSE,
      SIP_LINE_EVENT_LINE_ADDED,
      SIP_LINE_EVENT_LINE_DELETED,
      SIP_LINE_EVENT_LINE_ENABLED,
      SIP_LINE_EVENT_LINE_DISABLED,
      SIP_LINE_EVENT_LINE_CHANGED,
      SIP_LINE_EVENT_OUTBOUND_CHANGED
   };


   SipLineEvent(SipLine* Line, 
      int msgType = SipLineEvent::SIP_LINE_EVENT_FAILED,
      UtlString realm ="",
      UtlString scheme = HTTP_DIGEST_AUTHENTICATION,
      int SipReturnCode = SIP_OK_CODE,
      UtlString SipReturntext = SIP_OK_TEXT,
      void* observeData = NULL);

   virtual ~SipLineEvent();
   
   virtual OsMsg* createCopy(void) const;
   
   SipLineEvent& operator=(const SipLineEvent& rhs) ;

   int getSipReturnCode();
   
   UtlString& getSipReturnText();
   
   SipLine* getLine();
   
   UtlString& getRealm();
   
   UtlString& getScheme();
   
   
   void setMessageType(int status);
   
   int getMessageType() const;
   
   void setObserverData(void* pData);
   
   void* getObserverData();

private:
   
   UtlString mRealm;
   UtlString mScheme;
   UtlString mSipReturnText;
   int mSipReturnCode;
   int mMessageType;
   SipLine mLine;
   void* mObserverData;

};

#endif // !defined(AFX_SIPLINEEVENT_H__E2361046_5679_4988_A2CD_7564686A3EE4__INCLUDED_)
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_SIPLINELIST_H__3822B7DD_69A6_44FC_B936_B75FACC65DC2__INCLUDED_)
#define AFX_SIPLINELIST_H__3822B7DD_69A6_44FC_B936_B75FACC65DC2__INCLUDED_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <os/OsLockingList.h>
#include <net/SipLine.h>
#include <os/OsRWMutex.h>
#include <os/OsReadLock.h>
#include <os/OsWriteLock.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

class SipLineList
{
public:
        UtlBoolean getDeviceLine(SipLine *line);
        UtlBoolean linesInArray(size_t maxSize , size_t* returnSize, SipLine* Line[]);
        UtlBoolean linesInArray(size_t maxSize, size_t* returnSize, SipLine Line[]);

        UtlBoolean getFirstLine(SipLine *Line);
        SipLine* getLine(const Url& identityUrl);
   SipLine* getLine(const UtlString& lineId);
   SipLine* getLine(const UtlString& userId, int& numOfMatches);

        int getListSize() ;

        UtlBoolean isDuplicate( SipLine* line);
        UtlBoolean isDuplicate( const Url& lineIdentityUrl );

        UtlBoolean remove(SipLine* line);
        UtlBoolean remove(const Url& lineIdentityUrl);
   void add(SipLine* newLine);

   SipLine* findLine(const char* lineId,
                     const char* realm,
                     const Url& toFromUrl,
                     const char* userId,
                     const Url& defaultLine) ;

        SipLineList();
        virtual ~SipLineList();
        void dumpLines();

protected:
        OsLockingList m_LineList;
};

#endif // !defined(AFX_SIPLINELIST_H__3822B7DD_69A6_44FC_B936_B75FACC65DC2__INCLUDED_)
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipLineMgr_h_
#define _SipLineMgr_h_

// SYSTEM INCLUDES
// #include <...>

// APPLICATION INCLUDES


#include "os/OsServerTask.h"
#include "net/SipLine.h"
#include "net/SipLineList.h"
#include "net/SipLineEvent.h"
#include "net/HttpMessage.h"

// DEFINES
#define MAX_LINES                       32                  // Max number of lines
#define MAX_CREDENTIALS                 32                  // Max number of credentials per line

#define BASE_PHONESET_LINE_KEY          "PHONESET_LINE."    // Base key for device lines
#define BASE_USER_LINE_KEY              "USER_LINE."        // Base key for user lines
#define USER_DEFAULT_OUTBOUND_LINE      "USER_DEFAULT_OUTBOUND_LINE" // Default outbound line

#define LINE_REGISTRATION_PROVISION     "PROVISION"         // Registration value: Provision
#define LINE_REGISTRATION_REGISTER      "REGISTER"          // Registration value: Register
#define LINE_ALLOW_FORWARDING_ENABLE    "ENABLE"            // Allow Forwarding value: Enable
#define LINE_ALLOW_FORWARDING_DISABLE   "DISABLE"           // Allow Forwarding value: Disable
#define LINE_CONTACT_TYPE_LOCAL         "LOCAL"             // Use local contact/IP
#define LINE_CONTACT_TYPE_NAT_MAPPED    "NAT_MAPPED"        // Use NAT-derived contact/IP

#define LINE_PARAM_LINEID               "LINEID"           // lineID
#define LINE_PARAM_URL                  "URL"               // Line Parameter: identity/url
#define LINE_PARAM_REGISTRATION         "REGISTRATION"      // Line Parameter: registration method
#define LINE_PARAM_ALLOW_FORWARDING     "ALLOW_FORWARDING"  // Line Parameter: allow call forwarding
#define LINE_PARAM_CONTACT_TYPE         "CONTACT_TYPE"      // Contact type (LOCAL or NAT_MAPPED)
#define LINE_PARAM_CREDENTIAL           "CREDENTIAL."       // Line Parameter: credential sub key
#define LINE_PARAM_CREDENTIAL_REALM     "REALM"             // Credential Parameter: realm
#define LINE_PARAM_CREDENTIAL_USERID    "USERID"            // Credential Parameter: userid
#define LINE_PARAM_CREDENTIAL_PASSTOKEN "PASSTOKEN"         // Credential Parameter: Pass token

#define DEFAULT_LINE_PARAM_PHONESET_LINE    "PHONESET_LINE" // Outbound Line Param: Device line
#define DEFAULT_LINE_PARAM_BASE_USER_LINE   "USER_LINE."    // Outbound Line Param: User line

// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class OsConfigDb;
class SipRefreshMgr;

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class SipLineMgr : public OsServerTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   SipLineMgr(const char* authenticationScheme = HTTP_DIGEST_AUTHENTICATION);
     //:Default constructor

   SipLineMgr(const SipLineMgr& rSipLineMgr);
     //:Copy constructor

   virtual
   ~SipLineMgr();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   void StartLineMgr();

   UtlBoolean initializeRefreshMgr( SipRefreshMgr * refreshMgr );

   void setDefaultContactUri(const Url& contactUri);

   void setOwner(const UtlString& owner);

   UtlBoolean addLine(SipLine& line,
                      UtlBoolean doEnable = TRUE);

   void deleteLine(const Url& identity);

   void setDefaultOutboundLine( const Url& outboundLine );

   UtlBoolean enableLine( const Url& identity );

   void disableLine(const Url& identity,
                    UtlBoolean onStartup = FALSE,
                    const UtlString& lineId ="");

   void lineHasBeenUnregistered(const Url& identity);

   void enableAllLines();

   UtlBoolean buildAuthenticatedRequest(const SipMessage* response /*[in]*/,
                                       const SipMessage* request /*[in]*/,
                                       SipMessage* newAuthRequest /*[out]*/);

   //
   // Line Manipulators
   //

   void setFirstLineAsDefaultOutBound();

   void setCallHandlingForLine(const Url& identity, UtlBoolean useCallHandling= TRUE);

   void setAutoEnableForLine(const Url& identity, UtlBoolean isAutoEnable = TRUE);

   void setStateForLine(const Url& identity, int state);

   void setVisibilityForLine(const Url& identity, UtlBoolean Visibility = TRUE);

   void setUserForLine(const Url& identity, const UtlString User);

   void setUserEnteredUrlForLine(const Url& identity, UtlString sipUrl);

   UtlBoolean setContactTypeForLine(const Url& identity, LINE_CONTACT_TYPE eContactType) ;

   UtlBoolean addCredentialForLine(
        const Url& identity,
        const UtlString strRealm,
        const UtlString strUserID,
        const UtlString strPasswd,
        const UtlString type);

   UtlBoolean deleteCredentialForLine(const Url& identity,
                                     const UtlString strRealm );

   //
   // Listener/Observer Manipulators
   //

   void addMessageObserver(OsMsgQ& messageQueue,
                            void* observerData = NULL );

   UtlBoolean removeMessageObserver(OsMsgQ& messageQueue,
                                   void* pObserverData = NULL );
   //:Removes all SIP message observers for the given message/queue observer
   //!param: messageQueue - All observers dispatching to this message queue
   //        will be removed if the pObserverData is NULL or matches.
   //!param: pObserverData - If null, all observers that match the message
   //        queue will be removed.  Otherwise, only observers that match
   //        both the message queue and observer data will be removed.
   //!returns TRUE if one or more observers are removed otherwise FALSE.

        void notifyChangeInLineProperties(Url& identity);

   void notifyChangeInOutboundLine(Url& identity);

   //
   // Serialization Manipulators
   //

   void storeLine( OsConfigDb* pConfigDb, UtlString strSubKey, SipLine line);
   //:Stores the specified line to the configuration database under the
   // passed key.
   //!param: (in) pConfigDb - Configuration database to save to.
   //!param: (in) strSubKey - ROOT sub key of configuration. For example
   //        "USER_LINE.1."
   //!param: (in) line - The line to be serialized

   UtlBoolean loadLine(OsConfigDb* pConfigDb, UtlString strSubkey, SipLine& line);
   //:Loads a line from the configuration database given the specified sub key.
   //!param: (in) pConfigDb - Configuration database to loaded from.
   //!param: (in) strSubKey - ROOT sub key of configuration. For example
   //        "USER_LINE.1."
   //!param: (out) line - The line to be serialized
   //!returns: TRUE if successfully loaded otherwise false.

   void purgeLines(OsConfigDb* pConfigDb) ;
   //:Removes all device and user lines from the configuration database.
   //!param: (in) pConfigDb - Configuration database to be cleared.

/* ============================ ACCESSORS ================================= */

   const UtlString& getOwner() const;

   void getDefaultOutboundLine( UtlString &rOutBoundLine );

   UtlBoolean getLine(
       const UtlString& toUrl,
       const UtlString& localContact,
       SipLine& sipline ) const;
    //:Get the line identified by the designated To and Local Contact URLs.
    //
    //!returns The line identified by the designated To and Local Contact
    //         URLs or NULL if not found.

   UtlBoolean getLines(size_t maxLines /*[in]*/,
                       size_t& actualLines /*[out]*/,
                       SipLine* lines[]/*[in/out]*/) const;

   UtlBoolean getLines(size_t maxLines /*[in]*/,
                       size_t& actualLines /*[in/out]*/,
                       SipLine lines[]/*[in/out]*/) const;

   int getNumLines () const;
   //:Get the current number of lines.

   int getNumOfCredentialsForLine( const Url& identity ) const;

   UtlBoolean getCredentialListForLine(
        const Url& identity,
        int maxEnteries,
        int &actualEnteries,
        UtlString realmList[],
        UtlString userIdList[],
        UtlString typeList[],
        UtlString passTokenList[] );

   UtlBoolean getCallHandlingForLine( const Url& identity ) const;

   UtlBoolean getEnableForLine(const Url& identity) const;

   int getStateForLine(const Url& identity ) const;

   UtlBoolean getVisibilityForLine(const Url& identity ) const;

   UtlBoolean getUserForLine(const Url& identity, UtlString &User) const;

   UtlBoolean getUserEnteredUrlForLine( const Url& identity, UtlString &sipUrl) const;

   UtlBoolean getCanonicalUrlForLine(const Url& identity, UtlString &sipUrl) const ;

   UtlBoolean getContactTypeForLine(const Url& identity, LINE_CONTACT_TYPE& eContactType) const ;

/* ============================ INQUIRY =================================== */

   UtlBoolean isUserIdDefined( const SipMessage* request /*[in]*/) const;


/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

   SipLineMgr& operator=(const SipLineMgr& rhs);
     //:Assignment operator

    UtlBoolean handleMessage(OsMsg& eventMessage);

    void queueMessageToObservers(SipLineEvent& event);

    void removeFromList(SipLine* line);

    void addToList(SipLine *line);

    SipLine* getLineforAuthentication(
        const SipMessage* request /*[in]*/,
        const SipMessage* response /*[in]*/,
        const UtlBoolean& isIncomingRequest = FALSE,
        const UtlBoolean& fromTempList = FALSE ) const;

    // temp list for storing credentials for deleted lines
    void removeFromTempList( SipLine* line );

    void addToTempList( SipLine *line );

    void storeCredential(
        OsConfigDb *pConfigDb,
        UtlString strSubKey,
        UtlString strRealm,
        UtlString strUserId,
        UtlString strPassToken,
        UtlString strType );
    //:Stores a single set of credentials under the passed key
    //!param: (in) pConfigDb - Configuration database to saved to.
    //!param: (in) strSubKey - ROOT sub key of configuration. For example
    //        "USER_LINE.1.CREDENTIAL.1."
    //!param: (in) strRealm - Realm for the Credential.
    //!param: (in) strUserId - User ID for the Credential.
    //!param: (in) strPassToken - Pass Token for the Credential.
    //!param: (in) strType - Authentication Type for the Credential.

    UtlBoolean loadCredential(
        OsConfigDb* pConfigDb,
        UtlString strSubKey,
        SipLine& line) ;
    //:Loads a credential from the configuration db which is identified by
    // the specified sub key.
    //!param: (in) pConfigDb - Configuration database to saved to.
    //!param: (in) strSubKey - ROOT sub key of configuration. For example
    //        "USER_LINE.1.CREDENTIAL.1."
    //!param: (in/out) line - The line to populate the credentials into.
    //!returns TRUE if successfully loaded otherwise FALSE.

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    void dumpLines();

    // MsgType categories defined for use by the system
    enum LineMsgTypes
    {
        UNSPECIFIED = 0,
        START_LINE_MGR
    };

    UtlBoolean mIsStarted;
    UtlString mAuthenticationScheme;
    UtlString mAuthenticationRealm;
    OsConfigDb* mpAuthenticationDb;
    OsConfigDb* mpAuthorizationUserIds;
    OsConfigDb* mpAuthorizationPasswords;

    SipRefreshMgr* mpRefreshMgr;
    UtlString mOwner;
    Url mOutboundLine;
    Url mDefaultContactUri;

    UtlHashBag mMessageObservers;
    OsRWMutex mObserverMutex;

    // line list and temp line lists
    mutable SipLineList  sLineList;
    mutable SipLineList  sTempLineList;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipLineMgr_h_
//
// Copyright (C) 2007 Jaroslav Libak
// Licensed under the LGPL license.
//
// Copyright (C) 2005-2007 SIPez LLC.
// Licensed to SIPfoundry under a Contributor Agreement.
// 
// Copyright (C) 2004-2007 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef SipLineStateEventListener_h__
#define SipLineStateEventListener_h__

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include <utl/UtlString.h>
#include "tapi/sipXtapiEvents.h"

// DEFINES
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// FORWARD DECLARATIONS
// STRUCTS
// TYPEDEFS
// MACROS
// GLOBAL VARIABLES
// GLOBAL FUNCTIONS

class SipLineStateEvent
{
public:

   UtlString m_sLineId;
   SIPX_LINESTATE_CAUSE m_Cause;
   int m_responseCode;
   UtlString m_sResponseText;

   SipLineStateEvent(const UtlString& lineId, SIPX_LINESTATE_CAUSE cause, int responseCode = 0, const UtlString& sResponseText = NULL)
      : m_sLineId(lineId),
        m_Cause(cause),
        m_responseCode(responseCode),
        m_sResponseText(sResponseText)
   {

   }
};


/**
* Listener for Line state events
*/
class SipLineStateEventListener
{
   /* //////////////////////////// PUBLIC //////////////////////////////////// */

   /* ============================ CREATORS ================================== */
public:
   SipLineStateEventListener() {}
   virtual ~SipLineStateEventListener() {}

   /* ============================ MANIPULATORS ============================== */

   virtual void OnLineRegistering(const SipLineStateEvent& event) = 0;

   virtual void OnLineRegistered(const SipLineStateEvent& event) = 0;

   virtual void OnLineUnregistering(const SipLineStateEvent& event) = 0;

   virtual void OnLineUnregistered(const SipLineStateEvent& event) = 0;

   virtual void OnLineRegisterFailed(const SipLineStateEvent& event) = 0;

   virtual void OnLineUnregisterFailed(const SipLineStateEvent& event) = 0;

   virtual void OnLineProvisioned(const SipLineStateEvent& event) = 0;

   /* ============================ ACCESSORS ================================= */

   /* ============================ INQUIRY =================================== */

   /* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

   /* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

};

#endif // SipLineStateEventListener_h__
//
// 
// Copyright (C) 2005, 2006 SIPez LLC
// Licensed to SIPfoundry under a Contributor Agreement.
//
// Copyright (C) 2005, 2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

// Author: Dan Petrie (dpetrie AT SIPez DOT com)

#ifndef _SipMessage_h_
#define _SipMessage_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <utl/UtlHashBag.h>
#include <os/OsSocket.h>
#include <net/HttpMessage.h>
#include <net/SdpBody.h>
#include <sdp/SdpCodec.h>
#include <net/Url.h>
#include <net/SmimeBody.h>
#include <tapi/sipXtapi.h>
#include <tapi/sipXtapiEvents.h>


class UtlHashMap;
class SipUserAgent;
class SipRegInfoBody;        // for RFC 3680


// DEFINES

// SIP extensions
#define SIP_CALL_CONTROL_EXTENSION "sip-cc"
#define SIP_SESSION_TIMER_EXTENSION "timer"
#define SIP_REPLACES_EXTENSION "replaces"
#define SIP_JOIN_EXTENSION "join"

// SIP Methods
#define SIP_INVITE_METHOD "INVITE"
#define SIP_ACK_METHOD "ACK"
#define SIP_BYE_METHOD "BYE"
#define SIP_CANCEL_METHOD "CANCEL"
#define SIP_INFO_METHOD "INFO"
#define SIP_NOTIFY_METHOD "NOTIFY"
#define SIP_OPTIONS_METHOD "OPTIONS"
#define SIP_REFER_METHOD "REFER"
#define SIP_REGISTER_METHOD "REGISTER"
#define SIP_SUBSCRIBE_METHOD "SUBSCRIBE"
#define SIP_PING_METHOD         "PING"


//Simple Methods
#define SIP_MESSAGE_METHOD "MESSAGE"
#define SIP_DO_METHOD "DO"
#define SIP_PUBLISH_METHOD "PUBLISH"

// SIP Fields
#define SIP_ACCEPT_FIELD "ACCEPT"
#define SIP_ACCEPT_ENCODING_FIELD HTTP_ACCEPT_ENCODING_FIELD
#define SIP_ACCEPT_LANGUAGE_FIELD HTTP_ACCEPT_LANGUAGE_FIELD
#define SIP_ALLOW_FIELD "ALLOW"
#define SIP_ALSO_FIELD "ALSO"
#define SIP_CALLID_FIELD "CALL-ID"
#define SIP_CONFIG_ALLOW_FIELD "CONFIG_ALLOW"
#define SIP_CONFIG_REQUIRE_FIELD "CONFIG_REQUIRE"
#define SIP_SHORT_CALLID_FIELD "i"
#define SIP_CONTACT_FIELD "CONTACT"
#define SIP_SHORT_CONTACT_FIELD "m"
#define SIP_CONTENT_LENGTH_FIELD HTTP_CONTENT_LENGTH_FIELD
#define SIP_SHORT_CONTENT_LENGTH_FIELD "l"
#define SIP_CONTENT_TYPE_FIELD HTTP_CONTENT_TYPE_FIELD
#define SIP_SHORT_CONTENT_TYPE_FIELD "c"
#define SIP_CONTENT_ENCODING_FIELD "CONTENT-ENCODING"
#define SIP_SHORT_CONTENT_ENCODING_FIELD "e"
#define SIP_CSEQ_FIELD "CSEQ"
#define SIP_DIVERSION_FIELD "DIVERSION"   // draft-levy-sip-diversion-08 Diversion header
#define SIP_EVENT_FIELD "EVENT"
#define SIP_SHORT_EVENT_FIELD "o"
#define SIP_EXPIRES_FIELD "EXPIRES"
#define SIP_FROM_FIELD "FROM"
#define SIP_IF_MATCH_FIELD "SIP-IF-MATCH"
#define SIP_SHORT_FROM_FIELD "f"
#define SIP_MAX_FORWARDS_FIELD "MAX-FORWARDS"
#define SIP_P_ASSERTED_IDENTITY_FIELD "P-ASSERTED-IDENTITY"
#define SIP_Q_FIELD "Q"
#define SIP_REASON_FIELD "REASON"          //  RFC 3326 Reason header
#define SIP_RECORD_ROUTE_FIELD "RECORD-ROUTE"
#define SIP_REFER_TO_FIELD "REFER-TO"
#define SIP_SHORT_REFER_TO_FIELD "r"
#define SIP_REFERRED_BY_FIELD "REFERRED-BY"
#define SIP_SHORT_REFERRED_BY_FIELD "b"
#define SIP_REPLACES_FIELD "REPLACES"
#define SIP_REQUEST_DISPOSITION_FIELD "REQUEST-DISPOSITION"
#define SIP_REQUESTED_BY_FIELD "REQUESTED-BY"
#define SIP_REQUIRE_FIELD "REQUIRE"
#define SIP_PROXY_REQUIRE_FIELD "PROXY-REQUIRE"
#define SIP_ROUTE_FIELD "ROUTE"
#define SIP_SERVER_FIELD "SERVER"
#define SIP_SESSION_EXPIRES_FIELD "SESSION-EXPIRES"
#define SIP_IF_MATCH_FIELD "SIP-IF-MATCH"
#define SIP_ETAG_FIELD "SIP-ETAG"
#define SIP_SUBJECT_FIELD "SUBJECT"
#define SIP_SHORT_SUBJECT_FIELD "s"
#define SIP_SUBSCRIPTION_STATE_FIELD "SUBSCRIPTION-STATE"
#define SIP_SUPPORTED_FIELD "SUPPORTED"
#define SIP_SHORT_SUPPORTED_FIELD "k"
#define SIP_TO_FIELD "TO"
#define SIP_SHORT_TO_FIELD "t"
#define SIP_UNSUPPORTED_FIELD "UNSUPPORTED"
#define SIP_USER_AGENT_FIELD HTTP_USER_AGENT_FIELD
#define SIP_VIA_FIELD "VIA"
#define SIP_SHORT_VIA_FIELD "v"
#define SIP_WARNING_FIELD "WARNING"
#define SIP_MIN_EXPIRES_FIELD "MIN-EXPIRES"

///custom fields
#define SIP_LINE_IDENTIFIER "LINEID"
#define SIPX_IMPLIED_SUB "sipx-implied" ///< integer expiration duration for subscription
// Response codes and text
#define SIP_TRYING_CODE 100
#define SIP_TRYING_TEXT "Trying"

#define SIP_RINGING_CODE 180
#define SIP_RINGING_TEXT "Ringing"

#define SIP_QUEUED_CODE 182
#define SIP_QUEUED_TEXT "Queued"

#define SIP_EARLY_MEDIA_CODE 183
#define SIP_EARLY_MEDIA_TEXT "Session Progress"

#define SIP_2XX_CLASS_CODE 200

#define SIP_OK_CODE 200
#define SIP_OK_TEXT "OK"

#define SIP_ACCEPTED_CODE 202
#define SIP_ACCEPTED_TEXT "Accepted"

#define SIP_3XX_CLASS_CODE 300

#define SIP_MULTI_CHOICE_CODE 300
#define SIP_MULTI_CHOICE_TEXT "Multiple Choices"

#define SIP_PERMANENT_MOVE_CODE 301
#define SIP_PERMANENT_MOVE_TEXT "Moved Permanently"

#define SIP_TEMPORARY_MOVE_CODE 302
#define SIP_TEMPORARY_MOVE_TEXT "Moved Temporarily"

#define SIP_USE_PROXY_CODE 305
#define SIP_USE_PROXY_TXT "Use Proxy"

#define SIP_4XX_CLASS_CODE 400

#define SIP_BAD_REQUEST_CODE 400
#define SIP_BAD_REQUEST_TEXT "Bad Request"

#define SIP_FORBIDDEN_CODE 403
#define SIP_FORBIDDEN_TEXT "Forbidden"

#define SIP_NOT_FOUND_CODE 404
#define SIP_NOT_FOUND_TEXT "Not Found"

#define SIP_BAD_METHOD_CODE 405
#define SIP_BAD_METHOD_TEXT "Method Not Allowed"

#define SIP_REQUEST_TIMEOUT_CODE 408
#define SIP_REQUEST_TIMEOUT_TEXT "Request timeout"

#define SIP_CONDITIONAL_REQUEST_FAILED_CODE 412
#define SIP_CONDITIONAL_REQUEST_FAILED_TEXT "Conditional Request Failed"

#define SIP_BAD_MEDIA_CODE 415
#define SIP_BAD_MEDIA_TEXT "Unsupported Media Type or Content Encoding"

#define SIP_UNSUPPORTED_URI_SCHEME_CODE 416
#define SIP_UNSUPPORTED_URI_SCHEME_TEXT "Unsupported URI Scheme"

#define SIP_BAD_EXTENSION_CODE 420
#define SIP_BAD_EXTENSION_TEXT "Extension Not Supported"

#define SIP_TOO_BRIEF_CODE 423
#define SIP_TOO_BRIEF_TEXT "Registration Too Brief"
#define SIP_SUB_TOO_BRIEF_TEXT "Subscription Too Brief"

#define SIP_BAD_TRANSACTION_CODE 481
#define SIP_BAD_TRANSACTION_TEXT "Transaction Does Not Exist"

#define SIP_LOOP_DETECTED_CODE 482
#define SIP_LOOP_DETECTED_TEXT "Loop Detected"

#define SIP_TOO_MANY_HOPS_CODE 483
#define SIP_TOO_MANY_HOPS_TEXT "Too many hops"

#define SIP_BAD_ADDRESS_CODE 484
#define SIP_BAD_ADDRESS_TEXT "Address Incomplete"

#define SIP_BUSY_CODE 486
#define SIP_BUSY_TEXT "Busy Here"

#define SIP_REQUEST_TERMINATED_CODE 487
#define SIP_REQUEST_TERMINATED_TEXT "Request Terminated"

#define SIP_REQUEST_NOT_ACCEPTABLE_HERE_CODE 488
#define SIP_REQUEST_NOT_ACCEPTABLE_HERE_TEXT "Not Acceptable Here"

#define SIP_BAD_EVENT_CODE 489
#define SIP_BAD_EVENT_TEXT "Requested Event Type Is Not Supported"

#define SIP_REQUEST_PENDING_CODE 491
#define SIP_REQUEST_PENDING_TEXT "Request Pending"   

#define SIP_REQUEST_UNDECIPHERABLE_CODE 493
#define SIP_REQUEST_UNDECIPHERABLE_TEXT "Request Contained an Undecipherable S/MIME body"

#define SIP_5XX_CLASS_CODE 500

#define SIP_SERVER_INTERNAL_ERROR_CODE 500
#define SIP_SERVER_INTERNAL_ERROR_TEXT "Internal Server Error"

#define SIP_UNIMPLEMENTED_METHOD_CODE 501
#define SIP_UNIMPLEMENTED_METHOD_TEXT "Not Implemented"

#define SIP_SERVICE_UNAVAILABLE_CODE 503
#define SIP_SERVICE_UNAVAILABLE_TEXT "Service Unavailable"

#define SIP_BAD_VERSION_CODE 505
#define SIP_BAD_VERSION_TEXT "Version Not Supported"

#define SIP_6XX_CLASS_CODE 600

#define SIP_GLOBAL_BUSY_CODE 600
#define SIP_GLOBAL_BUSY_TEXT "Busy Everywhere"

#define SIP_DECLINE_CODE 603
#define SIP_DECLINE_TEXT "Declined"

// Warning codes
#define SIP_WARN_MEDIA_NAVAIL_CODE 304
#define SIP_WARN_MEDIA_NAVAIL_TEXT "Media type not available"
#define SIP_WARN_MEDIA_INCOMPAT_CODE 305
#define SIP_WARN_MEDIA_INCOMPAT_TEXT "Insufficient compatible media types"
#define SIP_WARN_MISC_CODE 399

// Transport stuff
#define SIP_PORT 5060
#define SIP_TLS_PORT 5061
#define SIP_PROTOCOL_VERSION "SIP/2.0"
#define SIP_SUBFIELD_SEPARATOR " "
#define SIP_SUBFIELD_SEPARATORS "\t "
#define SIP_MULTIFIELD_SEPARATOR ","
#define SIP_SINGLE_SPACE " "
#define SIP_MULTIFIELD_SEPARATORS "\t ,"
#define SIP_TRANSPORT_UDP "UDP"
#define SIP_TRANSPORT_TCP "TCP"
#define SIP_TRANSPORT_TLS "TLS"
#define SIP_URL_TYPE "SIP:"
#define SIPS_URL_TYPE "SIPS:"
#define SIP_DEFAULT_MAX_FORWARDS 70

// Caller preference request dispostions tokens
#define SIP_DISPOSITION_QUEUE "QUEUE"

// NOTIFY method event types
#define SIP_EVENT_MESSAGE_SUMMARY           "message-summary"
#define SIP_EVENT_SIMPLE_MESSAGE_SUMMARY    "simple-message-summary"
#define SIP_EVENT_CHECK_SYNC                "check-sync"
#define SIP_EVENT_REFER                     "refer"
#define SIP_EVENT_CONFIG                    "sip-config"
#define SIP_EVENT_UA_PROFILE                "ua-profile"
#define SIP_EVENT_REGISTER                  "reg" //  RFC 3680 
#define SIP_EVENT_PRESENCE                  "presence"

// NOTIFY Subscription-State values
#define SIP_SUBSCRIPTION_ACTIVE             "active"
#define SIP_SUBSCRIPTION_PENDING            "pending"
#define SIP_SUBSCRIPTION_TERMINATED         "terminated"

// The following are used for the REFER NOTIFY message body contents
#define CONTENT_TYPE_SIP_APPLICATION        "application/sip"
#define CONTENT_TYPE_MESSAGE_SIPFRAG        "message/sipfrag"
#define CONTENT_TYPE_SIMPLE_MESSAGE_SUMMARY "application/simple-message-summary"
#define CONTENT_TYPE_XPRESSA_SCRIPT         "text/xpressa-script"
#define CONTENT_TYPE_VQ_RTCP_XR             "application/vq-rtcpxr"

// Added for RFC 3680 
#define CONTENT_TYPE_REG_INFO 		"application/reg-info+xml"

#define SIP_REFER_SUCCESS_STATUS "SIP/2.0 200 OK\r\n"
#define SIP_REFER_FAILURE_STATUS "SIP/2.0 503 Service Unavailable\r\n"

//Added for Diversion header reason parameters

#define SIP_DIVERSION_UNKNOWN "unknown"
#define SIP_DIVERSION_BUSY "user-busy"
#define SIP_DIVERSION_UNAVAILABLE "unavailable"
#define SIP_DIVERSION_UNCONDITIONAL "unconditional"
#define SIP_DIVERSION_TIMEOFDAY "time-of-day"
#define SIP_DIVERSION_DND "do-not-disturb"
#define SIP_DIVERSION_DEFLECTION "deflection"
#define SIP_DIVERSION_OTOFSERVICE "out-of-service"
#define SIP_DIVERSION_FOLLOWME "follow-me"
#define SIP_DIVERSION_AWAY "away"

// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class SipTransaction;

/// Specialization of HttpMessage to contain and manipulate SIP messages
/**
 * @see HttpMessage for the descriptions of the general constructs
 * manipulators and accessors for the three basic parts of a SIP
 * message.  A message can be queried as to whether it is a request or a
 * response via the isResponse method.
 *
 * @nosubgrouping
 */
class SipMessage : public HttpMessage, public ISmimeNotifySink
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
   // See sipXcall's CpCallManager for more defines

   enum EventSubTypes
   {
       NET_UNSPECIFIED = 0,
       NET_SIP_MESSAGE
   };

/* ============================ CREATORS ================================== */

    //! Construct from a buffer
    SipMessage(const char* messageBytes = NULL,
               int byteCount = -1);

    //! Construct from bytes read from a socket
    SipMessage(OsSocket* inSocket,
              int bufferSize = HTTP_DEFAULT_SOCKET_BUFFER_SIZE);

    //! Copy constructor
    SipMessage(const SipMessage& rSipMessage);

    //! Assignment operator
    SipMessage& operator=(const SipMessage& rhs);

    virtual
    ~SipMessage();
    //:Destructor

/* ============================ MANIPULATORS ============================== */

    static UtlBoolean getShortName( const char* longFieldName,
                                   UtlString* shortFieldName );

    static UtlBoolean getLongName( const char* shortFieldName,
                                  UtlString* longFieldName );

    void replaceShortFieldNames();

    void replaceLongFieldNames();

/* ============================ ACCESSORS ================================= */

    //! @name SIP URL manipulators
    //@{
    static void buildSipUrl(UtlString* url, const char* address,
                            int port = PORT_NONE,
                            const char* protocol = NULL,
                            const char* user = NULL,
                            const char* userLabel = NULL,
                            const char* tag = NULL);

    static void buildReplacesField(UtlString& replacesField,
                                   const char* callId,
                                   const char* fromField,
                                   const char* toFIeld);

    static UtlBoolean parseParameterFromUri(const char* uri,
                                           const char* parameterName,
                                           UtlString* parameterValue);

    static void setUriParameter(UtlString* uri, const char* parameterName,
                                const char* parameterValue);

    static void parseAddressFromUri(const char* uri, UtlString* address,
                                    int* port, UtlString* protocol,
                                    UtlString* user = NULL,
                                    UtlString* userLabel = NULL,
                                    UtlString* tag = NULL);

    static void ParseContactFields(const SipMessage *sipResponse,
                                   const SipMessage* ipRequest,
                                   const UtlString& subFieldName,
                                   int& subFieldValue);

    static void setUriTag(UtlString* uri, const char* tagValue);

    static UtlBoolean getViaTag(const char* viaField,
                           const char* tagName,
                           UtlString& tagValue);
    //@}

    //! @name SIP specific first header line accessors
    //@{
    void setSipRequestFirstHeaderLine(const char* method,
                                      const char* uri,
                                      const char* protocolVersion = SIP_PROTOCOL_VERSION);

    void changeUri(const char* uri);

    void getUri(UtlString* address, int* port,
                UtlString* protocol,
                UtlString* user = NULL) const;
    //@}


    //! @name Request builder methods
    /*! The following set of methods are used for building
     * requests in this message
     */
    //@{
    void setAckData(const char* uri,
                    const char* fromAddress,
                    const char* toAddress,
                    const char* callId,
                    int sequenceNumber = 1);

    void setAckData(const SipMessage* inviteResponse,
                    const SipMessage* inviteRequest,
                    const char* contactUri = NULL,
                    int sessionExpiresSeconds = 0);

    void setAckErrorData(const SipMessage* inviteResponse);

    void setByeData(const char* uri,
                    const char* fromAddress,
                    const char* toAddress,
                    const char* callId,
                    const char* localContact,
                    int sequenceNumber = 1);

    void setByeData(const SipMessage* inviteResponse,
                    const char * lastRespContact,
                    UtlBoolean byeToCallee,
                    int localSequenceNumber,
                    const char* routeField,
                    const char* alsoInviteUri,
                    const char* localContact);

    void setCancelData(const char* fromAddress, const char* toAddress,
                       const char* callId,
                       int sequenceNumber = 1,
                       const char* localContact=NULL);

    void setCancelData(const SipMessage* inviteResponse,
                       const char* localContact=NULL);

    void setInviteData(const char* fromAddress,
                       const char* toAddress,
                       const char * farEndContact,
                       const char* contactUrl,
                       const char* callId,                       
                       int sequenceNumber = 1,
                       int sessionReinviteTimer = 0);

    void setInviteData(const SipMessage* previousInvite,
                       const char* newUri);

    void setReinviteData(SipMessage* invite,
                         const char* farEndContact,
                         const char* contactUrl,
                         UtlBoolean inviteFromThisSide,
                         const char* routeField,
                         int sequenceNumber,
                         int sessionReinviteTimer);

    void setOptionsData(const SipMessage* inviteRequest,
                        const char* LastRespContact,
                        UtlBoolean optionsToCallee,
                        int localCSequenceNumber,
                        const char* routeField,
                        const char* localContact);

    void setNotifyData(SipMessage *subscribeRequest,
                       int lastLocalSequenceNumber,
                       const char* route,
                       const char* stateField = NULL,
                       const char* eventField = NULL,
                       const char* id = NULL);

    void setNotifyData( const char* uri,
                        const char* fromField,
                        const char* toField,
                        const char* callId,
                        int lastNotifyCseq,
                        const char* eventtype,
                        const char* id,
                        const char* state,
                        const char* contact,
                        const char* routeField);

    void setSubscribeData( const char* uri,
                        const char* fromField,
                        const char* toField,
                        const char* callId,
                        int cseq,
                        const char* eventField,
                        const char* acceptField,
                        const char* id,
                        const char* contact,
                        const char* routeField,
                        int expiresInSeconds);

    void setEnrollmentData(const char* uri,
                           const char* fromField,
                           const char* toField,
                           const char* callId,
                           int CSequenceNum,
                           const char* contactUrl,
                           const char* protocolField,
                           const char* profileField,
                           int expiresInSeconds = -1);

    /* RFC 3428 - MWI*/
    void setMessageSummaryData(
                  UtlString& msgSummaryData,
                  const char* msgAccountUri,
                  UtlBoolean bNewMsgs=FALSE,
                  UtlBoolean bVoiceMsgs=FALSE,
                  UtlBoolean bFaxMsgs=FALSE,
                  UtlBoolean bEmailMsgs=FALSE,
                  int numNewMsgs=-1,
                  int numOldMsgs=-1,
                  int numFaxNewMsgs=-1,
                  int numFaxOldMsgs=-1,
                  int numEmailNewMsgs=-1,
                  int numEmailOldMsgs=-1);

    /* RFC 3428 - MWI */
    void setMWIData(const char *method,
				  const char* fromField,
                  const char* toField,
                  const char* uri,
                  const char* contactUrl,
                  const char* callId,
                  int CSeq,
                  UtlString bodyString);

    /* RFC 3680 - Registration event */
    void setRegInfoData(const char *method,
		    const char* fromField,
                  const char* toField,
                  const char* uri,
                  const char* contactUrl,
                  const char* callId,
                  int CSeq,
                  SipRegInfoBody& regInfoBody);

    void setVoicemailData(const char* fromField,
                           const char* toField,
                           const char* Uri,
                           const char* contactUrl,
                           const char* callId,
                           int CSeq,
                           int subscribePeriod = -1);


    void setReferData(const SipMessage* inviteResponse,
                    UtlBoolean byeToCallee,
                    int localSequenceNumber,
                    const char* routeField,
                    const char* contactUrl,
                    const char* remoteContactUrl,
                    const char* transferTargetAddress,
                    const char* targetCallId);

    void setRegisterData(const char* registererUri,
                         const char* registerAsUri,
                         const char* registrarServerUri,
                         const char* takeCallsAtUri,
                         const char* callId,
                         int sequenceNumber,
                         int expiresInSeconds = -1);

    void setRequestData(const char* method,
                        const char* uri,
                        const char* fromAddress,
                        const char* toAddress,
                        const char* callId,
                        int sequenceNumber = 1,
                        const char* contactUrl = NULL);

    //! Set a PUBLISH request
    void setPublishData( const char* uri,
                         const char* fromField,
                         const char* toField,
                         const char* callId,
                         int cseq,
                         const char* eventField,
                         const char* id,
                         const char* sipIfMatchField,
                         int expiresInSeconds,
                         const char* contact);
    /// Apply any header parameters in the request uri to the message
    void applyTargetUriHeaderParams();
    /**
     * There are some special rules implemented by this routine:
     *
     * - The header must not be forbidden by isUrlHeaderAllowed
     *
     * - If the header is a From, then any tag parameter on that
     *   new From header value is removed, and the tag parameter
     *   from the original From header is inserted.  The original
     *   From header value is inserted in an X-Original-From header.
     *
     * - If the header is a Route, it is forced to be a loose route
     *   and inserted as the topmost Route.
     *
     * - If it a unique header per isUrlHeaderUnique, then the new
     *   value replaces the old one.
     *
     * - otherwise, the new header is just added.to the message.
     */

    //@}

    void addSdpBody(int nRtpContacts,
                    UtlString hostAddresses[],
                    int rtpAudioPorts[],
                    int rtcpAudiopPorts[],
                    int rtpVideoPorts[],
                    int rtcpVideoPorts[],
                    RTP_TRANSPORT transportTypes[],
                    int numRtpCodecs,
                    SdpCodec* rtpCodecs[],
                    SdpSrtpParameters* srtpParams,
                    int videoBandwidth,
                    int videoFramerate,
                    const SipMessage* pRequest = NULL,
                    const RTP_TRANSPORT rtpTransportOptions = RTP_TRANSPORT_UDP);

    void setSecurityAttributes(const SIPXTACK_SECURITY_ATTRIBUTES* const pSecurity);
    SIPXTACK_SECURITY_ATTRIBUTES* const getSecurityAttributes() const { return mpSecurity; } 
    bool fireSecurityEvent(const void* pEventData,
                           const enum SIPX_SECURITY_EVENT,
                           const enum SIPX_SECURITY_CAUSE,
                           SIPXTACK_SECURITY_ATTRIBUTES* const pSecurity,
                           void* pCert = NULL,
                           char* szSubjectAltName = NULL) const;
    bool smimeEncryptSdp(const void *pEventData) ;

    //! Accessor to get SDP body, optionally decrypting it if key info. is provided
    const SdpBody* getSdpBody(SIPXTACK_SECURITY_ATTRIBUTES* const pSecurity = NULL,
                              const void* pEventData = NULL) const;


    //! @name Response builders
    /*! The following methods are used to build responses
     * in this message
     */
    //@{
    void setResponseData(const SipMessage* request,
                        int responseCode,
                        const char* responseText,
                        const char* localContact = NULL);

    void setResponseData(int statusCode, const char* statusText,
                        const char* fromAddress,
                        const char* toAddress,
                        const char* callId,
                        int sequenceNumber,
                        const char* sequenceMethod,
                        const char* localContact = NULL);

    void setOkResponseData(const SipMessage* request,
                           const char* localContact = NULL);

    void setRequestTerminatedResponseData(const SipMessage* request);

    virtual void setRequestUnauthorized(const SipMessage* request,
                                const char* authenticationScheme,
                                const char* authenticationRealm,
                                const char* authenticationNonce = NULL,
                                const char* authenticationOpaque = NULL,
                                enum HttpEndpointEnum authEntity = SERVER);

    void setTryingResponseData(const SipMessage* request);

    /// Generate a 488 response (no compatible codecs).
    void setInviteBadCodecs(const SipMessage* inviteRequest,
                            SipUserAgent* ua
                            /**< SipUserAgent from which to extract the
                             *   agent identification for the Warning:
                             *   header.
                             */
       );

    void setInviteForbidden(const SipMessage* request);

    void setRequestBadMethod(const SipMessage* request,
                             const char* allowedMethods);

    void setRequestUnimplemented(const SipMessage* request);

    void setRequestBadExtension(const SipMessage* request,
                                const char* unsuportedExtensions);

    void setRequestBadAddress(const SipMessage* request);

    void setRequestBadVersion(const SipMessage* request);

    void setRequestBadRequest(const SipMessage* request);

    void setRequestBadUrlType(const SipMessage* request);

    void setRequestBadContentEncoding(const SipMessage* request,
                             const char* allowedEncodings);

    void setInviteRingingData(const char* fromAddress, const char* toAddress,
                              const char* callId,
                              int sequenceNumber = 1);

    void setInviteRingingData(const SipMessage* inviteRequest);

    void setQueuedResponseData(const SipMessage* inviteRequest);

    void setRequestPendingData(const SipMessage* inviteRequest);

    void setForwardResponseData(const SipMessage* inviteRequest,
                                const char* forwardAddress);

    void setInviteBusyData(const char* fromAddress, const char* toAddress,
                       const char* callId,
                       int sequenceNumber = 1);

    void setBadTransactionData(const SipMessage* inviteRequest);

    void setLoopDetectedData(const SipMessage* inviteRequest);

    void setInviteBusyData(const SipMessage* inviteRequest);

    void setInviteOkData(const SipMessage* inviteRequest,                         
                         int maxSessionExpiresSeconds,
                         const char* localContact = NULL);

    void setByeErrorData(const SipMessage* byeRequest);

    void setReferOkData(const SipMessage* referRequest);

    void setReferDeclinedData(const SipMessage* referRequest);

    void setReferFailedData(const SipMessage* referRequest);

    void setEventData(void* pEventData) { mpEventData = pEventData; }
    //@}


    //! @name Specialized header field accessors
    //@{
    UtlBoolean getFieldSubfield(const char* fieldName, int subfieldIndex,
                               UtlString* subfieldValue) const;

    UtlBoolean getContactUri(int addressIndex, UtlString* uri) const;

    UtlBoolean getContactField(int addressIndex,
                              UtlString& contactField) const;

    UtlBoolean getContactEntry(int addressIndex,
                              UtlString* uriAndParameters) const;

    UtlBoolean getContactAddress(int addressIndex,
                                UtlString* contactAddress,
                                int* contactPort,
                                UtlString* protocol,
                                UtlString* user = NULL,
                                UtlString* userLabel = NULL) const;

    void setViaFromRequest(const SipMessage* request);

    /// fills in parameters in topmost via based on actual received information.
    void setReceivedViaParams(const UtlString& fromIpAddress, ///< actual sender ip
                              int              fromPort       ///< actual sender port
                              );

    void addVia(const char* domainName,
                int port,
                const char* protocol,
                const char* branchId = NULL,
                const bool bIncludeRport = false,
                const char* customRouteId = NULL) ;

    void addViaField(const char* viaField, UtlBoolean afterOtherVias = TRUE);

    void setLastViaTag(const char* tagValue,
                       const char* tagName = "received");

    void setCallIdField(const char* callId = NULL);

    void setCSeqField(int sequenceNumber, const char* method);
    void incrementCSeqNumber();

    void setFromField(const char* fromField);

    void setFromField(const char* fromAddress, int fromPort,
                      const char* fromProtocol = NULL,
                      const char* fromUser = NULL,
                      const char* fromLabel = NULL);

    void setRawToField(const char* toField);

    void setRawFromField(const char* toField);

    void setToField(const char* toAddress, int toPort,
                    const char* fromProtocol = NULL,
                    const char* toUser = NULL,
                    const char* toLabel = NULL);
    void setToFieldTag(const char* tagValue);

    void setToFieldTag(int tagValue);

    void setExpiresField(int expiresInSeconds);

    void setMinExpiresField(int minimumExpiresInSeconds);

    void setContactField(const char* contactField, int index = 0);

    void setRequestDispositionField(const char* dispositionField);

    void addRequestDisposition(const char* dispositionToken);

    void setWarningField(int code, const char* hostname, const char* text);
    
    void getFromLabel(UtlString* fromLabel) const;

    void getToLabel(UtlString* toLabel) const;

    void getFromField(UtlString* fromField) const;

    void getFromUri(UtlString* uri) const;

    void getFromUrl(Url& url) const;

    void getFromAddress(UtlString* fromAddress, int* fromPort, UtlString* protocol,
                        UtlString* user = NULL, UtlString* userLabel = NULL,
                        UtlString* tag = NULL) const;

    //! Get the identity value from the P-Asserted-Identity header field
    /*! Get the identity from the index'th P-Asserted-Identity header
     *  field if it exists.
     *  \param identity - network asserted SIP identity (name-addr or
     *                  addr-spec format).  Use the Url class to parse the identity
     *  \param index - indicates which occurrance of P-Asserted-Identity header
     *                 to retrieve.
     *  \return TRUE/FALSE if the header of the given index exists
     */
    UtlBoolean getPAssertedIdentityField(UtlString& identity, int index = 0) const;

    //! Remove all of the P-Asserted-Identity header fields
    void removePAssertedIdentityFields();

    //! Add the P-Asserted-Identity value 
    void addPAssertedIdentityField(const UtlString& identity);

    UtlBoolean getResponseSendAddress(UtlString& address,
                                     int& port,
                                     UtlString& protocol) const;

    static void convertProtocolStringToEnum(const char* protocolString,
                        OsSocket::IpProtocolSocketType& protocolEnum);

    static void convertProtocolEnumToString(OsSocket::IpProtocolSocketType protocolEnum,
                                            UtlString& protocolString);

    UtlBoolean getWarningCode(int* warningCode, int index = 0) const;

    // Retrieves the index-th Via: header as it appears in the message,
    // but does not parse Via: headers for ",".
    // You probably want to use getViaFieldSubField().
    UtlBoolean getViaField(UtlString* viaField, int index) const;

    // Retrieves the index-th logical Via: header value, folding together
    // all the Via: headers and parsing ",".
    UtlBoolean getViaFieldSubField(UtlString* viaSubField, int subFieldIndex) const;

    void getLastVia(UtlString* viaAddress,
                    int* viaPort,
                    UtlString* protocol,
                    int* recievedPort = NULL,
                    UtlBoolean* receivedSet = NULL,
                    UtlBoolean* maddrSet = NULL,
                    UtlBoolean* receivedPortSet = NULL) const;

    UtlBoolean removeLastVia();

    void getToField(UtlString* toField) const;

    void getToUri(UtlString* uri) const;

    void getToUrl(Url& url) const;

    void getToAddress(UtlString* toAddress,
                      int* toPort,
                      UtlString* protocol,
                      UtlString* user = NULL,
                      UtlString* userLabel = NULL,
                      UtlString* tag = NULL) const;

    void getCallIdField(UtlString* callId) const;

    void getDialogHandle(UtlString& dialogHandle) const;

    UtlBoolean getCSeqField(int* sequenceNum, UtlString* sequenceMethod) const;

    UtlBoolean getRequireExtension(int extensionIndex, UtlString* extension) const;

    UtlBoolean getProxyRequireExtension(int extensionIndex, UtlString* extension) const;

    void addRequireExtension(const char* extension);

    UtlBoolean getContentEncodingField(UtlString* contentEncodingField) const;

    /// Retrieve the event type, id, and other params from the Event Header
    UtlBoolean getEventField(UtlString* eventType,
                             UtlString* eventId = NULL, //< set to the 'id' parameter value if not NULL
                             UtlHashMap* params = NULL  //< holds parameter name/value pairs if not NULL
                             ) const;

    UtlBoolean getEventField(UtlString& eventField) const;

    void setEventField(const char* eventField);

    UtlBoolean getExpiresField(int* expiresInSeconds) const;

    UtlBoolean getRequestDispositionField(UtlString* dispositionField) const;

    UtlBoolean getRequestDisposition(int tokenIndex,
                                    UtlString* dispositionToken) const;

    UtlBoolean getSessionExpires(int* sessionExpiresSeconds, UtlString* refresher) const;

    void setSessionExpires(int sessionExpiresSeconds);

    UtlBoolean getSupportedField(UtlString& supportedField) const;

    void setSupportedField(const char* supportedField);

    //! Test whether "token" is present in the Supported: header.
    UtlBoolean isInSupportedField(const char* token) const;

    //! Get the SIP-IF-MATCH field from the PUBLISH request
    UtlBoolean getSipIfMatchField(UtlString& sipIfMatchField) const;

    //! Set the SIP-IF-MATCH field for a PUBLISH request
    void setSipIfMatchField(const char* sipIfMatchField);

    //! Get the SIP-ETAG field from the response to a PUBLISH request
    UtlBoolean getSipETagField(UtlString& sipETagField) const;

    //! Set the SIP-ETAG field in a response to the PUBLISH request
    void setSipETagField(const char* sipETagField);

    const UtlString& getLocalIp() const;
    
    void setLocalIp(const UtlString& localIp);

    void setTransportInfo(const SipMessage* pMsg) ;

    //@}

    //! @name SIP Routing header field accessors and manipulators
    //@{
    UtlBoolean getMaxForwards(int& maxForwards) const;

    void setMaxForwards(int maxForwards);

    void decrementMaxForwards();

    UtlBoolean getRecordRouteField(int index,
                                  UtlString* recordRouteField) const;

    UtlBoolean getRecordRouteUri(int index, UtlString* recordRouteUri) const;

    void setRecordRouteField(const char* recordRouteField, int index);

    void addRecordRouteUri(const char* recordRouteUri);

    // isClientMsgStrictRouted returns whether or not a message
    //    is set up such that it requires strict routing.
    //    This is appropriate only when acting as a UAC
    UtlBoolean isClientMsgStrictRouted() const;

    UtlBoolean getRouteField(UtlString* routeField) const;

    UtlBoolean getRouteUri(int index, UtlString* routeUri) const;

    void addRouteUri(const char* routeUri);

    void addLastRouteUri(const char* routeUri);

    UtlBoolean getLastRouteUri(UtlString& routeUri,
                              int& lastIndex);

    UtlBoolean removeRouteUri(int index, UtlString* routeUri);

    void setRouteField(const char* routeField);

    UtlBoolean buildRouteField(UtlString* routeField) const;

    /// Adjust route values as required when receiving at a proxy.
    void normalizeProxyRoutes(const SipUserAgent* sipUA, ///< used to check isMyHostAlias
                              Url& requestUri,           ///< returns normalized request uri
                              UtlSList* removedRoutes = NULL // route headers popped 
                              );
    /**<
     * Check the request URI and the topmost route
     *   - Detect and correct for any strict router upstream
     *     as specified by RFC 3261 section 16.4 Route Information Preprocessing
     *   - Pop off the topmost route until it is not me
     *  
     * If the removedRoutes is non-NULL, then any removed routes are returned
     *   on this list (in the order returned - topmost first) as UtlString objects.
     *   The caller is responsible for deleting these UtlStrings (a call to
     *   removedRoutes->destroyAll will delete them all).
     */

    //@}


    //! @name Call control header field accessors
    //@{
    //! Deprecated
    UtlBoolean getAlsoUri(int index, UtlString* alsoUri) const;
    //! Deprecated
    UtlBoolean getAlsoField(UtlString* alsoField) const;
    //! Deprecated
    void setAlsoField(const char* alsoField);
    //! Deprecated
    void addAlsoUri(const char* alsoUri);

    void setRequestedByField(const char* requestedByUri);

    UtlBoolean getRequestedByField(UtlString& requestedByField) const;

    void setReferToField(const char* referToField);

    UtlBoolean getReferToField(UtlString& referToField) const;

    void setReferredByField(const char* referredByField);

    UtlBoolean getReferredByField(UtlString& referredByField) const;

    UtlBoolean getReferredByUrls(UtlString* referrerUrl = NULL,
                                 UtlString* referredToUrl = NULL) const;

    void setAllowField(const char* referToField);

    UtlBoolean getAllowField(UtlString& referToField) const;

    UtlBoolean getReplacesData(UtlString& callId,
                              UtlString& toTag,
                              UtlString& fromTag) const;

    /// @returns true if the message has either a User-Agent or Server header
    bool hasSelfHeader() const;

    // SERVER-header accessors
    void getServerField(UtlString* serverFieldValue) const;
    void setServerField(const char* serverField);
    void setAcceptField(const char* acceptField);
    void setAuthField(const char* authField);

    // RFC 3326 REASON-header
    void setReasonField(const char* reasonField);

    UtlBoolean getReasonField(UtlString& reasonField) const;

	
    // Diversion-header
    void addDiversionField(const char* addr, const char* reasonParam,
    								UtlBoolean afterOtherDiversions=FALSE);

    void addDiversionField(const char* diversionField, UtlBoolean afterOtherDiversions=FALSE);

	
    UtlBoolean getLastDiversionField(UtlString& diversionField,int& lastIndex);

    UtlBoolean getDiversionField(int index, UtlString& diversionField);

    UtlBoolean getDiversionField(int index, UtlString& addr, UtlString& reasonParam);
	
    //@}

    // This method is needed to cover the symetrical situation which is
    // specific to SIP authorization (i.e. authentication and authorize
    // fields may be in either requests or responses
    UtlBoolean verifyMd5Authorization(const char* userId,
                                      const char* password,
                                      const char* nonce,
                                      const char* realm,
                                      const char* uri = NULL,
                                      enum HttpEndpointEnum authEntity = SERVER) const;

    //! @name DNS SRV state accessors
    /*! \note this will be deprecated
     */
    //@{
        //SDUA
    UtlBoolean getDNSField(UtlString * Protocol,
                          UtlString * Address,
                          UtlString * Port) const;
    void setDNSField( const char* Protocol,
                     const char* Address,
                     const char* Port);

    void clearDNSField();
    //@}


    //! Accessor to store transaction reference
    /*! \note the transaction may be NULL
     */
    void setTransaction(SipTransaction* transaction);

    //! Accessor to get transaction reference
    /*! \note the transaction may be NULL
     */
    SipTransaction* getSipTransaction() const;

    //! Accessor to retrieve any transport string from
    /*! \the to-field.  Also determines if it is a custom transport.
     */
    const UtlString getTransportName(bool& bCustom) const;       

    void setUseShortFieldNames(UtlBoolean bUseShortNames)
        { mbUseShortNames = bUseShortNames; } ; 

    UtlBoolean getUseShortFieldNames() const
        { return mbUseShortNames; } ;

/* ============================ INQUIRY =================================== */

    //! Returns TRUE if this a SIP response
    //! as opposed to a request.
    UtlBoolean isResponse() const;

    //! @ Transaction and session related inquiry methods
    //@{
    UtlBoolean isSameMessage(const SipMessage* message,
                            UtlBoolean responseCodesMustMatch = FALSE) const;

    //! Is message part of a server or client transaction?
    /*! \param isOutgoing - the message is to be sent as opposed to received
     */
    UtlBoolean isServerTransaction(UtlBoolean isOutgoing) const;

    UtlBoolean isSameSession(const SipMessage* message) const;
    static UtlBoolean isSameSession(Url& previousUrl, Url& newUrl);
    UtlBoolean isResponseTo(const SipMessage* message) const;
    UtlBoolean isAckFor(const SipMessage* inviteResponse) const;
    
    //SDUA
    UtlBoolean isInviteFor(const SipMessage* inviteRequest) const;
    UtlBoolean isSameTransaction(const SipMessage* message) const;
    //@}

    //
    UtlBoolean isRequestDispositionSet(const char* dispositionToken) const;

    UtlBoolean isRequireExtensionSet(const char* extension) const;

    //! Is this a header parameter we want to allow users or apps. to
    //  pass through in the URL
    static UtlBoolean isUrlHeaderAllowed(const char*);

    //! Does this header allow multiple values, or only one.
    static UtlBoolean isUrlHeaderUnique(const char*);

    static void parseViaParameters( const char* viaField,
                                    UtlContainer& viaParameterList
                                   );
    // ISmimeNotifySink implementations                               
    void OnError(SIPX_SECURITY_EVENT event, SIPX_SECURITY_CAUSE cause);
    bool OnSignature(void* pCert, char* szSubjAltName);        
    UtlBoolean getFromThisSide() const { return mbFromThisSide; }
    void setFromThisSide(const bool bFromThisSide) { mbFromThisSide = bFromThisSide; }

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    SipTransaction* mpSipTransaction;
    mutable SIPXTACK_SECURITY_ATTRIBUTES* mpSecurity;
    mutable void* mpEventData;
    UtlString mCustomRouteId;

    UtlString mLocalIp;
    UtlBoolean mbFromThisSide;
    UtlBoolean mbUseShortNames;

    //SDUA
    UtlString m_dnsProtocol ;
    UtlString m_dnsAddress ;
    UtlString m_dnsPort ;

    // Class for the singleton object that carries the field properties
    class SipMessageFieldProps
       {
         public:

          SipMessageFieldProps();
          ~SipMessageFieldProps(); 

          UtlHashBag mShortFieldNames;
          UtlHashBag mLongFieldNames;
          // Headers that may not be referenced in a URI header parameter.
          UtlHashBag mDisallowedUrlHeaders;
          // Headers that do not take a list of values.
          UtlHashBag mUniqueUrlHeaders;

          void initNames();
          void initDisallowedUrlHeaders();
          void initUniqueUrlHeaders();
       };

    // Singleton object to carry the field properties.
    static SipMessageFieldProps sSipMessageFieldProps;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipMessage_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SipMessageEvent_h_
#define _SipMessageEvent_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <net/SipMessage.h>
#include <os/OsMsg.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class SipMessageEvent : public OsMsg
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

        enum MessageStatusTypes
        {
                APPLICATION = 0,
                TRANSPORT_ERROR = 1,
        AUTHENTICATION_RETRY,
        SESSION_REINVITE_TIMER,
        TRANSACTION_GARBAGE_COLLECTION,
        TRANSACTION_RESEND,
        TRANSACTION_EXPIRATION
        };

/* ============================ CREATORS ================================== */

   SipMessageEvent(SipMessage* message = NULL, int status = APPLICATION);
     //:Default constructor


   virtual
   ~SipMessageEvent();
     //:Destructor

   virtual OsMsg* createCopy(void) const;
/* ============================ MANIPULATORS ============================== */


/* ============================ ACCESSORS ================================= */
const SipMessage* getMessage();

void setMessageStatus(int status);
int getMessageStatus() const;

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
        SipMessage* sipMessage;
        int messageStatus;

   SipMessageEvent(const SipMessageEvent& rSipMessageEvent);
     //:disable Copy constructor

   SipMessageEvent& operator=(const SipMessageEvent& rhs);
     //:disable Assignment operator

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipMessageEvent_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipMessageList_h_
#define _SipMessageList_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <net/SipMessage.h>
#include <os/OsLockingList.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class SipMessageList
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

    SipMessageList();
    //:Default constructor

    virtual
    ~SipMessageList();
    //:Destructor

/* ============================ MANIPULATORS ============================== */



/* ============================ ACCESSORS ================================= */
    SipMessage* getResponseFor(SipMessage* request);
    SipMessage* getRequestFor(SipMessage* response);
    SipMessage* getDuplicate(SipMessage* message,
      UtlBoolean responseCodesMustMatch = FALSE);
    SipMessage* getAckFor(SipMessage* inviteRequest);
    //SDUA
    SipMessage* getInviteFor(SipMessage* cancelRequest);
    SipMessage* isSameFrom(const Url& fromUrl);
    SipMessage* isSameTo(const Url& toUrl);
    SipMessage* isSameCallId(const UtlString& callId);

    int getListSize();
    int getIterator();
    SipMessage* getSipMessageForIndex( int iteratorHandle );
    void releaseIterator( int iteratorHandle );

    UtlBoolean remove(SipMessage* message);
    void add(SipMessage* message);

    void removeOldMessages(long oldTime, UtlBoolean deleteMessages = TRUE);
    void remove(int iteratorHandle);

    void toString(UtlString& listDumpString);

    void printDebugTable() ;
/* ============================ INQUIRY =================================== */


/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    OsLockingList messageList;

    SipMessageList(const SipMessageList& rSipMessageList);
    //:Copy constructor (disabled)

    SipMessageList& operator=(const SipMessageList& rhs);
    //:Assignment operator (disabled)

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipMessageList_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipNonceDb_h_
#define _SipNonceDb_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include <utl/UtlString.h>
#include <utl/UtlHashBag.h>
#include "os/OsBSem.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class SipNonceDb
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   SipNonceDb();
     //:Default constructor

   virtual
   ~SipNonceDb();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   void createNewNonce(const UtlString& callId, //input
                       const UtlString& fromTag, // input
                       const UtlString& uri, // input
                       const UtlString& realm, // input
                       UtlString& nonce); // output

   void removeOldNonces(long oldTime);

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */

   UtlBoolean isNonceValid(const UtlString& nonce,
                          const UtlString& callId,
                          const UtlString& fromTag,
                          const UtlString& uri,
                          const UtlString& realm,
                          const long expiredTime);

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
   SipNonceDb(const SipNonceDb& rSipNonceDb);
     //:Copy constructor

   SipNonceDb& operator=(const SipNonceDb& rhs);
     //:Assignment operator

   UtlString nonceSignature(const UtlString& callId,
                                                   const UtlString& uri,
                                                   const UtlString& fromTag,
                           const UtlString& realm,
                                                   const UtlString& timestamp
                           );

   UtlHashBag mNonceHash;
   UtlString    mNonceSignatureSecret;

};

/// A shared singleton instance of SipNonceDb.
class SharedNonceDb : public SipNonceDb
{
  public:

   /// Get the singleton shared nonce database.
   static SipNonceDb* get();
   
  private:
   
   static OsBSem*     spLock;
   static SipNonceDb* spSipNonceDb;

   /// Hidden constructor for singleton
   SharedNonceDb();

   /// Hidden destructor
   ~SharedNonceDb();
};


/* ============================ INLINE METHODS ============================ */

#endif  // _SipNonceDb_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipNotifyStateTask_h_
#define _SipNotifyStateTask_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <os/OsServerTask.h>
#include <os/OsDefs.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class SipUserAgent;
class SipMessage;
class CommandSecurityPolicy;
class OsQueuedEvent;
class OsTimer;

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class SipNotifyStateTask : public OsServerTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    static void defaultReboot();

    static void defaultBinaryMessageWaiting(const char* toUrl,
                                      UtlBoolean newMessages);

    static void defaultDetailMessageWaiting(const char* toUrl,
                                      const char* messageMediaType,
                                      UtlBoolean absoluteValues,
                                      int totalNewMessages,
                                      int totalOldMessages,
                                      int totalUntouchedMessages,
                                      int urgentUntouchedMessages,
                                      int totalSkippedMessages,
                                      int urgentSkippedMessages,
                                      int totalFlaggedMessages,
                                      int urgentFlaggedMessages,
                                      int totalReadMessages,
                                      int urgentReadMessages,
                                      int totalAnsweredMessages,
                                      int urgentAnsweredMessages,
                                      int totalDeletedMessages,
                                      int urgentDeletedMessages);
    // totalNewMessages and totalOldMessages are summary totals
    //      accross all other categories.
    //! param: messageMediaType = "Voicemail", "Email", "Fax", "Video", etc
    //! param: absoluteValues - the message counts are absolute counts (TRUE) or deltas (FALSE)
    // If these are absolute values negative number for a message count means unspecified
    // If these are deltas there is know way to know if the values are not set


/* ============================ CREATORS ================================== */

   SipNotifyStateTask(const UtlString& checkSyncPolicy, SipUserAgent* pSipUserAgent = NULL);
     //:Default constructor

   virtual
   ~SipNotifyStateTask();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

   virtual UtlBoolean handleMessage(OsMsg& eventMessage);   

/* ============================ ACCESSORS ================================= */

   void setRebootFunction(void (*rebootNotifyFunction)());

   void setBinaryMessageWaitingFunction(void (*binaryMessageWaitingFunc)(
                                        const char* toUrl,
                                        UtlBoolean newMessages));

   void setDetailMessageWaitingFunction(void (*requestProcessor)(
                                      const char* toUrl,
                                      const char* messageMediaType,
                                      UtlBoolean absoluteValues,
                                      int totalNewMessages,
                                      int totalOldMessages,
                                      int totalUntouchedMessages,
                                      int urgentUntouchedMessages,
                                      int totalSkippedMessages,
                                      int urgentSkippedMessages,
                                      int totalFlaggedMessages,
                                      int urgentFlaggedMessages,
                                      int totalReadMessages,
                                      int urgentReadMessages,
                                      int totalAnsweredMessages,
                                      int urgentAnsweredMessages,
                                      int totalDeletedMessages,
                                      int urgentDeletedMessages));

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

   OsStatus handleCheckSyncEvent(const SipMessage* source) ;

   UtlBoolean scheduleRunScript(UtlString* pContent, 
                               CommandSecurityPolicy *pPolicy, 
                               int seconds) ;

   OsStatus doRunScript(UtlString* pContent, 
                        CommandSecurityPolicy *pPolicy) ;

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    SipUserAgent*  mpSipUserAgent;
    UtlString       mCheckSyncPolicy ;  // policy for handling check-sync events
    OsQueuedEvent* mpRunScriptEvent ;  // queued event for scripts (if phone is busy)
    OsTimer*       mpRunScriptTimer ;  // timer for scripts (if phone is busy)

    void(*mpRebootFunction)();

    void(*mpBinaryMessageWaitingFunction)(const char* toUrl,
                                        UtlBoolean newMessages);

    void(*mpDetailedMessageWaitingFunction)(
                                      const char* toUrl,
                                      const char* messageMediaType,
                                      UtlBoolean absoluteValues,
                                      int totalNewMessages,
                                      int totalOldMessages,
                                      int totalUntouchedMessages,
                                      int urgentUntouchedMessages,
                                      int totalSkippedMessages,
                                      int urgentSkippedMessages,
                                      int totalFlaggedMessages,
                                      int urgentFlaggedMessages,
                                      int totalReadMessages,
                                      int urgentReadMessages,
                                      int totalAnsweredMessages,
                                      int urgentAnsweredMessages,
                                      int totalDeletedMessages,
                                      int urgentDeletedMessages);

    UtlBoolean getStatusTotalUrgent(const char* status, 
                                 UtlBoolean absoluteValues,
                                 int parameterIndex,
                                 int& total, 
                                 int& urgent);

   SipNotifyStateTask(const SipNotifyStateTask& rSipNotifyStateTask);
     //:Copy constructor (disabled)

   SipNotifyStateTask& operator=(const SipNotifyStateTask& rhs);
     //:Assignment operator (disabled)

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipNotifyStateTask_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipObserverCriteria_h_
#define _SipObserverCriteria_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <os/OsMsgQ.h>


// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class SipSession;

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class SipObserverCriteria : public UtlString
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   SipObserverCriteria(void* observerData = NULL,
                      OsMsgQ* messageQueue = NULL,
                      const char* sipMethod = NULL,
                      UtlBoolean wantRequests = TRUE,
                      UtlBoolean wantResponses = TRUE,
                      UtlBoolean wantIncoming = TRUE,
                      UtlBoolean wantOutGoing = TRUE,
                      const char* eventName = NULL,
                      SipSession* pSession = NULL);
     //:Default constructor

   virtual
   ~SipObserverCriteria();
     //:Destructor

/* ============================ MANIPULATORS ============================== */


/* ============================ ACCESSORS ================================= */

   OsMsgQ* getObserverQueue();
   void* getObserverData();
   void getEventName(UtlString& eventName);
   SipSession* getSession();

/* ============================ INQUIRY =================================== */

   UtlBoolean wantsRequests();
   UtlBoolean wantsResponses();
   UtlBoolean wantsIncoming();
   UtlBoolean wantsOutGoing();

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

   void* mObserverData;
   UtlBoolean mWantsRequests;
   UtlBoolean mWantsResponses;
   UtlBoolean mWantsIncoming;
   UtlBoolean mWantsOutGoing;
   OsMsgQ* mpMessageObserverQueue;
   UtlString mEventName;
   SipSession* mpSession ;

   SipObserverCriteria& operator=(const SipObserverCriteria& rhs);
     //:Assignment operator (not implemented)

   SipObserverCriteria(const SipObserverCriteria& rSipObserverCriteria);
     //:Copy constructor (not implemented)

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipObserverCriteria_h_
//
// Copyright (C) 2005 SIPez LLC.
// Licensed to SIPfoundry under a Contributor Agreement.
// 
// Copyright (C) 2004 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
//////////////////////////////////////////////////////////////////////////////
// Author: Daniel Petrie (dpetrie AT SIPez DOTcom)


#ifndef _SipPimClient_h_
#define _SipPimClient_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <os/OsServerTask.h>
#include <utl/UtlString.h>
#include <net/Url.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class SipUserAgent;
class SipMessage;

// Author: Daniel Petrie
//         dgpetrie AT yahoo DOT com
//
//! Client for SIP Presence and Instant Messaging
/*! This client provides interfaces for publishing
 * the current presence state of an entity or AOR.
 * It also provides a basic client for sending
 * pager style instant messages.  That is non-session
 * based messages using the MESSAGE request.  Note
 * that a user interface can provide a session base
 * end user experience using a non-session based
 * messages.
 * 
 *
 * \par Presence State
 * The setPresenceState method can be sued to set the
 * current presence state for the presence AOR.  Setting
 * the state to a different value implies that a PUBLISH
 * request is sent to update the presence state.
 *
 * \par Instant Message
 * A sessionless instant message is sent using the sendPagerMessage
 * method.
 *
 */

class SipPimClient : public OsServerTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    typedef enum 
    {
        invalid = -1,
        closed,
        open
    } SipxRpidStates;

    typedef void (*MessageCallback)(void* userData, const UtlString& fromAddress, const char* textMessage, int textLength, const char* subject, const SipMessage& messageRequest);
/* ============================ CREATORS ================================== */

    //! Constructor
    /*! Construct and bind AOR and user agent for Presence and IM client.
     * \param userAgent - user agent to send requests and receive reponses
     * \param presentityAor - the entity whose presence state is to be
     * published.  This is also the From nameAddr used for instant
     * messages sent.
     */
    SipPimClient(SipUserAgent& userAgent, Url& presentityAor);

    //! Destructor
    virtual
    ~SipPimClient();

/* ============================ MANIPULATORS ============================== */

    //! Set the Private key and Certificate for the local side
    /*! 
     *   \param localPkcs12DerKeyCert DER format PKCS12 container for 
     *          private key and certificate for the local side.
     *   \param localPkcs12DerKeyCertLength the length of localPkcs12DerKeyCert
     *          in bytes
     *   \param sPkcs12Password password (symmetric key) to decrypt the 
     *          PKCS12 container/wrapper.
     */
    void setLocalKeyCert(const char* localPkcs12DerKeyCert,
                         int localPkcs12DerKeyCertLength,
                         const char* sPkcs12Password);

    //! Set the certificate containing the public key for the remote side
    /*! Setting the remote certificate enable encryption of IM messages
     *  to the other side.
     *  \param derFormatCertificate - DER format certificate
     *  \param derFormatCertificateLength - length of the certificate
     */
    void setRemoteCertificate(const char* derFormatCertificate,
                              int derFormatCertificateLength);

    //! Send a pager style instant message to the given destination
    /*! Send a non-session based instant message using the
     * MESSAGE method.
     *
     * \param destinationAor - destination to send the IM to.
     * \param messageText - text of the message to send in the IM
     * \param responseCode - the response code from the request to sent the text
     * \param responseCodeText - the response code text from the top header line
     */
    UtlBoolean sendPagerMessage(Url& destinationAor, 
                                const char* messageText, const char* subject,
                                int& responseCode,
                                UtlString& responseCodeText);

    //! Set callback function for incoming pager mode text messages 
    /*! Set the function to be called if there are incoming MESSAGE
     * requests with text bodies.  Note: the SipPimClient task MUST
     * be started up for the callback to get invoked.
     * \param textHandler - callback function with the following arguments:
     * \param fromAddress - the from field from the request
     * \param textMessage - the text message from the request body
     * \param messageRequest - the MESSAGE request
     */
    void setIncomingImTextHandler(MessageCallback callback, void* userData);

    //! Update the presence state of the presentity indicate 
    /*! Send a PUBLISH request to update the RPID document with the
     * given presence state.  If the current state is the same
     * the presence state document is not updated.
     *
     * \param newState - the new RPID presence state to be published.
     */
    UtlBoolean updatePresenceState(SipxRpidStates newState);

    //! Handler for incoming SIP messages
    /*! This consumes SIP messages and dispatched them to the
     * callbacks.
     */
    UtlBoolean handleMessage(OsMsg& eventMessage);

/* ============================ ACCESSORS ================================= */


/* ============================ INQUIRY =================================== */


/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

    //! Call Id generator for SipPimClient
    void getNextCallId(UtlString& callId);

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:


    //! Disabled copy constructor
    SipPimClient(const SipPimClient& rSipPimClient);

    //! Disabled assignment operator
    SipPimClient& operator=(const SipPimClient& rhs);

    int mCallIdIndex;
    Url mPresentityAor;
    UtlString mFromField;
    SipUserAgent* mpUserAgent;

    MessageCallback mpTextHandlerFunction;
    void* mpTextHandlerUserData;

    UtlString mPkcs12KeyCertContainer;
    UtlString mPkcs12Password;
    UtlString mDerRemoteCertificate;

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipPimClient_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SipPresenceEvent_h_
#define _SipPresenceEvent_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include <utl/UtlHashMap.h>
#include <net/HttpBody.h>
#include <net/Url.h>
#include <os/OsDateTime.h>
#include <os/OsBSem.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS

#define PRESENCE_EVENT_CONTENT_TYPE "application/pidf+xml"
#define PRESENCE_EVENT_TYPE "presence"

#define BEGIN_PRESENCE "<presence xmlns=\"urn:ietf:params:xml:ns:pidf\""
#define END_PRESENCE "</presence>\n"

#define PRESENTITY_EQUAL " entity="

#define BEGIN_TUPLE "<tuple id="
#define END_TUPLE "</tuple>\n"

#define BEGIN_STATUS "<status>\n"
#define END_STATUS "</status>\n"

#define BEGIN_BASIC "<basic>"
#define END_BASIC "</basic>\n"

#define BEGIN_CONTACT "<contact>"
#define END_CONTACT "</contact>\n"


#define STATUS_OPEN "open"
#define STATUS_CLOSED "closed"

// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//! Container for tuple element in the presence event package
/**
 * This class contains all the contents presented in a tuple element of the
 * presence information data format described in RFC 3863. This class has the
 * methods to construct and manipulate the tuple and its sub-elements.
 */

class Tuple : public UtlContainable
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

/** 
 * @name ====================== Constructors and Destructors
 * @{
 */
   /// Constructor
   Tuple(const char* tupleId);

   /// Copy constructor
   Tuple(const Tuple& rTuple);

   /// Destructor
   ~Tuple();

   virtual UtlContainableType getContainableType() const;

   static const UtlContainableType TYPE;

   virtual unsigned int hash() const;

   int compareTo(const UtlContainable *b) const;

///@}
   
/**
 * @name ====================== Tuple Setting Interfaces
 *
 * These methods set/get the tuple element and sub-elements.
 *
 * @{
 */

   void setTupleId(const char* tupleId);

   void getTupleId(UtlString& tupleId) const;

   void setStatus(const char* status);

   void getStatus(UtlString& state) const;

   void setContact(const char* url, const float priority);

   void getContact(UtlString& url, float& priority) const;

///@}
   
/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:
   
/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:

   // Variables for tuple element
   UtlString mId;

   // Variables for status element
   UtlString mStatus;

   // Variables for contact element
   UtlString mContactUrl;
   float mPriority;

   //Assignment operator
   Tuple& operator=(const Tuple& rhs);
};


//! Container for MIME type application/pidf+xml.
/**
 * This class contains all the contents presented in a presence event package
 * described in RFC 3863. This class has the methods to construct and
 * manipulate the presence events in a presence event package.
 */
class SipPresenceEvent : public HttpBody
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

/** 
 * @name ====================== Constructors and Destructors
 * @{
 */
   //! Construct an empty package or one from an existing presence event package in the xml format
   SipPresenceEvent(const char* entity, const char* bodyBytes = NULL);

   //! Destructor that will free up the memory allocated for presence contents if it is not being deleted
   virtual
      ~SipPresenceEvent();

///@}
   
/**
 * @name ====================== Presence Event Serialization Interfaces
 *
 * @{
 */

   //! Build the body of this object
   void buildBody() const;

   //! Get the string length of this object
   virtual int getLength() const;

   //! Get the serialized char representation of this presence event.
   /*! \param bytes - buffer space where the presence event is written, null
    *       terminated.
    *  \param length - the number of bytes written (not including the
    *       null terminator).
    */
   virtual void getBytes(const char** bytes,
                         int* length) const;

   //! Get the serialized string representation of this presence event.
   /*! \param bytes - buffer space where the presence event is written, null
    *       terminated.
    *  \param length - the number of bytes written (not including the
    *       null terminator).
    */
   virtual void getBytes(UtlString* bytes,
                         int* length) const;

///@}

/**
 * @name ====================== Tuple Setting Interfaces
 *
 * These methods set/get the tuple element.
 *
 * @{
 */

   //! Insert a Tuple object to the hash table.
   void insertTuple(Tuple* tuple);

   //! Get the Tuple object based on the tupleId.
   Tuple* getTuple(UtlString& tupleId);
   
   //! Remove the Tuple object.
   Tuple* removeTuple(Tuple* tuple);
   
   //! Check whether there is any Tuple or not
   UtlBoolean isEmpty();

///@}
   
/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:
   
   /// Parse an existing tuple event package from xml format into the internal representation.
   void parseBody(const char* bytes);


/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:

   //! Variables for presence
   UtlString mEntity;

   //! Variables for tuple element
   UtlHashMap mTuples;

    //! reader/writer lock for synchronization
    OsBSem mLock;

   //! Disabled copy constructor
   SipPresenceEvent(const SipPresenceEvent& rSipPresenceEvent);

   //! Disabled assignment operator
   SipPresenceEvent& operator=(const SipPresenceEvent& rhs);

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipPresenceEvent_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipProtocolServerBase_h_
#define _SipProtocolServerBase_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <net/SipClient.h>
#include <os/OsServerSocket.h>
#include <os/OsTask.h>
#include <os/OsServerTask.h>
#include <os/OsLockingList.h>
#include <os/OsRWMutex.h>
#include <utl/UtlHashMap.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class SipUserAgent;
class SipServerBrokerListener;

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class SipProtocolServerBase : public OsTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   SipProtocolServerBase(SipUserAgent* userAgent,
                         const char* protocolString,
                         const char* taskName);
     //:Default constructor


   virtual
   ~SipProtocolServerBase();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

    virtual UtlBoolean startListener();

    virtual void shutdownListener() = 0;


    UtlBoolean send(SipMessage* message, const char* hostAddress,
            int hostPort = SIP_PORT);

    virtual int run(void* pArg) = 0;

    void removeOldClients(long oldTime);

/* ============================ ACCESSORS ================================= */

    int getClientCount();

    virtual void printStatus();

    virtual UtlBoolean isOk();

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    friend class SipServerBrokerListener;

    SipClient* createClient(const char* hostAddress,
                            int hostPort,
                            const char* localIp);

    void releaseClient(SipClient* client);

    void startClients();

    void shutdownClients();

    UtlBoolean clientExists(SipClient* client);

    void addClient(SipClient* client);

    virtual OsSocket* buildClientSocket(int hostPort, const char* hostAddress, const char* localIp) = 0;

    UtlString mProtocolString;
    UtlString mDefaultIp;
    int mDefaultPort;
    SipUserAgent* mSipUserAgent;
    UtlHashMap mServerSocketMap;
    UtlHashMap mServerPortMap;
    UtlHashMap mServers;
    SipServerBrokerListener* mpServerBrokerListener;
    


/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    UtlBoolean waitForClientToWrite(SipClient* client);

    SipClient* getClient(const char* hostAddress,
                         int hostPort,
                         const char* localIp);

    void deleteClient(SipClient* client);

        OsRWMutex mClientLock;
    OsLockingList mClientList;

        SipProtocolServerBase(const SipProtocolServerBase& rSipProtocolServerBase);
        //: disable Copy constructor

   SipProtocolServerBase& operator=(const SipProtocolServerBase& rhs);
     //:disable Assignment operator

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipProtocolServerBase_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////
// Author: Dan Petrie (dpetrie AT SIPez DOT com)

#ifndef _SipPublishContentMgr_h_
#define _SipPublishContentMgr_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES

#include <os/OsDefs.h>
#include <os/OsMutex.h>
#include <utl/UtlDefs.h>
#include <utl/UtlHashMap.h>
#include <utl/UtlContainableAtomic.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// FORWARD DECLARATIONS
class HttpBody;
class UtlString;
class SipPublishContentMgrDefaultConstructor;

// TYPEDEFS

/** Class for managing body content to be accepted via PUBLISH or provided in NOTIFY requests
 *
 *  This class is a database that is used to store and retrieve
 *  content (i.e. SIP Event state bodies).  This class does not
 *  actually touch or process SIP messages.  It is used by other
 *  classes and applications to store and retrieve content related to
 *  SIP SUBSCRIBE, NOTIFY and PUBLISH requests.  The usual usage is to
 *  have one instance that maintains state for an unlimited number of
 *  resources and event types.
 *
 *  The resourceId and eventTypeKey have no semantics.  Syntactically,
 *  they are restricted only by:  (1) resourceId may not be the null
 *  string, and (2) eventTypeKey may not contain a byte with the value
 *  1 (control-A), so that the concatenation of resourceId and
 *  eventTypeKey can be split unambiguously.
 *
 *  It is up to the application or event package to decide what the 
 *  resourceId and eventTypeKey look like.  In addition, there is an
 *  eventType that may provide a coarser classification than
 *  eventTypeKey.  Callback functions are registered for eventTypes
 *  rather than eventTypeKeys, so the set of eventTypeKeys is not
 *  limited at compile time.
 *  
 *  A suggested convention for the resourceId
 *  is to use:  <userId>@<hostname>[:port] as provided in the
 *  SUBSCRIBE or PUBLISH request URI.  It is suggested that host be
 *  the domainname not the specific IP address.
 *
 *  It is also suggested the SIP event type token be used (without any
 *  event header parameters) as the eventTypeKey.  Only in special
 *  cases where the content varies based upon an event parameter,
 *  should the parameter(s) be include included in the eventTypeKey.
 *  Usually, eventType is the same as eventTypeKey, or is the
 *  SIP event type alone, if eventTypeKey contains parameters.
 *
 * \par Put Event State In
 *  Applications put Event state information for a specific resourceId
 *  and eventTypeKey into the SipPublishContentMgr via the publish method.
 *
 * \par Retrieve Event State
 *  Applications retrieve published content type via the getContent
 *  method.
 *
 * \par Remove Event State
 * All event state information for a resource Id and event type key can
 * can be removed via the unpublish method.  The content associated
 * with the keys is passed back so the application can destroy the
 * content.
 *
 * \par Default Event State
 * It is possible to define a default event state for an event type key.
 * This default content is provided in the getContent method if no
 * content was provided for the specific resource Id.  Default content
 * is set via the publishDefault method.
 */
class SipPublishContentMgr
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    /** Callback used to notify interested applications when content has changed
     *  Well behaved applications that register and implement this function
     *  should not block.  They should quickly return as failure to do so
     *  may hinder timely processing and system performance.  The memory
     *  for the content provided in the arguments should not be presumed to
     *  exist beyond the point where the application returns from this function.
     *
     *  /param applicationData - provided with the callback function pointer
     *  when it was registered.
     *  The rest of the arguments in this callback have the same meaning as 
     *  the getContent method.
     */
    typedef void (*SipPublisherContentChangeCallback) (void* applicationData,
                                                       const char* resourceId,
                                                       const char* eventTypeKey,
                                                       const char* eventType,
                                                       UtlBoolean isDefaultContent);

/* ============================ CREATORS ================================== */

    /// Default publish container constructor
    SipPublishContentMgr();


    /// Destructor
    virtual
    ~SipPublishContentMgr();


/* ============================ MANIPULATORS ============================== */

    /** Provide the default content for the given event type key
     *
     *  \param eventTypeKey - a unique id for the event type, typically the
     *         SIP Event type token.  Usually this does not contain any of
     *         the SIP Event header parameters.  However it may contain 
     *         event header parameters if the parameter identifies different
     *         content.  If event parameters are included, they must be in
     *         a consistent order for all uses of eventTypeKey in this class.
     *         There is no semantics enforced.  This is an opaque string used 
     *         as part of the key.
     *  \param eventType - SIP event type token
     *  \param numContentTypes - the number of bodies (each having a unique
     *         content type) provided in the eventContent array.  Multiple
     *         content types are published if the server wants to deliver
     *         different content types based upon the SUBSCRIBE Accepts
     *         header content types listed.
     *  \param eventContent - the SIP Event state content which was provided
     *         via a PUBLISH or requested via a SUBSCRIBE to be delivered
     *         via a NOTIFY.  If multiple bodies are provided and the content 
     *         types match more than one of the mime types provided in the
     *         SUBSCRIBE Accepts header, the order of the bodies in the
     *         eventContent array indicates a preference.  The bodies are
     *         NOT copied, but their memory becomes owned by the
     *         SipPublishContentMgr object and will be deleted by it when
     *         they are no longer needed.
     */
    virtual void publishDefault(const char* eventTypeKey,
                                      const char* eventType,
                                      int numContentTypes,
                                HttpBody* eventContent[]);

    /** Add a default content constructor function.
     *
     *  \param *defaultConstructor becomes owned by the SipPublishContentMgr,
     *         which will delete it when it is no longer needed.
     */
    virtual void publishDefault(const char* eventTypeKey,
                                        const char* eventType,
                                SipPublishContentMgrDefaultConstructor*
                                defaultConstructor);

    /** Remove the default content and default content constructor for
     *  eventTypeKey.
     */
    virtual void unpublishDefault(const char* eventTypeKey,
                                  const char* eventType);

    /** Provide the given content for the resource and event type key
     *  An application provides content (i.e. SIP event state bodies)
     *  through this interface for the given resourceId and eventTypeKey.
     *  The resourceId and eventTypeKey together compose a unique key which
     * identifies the provided content.  The resourceId is optained from
     * the PUBLISH or SUBSCRIBE request URI.  The eventTypeKey is obtained
     * from the SIP Event header field.
     *  \param resourceId - a unique id for the resource, typically the
     *         identity or AOR for the event type content.  There is no
     *         semantics enforced.  This is an opaque string used as part
     *         of the key.
     *  \param eventTypeKey - a unique id for the event type, typically the
     *         SIP Event type token.  Usually this does not contain any of
     *         the SIP Event header parameters.  However it may contain 
     *         event header parameters if the parameter identifies different
     *         content.  If event parameters are included, they must be in
     *         a consistent order for all uses of eventTypeKey in this class.
     *         There is no semantics enforced.  This is an opaque string used 
     *         as part of the key.
     *  \param eventType - SIP event type token
     *  \param numContentTypes - the number of bodies (each having a unique
     *         content type) provided in the eventContent array.  Multiple
     *         content types are published if the server wants to deliver
     *         different content types based upon the SUBSCRIBE Accepts
     *         header content types listed.
     *  \param eventContent - the SIP Event state content which was provided
     *         via a PUBLISH or requested via a SUBSCRIBE to be delivered
     *         via a NOTIFY.  If multiple bodies are provided and the content 
     *         types match more than one of the mime types provided in the
     *         SUBSCRIBE Accepts header, the order of the bodies in the
     *         eventContent array indicates a preference.  The bodies are
     *         NOT copied, but their memory becomes owned by the
     *         SipPublishContentMgr object and will be deleted by it when
     *         they are no longer needed.
     *  \param noNotify - if TRUE, do not generate any NOTIFYs for this content
     *         change.  This should only be used in generateDefaultContent
     *         methods.
     */
    virtual void publish(const char* resourceId,
                               const char* eventTypeKey,
                               const char* eventType,
                               int numContentTypes,
                               HttpBody* eventContent[],
                         UtlBoolean noNotify = FALSE);

    /** Remove the content for the given resourceId and eventTypeKey
     *  The content bodies are given back so that the application can
     *  release or delete the bodies.
     *  \param resourceId - a unique id for the resource, typically the
     *         identity or AOR for the event type content.  There is no
     *         semantics enforced.  This is an opaque string used as part
     *         of the key.
     *  \param eventTypeKey - a unique id for the event type, typically the
     *         SIP Event type token.  Usually this does not contain any of
     *         the SIP Event header parameters.  However it may contain 
     *         event header parameters if the parameter identifies different
     *         content.  If event parameters are included, they must be in
     *         a consistent order for all uses of eventTypeKey in this class.
     *         There is no semantics enforced.  This is an opaque string used 
     *         as part of the key.
     *  \param eventType - SIP event type token
     */
    virtual void unpublish(const char* resourceId,
                                const char* eventTypeKey,
                           const char* eventType);

    /** Fetch the published content for a given resourceId/eventTypeKey.
     *  The content body pointers point to copies of the stored
     *  bodies, and the caller is responsible for deleting them.
     *  Returns TRUE unless maxContentTypes is too small to hold the
     *  published content versions.
     *  \param resourceId - a unique id for the resource, or NULL
     *         to retrieve the default content for the eventTypeKey.
     *  \param eventTypeKey - the unique id for the event type.
     *  \param eventType - SIP event type token
     *  \param maxContentTypes - the size of the provided
     *         eventContent array.
     *  \param numContentTypes - upon return, *numContentType is set
     *         to the number of bodies (each having a unique
     *         content type) set in the eventContent array.
     *  \param eventContent - the SIP Event state content.
     *  \param pDefaultConstructor - if not NULL, *pDefaultConstructor
     *         is set to point to a copy of the defaultConstructor for
     *         eventTypeKey (if one is set), or NULL.
     */
    virtual UtlBoolean getPublished(const char* resourceId,
                                    const char* eventTypeKey,
                                    int maxContentTypes,
                                    int& numContentTypes,
                                    HttpBody* eventContent[],
                                    SipPublishContentMgrDefaultConstructor**
                                    defaultConstructor);

    /** Get the content for the given resourceId, eventTypeKey and contentTypes
     *  Retrieves the content type identified by the resourceID and eventTypeKey.
     *  The given contentTypes indicates what content types are accepted (i.e.
     *  the mime types from the SUBSCRIBE Accept header).
     *  \param resourceId - a unique id for the resource, typically the
     *         identity or AOR for the event type content.  There is no
     *         semantics enforced.  This is an opaque string used as part
     *         of the key.
     *  \param eventTypeKey - a unique id for the event type, typically the
     *         SIP Event type token.  Usually this does not contain any of
     *         the SIP Event header parameters.  However it may contain 
     *         event header parameters if the parameter identifies different
     *         content.  If event parameters are included, they must be in
     *         a consistent order for all uses of eventTypeKey in this class.
     *         There is no semantics enforced.  This is an opaque string used 
     *         as part of the key.
     *  \param eventType - SIP event type token
     *  \param acceptHeaderValue - the mime types allowed to be returned in 
     *         the content argument.  The first match is the one returned.
     *         This string has the same syntax/format as the SIP Accept header.
     *  \param content - the content body if a match was found, otherwise NULL.
     *         The content body is a copy that must be freed.
     *  \param isDefaultContent - if there was no content specific to the resourceId
     *         and default content was provided for the given eventTypeKey,
     *         then isDefaultContent is set to TRUE and 'content' contains
     *         values from the eventTypeKey content default.
     */
    virtual UtlBoolean getContent(const char* resourceId,
                                  const char* eventTypeKey,
                                  const char* eventType,
                                  const char* acceptHeaderValue,
                                  HttpBody*& content,
                                  UtlBoolean& isDefaultContent);

    /** Set the callback which gets invoked whenever the content changes
     *  Currently only one observer is allowed per eventTypeKey.  If
     *  a subsequent observer is set for the same eventTypeKey, it replaces
     *  the existing one.  The arguments of the callback function have
     *  the same meaning as getContent.
     *  Note: the callback is invoked when the default content changes as well.
     *  When the default content for an eventTypeKey changes, the
     *  resourceId is NULL.  The application is responsible for knowing
     *  which resources do not have specific content (i.e. are observing
     *  the default content and may need to be notified).
     *  \param eventTypeKey - SIP event type key
     *  \param applicationData - application specific data that is to be
     *         passed back to the application in the callback function.
     *  Returns TRUE if the callback is set for the eventTypeKey.  Will
     *  not set the callback if it is already set for the given eventTypeKey
     */
    virtual UtlBoolean setContentChangeObserver(const char* eventType,
                                                void* applicationData,
                             SipPublisherContentChangeCallback callbackFunction);

    /** Remove the current observer for the eventTypeKey
     *  If the given callbackFunction does not match the existing one,
     *  this method returns FALSE and the existing observer(s) remain.
     */
    virtual UtlBoolean removeContentChangeObserver(const char* eventType,
                                                   void*& applicationData,
                            SipPublisherContentChangeCallback& callbackFunction);


/* ============================ ACCESSORS ================================= */

    /// Get some debug information
    void getStats(int& numDefaultContent,
                  int& numDefaultConstructor,
                    int& numResourceSpecificContent,
                    int& numCallbacksRegistered);

/* ============================ INQUIRY =================================== */


/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    /// parse the accept header field and create a HashMap with a UtlString for each MIME type
    UtlBoolean buildContentTypesContainer(const char* acceptHeaderValue, 
                                          UtlHashMap& contentTypes);

    /// Copy constructor NOT ALLOWED
    SipPublishContentMgr(const SipPublishContentMgr& rSipPublishContentMgr);

    /// Assignment operator NOT ALLOWED
    SipPublishContentMgr& operator=(const SipPublishContentMgr& rhs);

    /// lock for single thread use
    void lock();

    /// unlock for use
    void unlock();

    OsMutex mPublishMgrMutex;
    // Indexed by strings "resourceId\001eventTypeKey".
    UtlHashMap mContentEntries; 
    // Indexed by strings "\001eventTypeKey".
    UtlHashMap mDefaultContentEntries;
    UtlHashMap mDefaultContentConstructors;
    // Indexed by strings "eventType".
    UtlHashMap mEventContentCallbacks;
};

/**
 * Helper class for SipPublishContentMgr.
 *
 * Each instance is a device for producing default content for a
 * resource/event-type when generateDefaultContent is set but there is no
 * content for the resource/event-type.
 *
 * SipPublicContentMgrDefaultConstructor is pure virtual.  Instances
 * can only be created of subclasses that provide a getContent()
 * method.
 */
class SipPublishContentMgrDefaultConstructor : public UtlContainableAtomic
{
  public:

   /** Generate the content for a resource and event.
    *  Called when getContent is called for a resourceId/eventTypeKey
    *  that has no published content.  generateDefaultContent may set
    *  content for that combination, or it can do nothing, which
    *  forces getContent to use the default content (if any) for that
    *  eventTypeKey.  If generateDefaultContent calls
    *  contentMgr->publish(), it must provide noNotify = TRUE, because
    *  the caller will generate NOTIFYs for this content.
    */
   void virtual generateDefaultContent(SipPublishContentMgr* contentMgr,
                                       const char* resourceId,
                                       const char* eventTypeKey,
                                       const char* eventType) = 0;

   /// Make a copy of this object according to its real type.
   virtual SipPublishContentMgrDefaultConstructor* copy() = 0;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipPublishContentMgr_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SipPublishServer_h_
#define _SipPublishServer_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include <os/OsServerTask.h>
#include <os/OsDefs.h>
#include <os/OsRWMutex.h>
#include <utl/UtlString.h>
#include <utl/UtlHashMap.h>
#include <net/SipUserAgent.h>


// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// FORWARD DECLARATIONS
class SipPublishServerEventStateCompositor;
class SipUserAgent;
class SipPublishServerEventStateMgr;
class OsMsg;
class SipMessage;


// TYPEDEFS


//! Top level class for accepting and processing PUBLISH requests
/*! This implements a generic RFC 3903 PUBLISH server.  This class
 *  receives PUBLISH requests, passes the event content to the event
 *  state compositor class, and send back the appropriate response.
 *  The SipPublishServer is designed to handle several different event
 *  types so that you can have multiple instances of the SipPublishServer
 *  each handling different event type.  However you can not have an
 *  event type that is handled by more than one SipPublishServer.
 *
 *  \par Event Specific Handling and Processing
 *  Event types are enabled with the enableEventType method.  This method
 *  handling and processing of the specified Event type to be specialized
 *  by providing an Event specific: SipEventPlugin and SipUserAgent.
 *
 *  \par Event State Compositor
 *
 *  \par Event State
 *  The SipPublishServerEventStateMgr is used by SipPublishServer to maintain
 *  the event state (PUBLISH event state not event state content).
 *
 *  \par Overall Data Flow
 *  The SipPublishServer needs to address 2 general stimulus:
 *  1) Respond to incoming PUBLISH requests.
 *  2) Some notification error responses should cause the subscription to expire
 *
 *  When enabling a SIP event type via the enableEventType method, the SipPublishServer
 *  registers with the SipUserAgent to receive PUBLISH requests 
 *  for the event type which are processed by the handleMessage method.
 *  The SipPublishServer uses timers to keep track of when event publication expire. 
 *  When a timer fires, a message gets queued on the SipPublishServer which is that
 *  passed to handleMessage.
 */
 
class SipPublishServer : public OsServerTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:


/* ============================ CREATORS ================================== */

    //! Helper utility to build a basic server with default behavior
    static SipPublishServer* buildBasicServer(SipUserAgent& userAgent,
                                              const char* eventType);

    //! Default SipPublishServer constructor
    SipPublishServer(SipUserAgent& defaultUserAgent,
                     SipPublishServerEventStateMgr& defaultEventStateMgr,
                     SipPublishServerEventStateCompositor& defaultCompositor);


    //! Destructor
    virtual
    ~SipPublishServer();


/* ============================ MANIPULATORS ============================== */

    //! Tell the publish server to support given event type
    UtlBoolean enableEventType(const char* eventType,
                               SipUserAgent* userAgent = NULL,
                               SipPublishServerEventStateMgr* eventStateMgr = NULL,
                               SipPublishServerEventStateCompositor* compositor = NULL);

    //! Tell the publish server to stop supporting given event type
    UtlBoolean disableEventType(const char* eventType,
                                SipUserAgent*& userAgent,
                                SipPublishServerEventStateMgr*& eventStateMgr,
                                SipPublishServerEventStateCompositor*& compositor);

    //! Handler for PUBLISH requests and timers
    UtlBoolean handleMessage(OsMsg &eventMessage);

/* ============================ ACCESSORS ================================= */

    //! Get the event state compositor for the given eventType
    /*! WARNING: there is no locking of the event state compositor once it is
     *  returned.  If the eventStateCompositor is removed via disableEventType
     *  and destroyed, there is no locking protection.  The eventStateCompositor
     *  is only safe to use if the application knows that it is not going
     *  to get the rug pulled out from under it.  Returns the default
     *  event state compositor if there is not an event specific state compositor.
     */
    SipPublishServerEventStateCompositor* 
        getEventStateCompositor(const UtlString& eventType);

    //! Get the event state manager for the given event type
    /*! WARNING: there is no locking of the event state manager once it is
     *  returned.  If the event state manager is removed via disableEventType
     *  and destroyed, there is no locking protection.  The event state manager
     *  is only safe to use if the application knows that it is not going
     *  to get the rug pulled out from under it.  Returns the default
     *  event state manager if there is not an event specific state 
     *  manager.
     */
    SipPublishServerEventStateMgr* getEventStateMgr(const UtlString& eventType);

/* ============================ INQUIRY =================================== */


/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:


/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    //! Copy constructor NOT ALLOWED
    SipPublishServer(const SipPublishServer& rSipPublishServer);

    //! Assignment operator NOT ALLOWED
    SipPublishServer& operator=(const SipPublishServer& rhs);

    //! Handle PUBLISH requests
    UtlBoolean handlePublish(const SipMessage& publishRequest);

    //! lock for single thread write access (add/remove event handlers)
    void lockForWrite();

    //! unlock for use
    void unlockForWrite();

    //! lock for multiple-thread read access
    void lockForRead();

    //! unlock for use
    void unlockForRead();

    SipUserAgent* mpDefaultUserAgent;
    SipPublishServerEventStateMgr* mpDefaultEventStateMgr;
    SipPublishServerEventStateCompositor* mpDefaultCompositor;
    UtlHashMap mEventDefinitions; 
    OsRWMutex mPublishServerMutex;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipPublishServer_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SipPublishServerEventStateCompositor_h_
#define _SipPublishServerEventStateCompositor_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES

#include <os/OsDefs.h>
#include <os/OsMutex.h>
#include <utl/UtlDefs.h>
#include <utl/UtlHashMap.h>


// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// FORWARD DECLARATIONS
class SipMessage;
class UtlString;

// TYPEDEFS

//! Class for specializing the handling of SIP Events in SipPublishServer
/*! This class provides the default behavior for SIP event packages
 *  handled by SipPublishServer.  Event packages which wish to change
 *  or extend the default behavior should derived from this class and
 *  override the behavior of methods implemented by this class.
 *
 * \par 
 */
class SipPublishServerEventStateCompositor
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:



/* ============================ CREATORS ================================== */

    //! Default Dialog constructor
    SipPublishServerEventStateCompositor();


    //! Destructor
    virtual
    ~SipPublishServerEventStateCompositor();


/* ============================ MANIPULATORS ============================== */

    //! Determine what the resourceId ad eventTypeKey should be for this PUBLISH request
    /*! The default behavior is to use the identify from the request URI
     *  as the resourceId and the event type token from the Event header
     *  as the eventTypeKey.  Some event packages may wish to override
     *  this (e.g. the host part of the resourceID, which will usually be an
     *  IP addressmay make sense in some cases  to be substituted with the 
     *  domain name.  In some event packages, the content of the event state
     *  information will vary based upon some Event header parameters, in
     *  which cases it may make sense to include that event header parameter
     *  in a consistant order and format in the eventTypeKey.)
     */
    virtual UtlBoolean getKeys(const SipMessage& publishRequest,
                               UtlString& resourceId,
                               UtlString& eventTypeKey);

    //! Determine if the given PUBLISH request is authenticated
    /*! Default behavior is to not require any authentication.
     */
    virtual UtlBoolean isAuthenticated(const SipMessage& publishRequest,
                                       const UtlString& resourceId,
                                       const UtlString& eventTypeKey,
                                       SipMessage& publishResponse);

    //! Determine if the given PUBLISH request is authorized
    /*! Default behavior is to allow any request to subscribe
     */
    virtual UtlBoolean isAuthorized(const SipMessage& publishRequest,
                                   const UtlString& resourceId,
                                   const UtlString& eventTypeKey,
                                   SipMessage& publishResponse);


/* ============================ ACCESSORS ================================= */


/* ============================ INQUIRY =================================== */


/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    //! Copy constructor NOT ALLOWED
    SipPublishServerEventStateCompositor(const SipPublishServerEventStateCompositor& rSipPublishServerEventStateCompositor);

    //! Assignment operator NOT ALLOWED
    SipPublishServerEventStateCompositor& operator=(const SipPublishServerEventStateCompositor& rhs);


};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipPublishServerEventStateCompositor_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SipPublishServerEventStateMgr_h_
#define _SipPublishServerEventStateMgr_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES

#include <os/OsDefs.h>
#include <os/OsMsgQ.h>
#include <os/OsMutex.h>
#include <utl/UtlDefs.h>
#include <utl/UtlHashMap.h>
#include <utl/UtlHashBag.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// FORWARD DECLARATIONS
class SipMessage;
class UtlString;

// TYPEDEFS

//! Class for maintaining PUBLISH event state information in publish server
/*! 
 *
 * \par 
 */
class SipPublishServerEventStateMgr
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:



/* ============================ CREATORS ================================== */

    //! Default constructor
    SipPublishServerEventStateMgr();


    //! Destructor
    virtual
    ~SipPublishServerEventStateMgr();


/* ============================ MANIPULATORS ============================== */
                 
    //! Generate a new entity tag
    virtual void generateETag(UtlString& entity);

    //! Add a new publication
    void addPublish(UtlString& entity, UtlString& resourceId,
                    UtlString& eventTypeKey, int expiration);

    //! Update the publication
    void updatePublish(UtlString& oldEntity, UtlString& entity, UtlString& resourceId,
                       UtlString& eventTypeKey, int expiration);
                    
    //! Remove old publication
    void removePublish(UtlString& entity);

    //! Remove old publication that expired before given date
    void removeOldPublication(long oldEpochTimeSeconds);

/* ============================ ACCESSORS ================================= */

/* ============================ INQUIRY =================================== */

    //! inquire if the publish exists
    virtual UtlBoolean publishExists(UtlString& entityTag);

    //! inquire if the publish has already expired
    virtual UtlBoolean isExpired(UtlString& entityTag);

    //! inquire if the expiration is correct
    virtual UtlBoolean checkExpiration(int* expiration);
    
/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    //! Copy constructor NOT ALLOWED
    SipPublishServerEventStateMgr(const SipPublishServerEventStateMgr& rSipPublishServerEventStateMgr);

    //! Assignment operator NOT ALLOWED
    SipPublishServerEventStateMgr& operator=(const SipPublishServerEventStateMgr& rhs);

    //! lock for single thread use
    void lock();

    //! unlock for use
    void unlock();

    OsMutex mEventStateMgrMutex;
    int mMinExpiration;
    int mDefaultExpiration;
    int mMaxExpiration;

    // Container for the event states
    UtlHashMap mEventStatesByEntityTag;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipPublishServerEventStateMgr_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////
// Author: Dan Petrie (dpetrie AT SIPez DOT com)

#ifndef _SipRefreshManager_h_
#define _SipRefreshManager_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES

#include <os/OsDefs.h>
#include <os/OsServerTask.h>
#include <utl/UtlHashMap.h>
#include <net/SipDialog.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// FORWARD DECLARATIONS
class SipMessage;
class SipUserAgent;
class SipDialogMgr;
class RefreshDialogState;
class OsTimer;

// TYPEDEFS

//! Class for refreshing SIP subscriptions and registrations
/*! This is currently verified for SUBSCRIPTIONS ONLY.
 *  This class is intended to deprecate the SipRefreshMgr class.
 *
 * \par 
 */
class SipRefreshManager : public OsServerTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    enum RefreshRequestState
    {
        REFRESH_REQUEST_UNKNOWN,
        REFRESH_REQUEST_PENDING,
        REFRESH_REQUEST_FAILED,
        REFRESH_REQUEST_SUCCEEDED
    };

    /*! Typedef defining the signature of the callback used to inform
     *  applications of refresh subscription and registration state
     *  changes.
     *  \param requestState - the state of the last SUBSCRIBE or NOTIFY
     *         transaction.  Note: this is not the same as the dialog state.
     *         The dialog state is indicted by the fact that expiration
     *         is in the future (i.e. subscribed or registered) or in the
     *         past or zero (i.e. expired).
     *  \param earlyDialogHandle - provided if still an early dialog or if
     *         the dialog just changed to an established dialog otherwise NULL
     *  \param dialogHandle - provided if dialog is established otherwise NULL
     *  \param applicationData - pass back of application data provided upon
     *         adding SUBSCRIBE or REGISTRATION to be refreshed
     *  \param responseCode - SIP response code 200-299 Success, > 300 failure
     *         Has no meaning if subscribeResponse is NULL
     *         NOTE: a failure code does not mean that the subscription or
     *         registration has expired.  The previous SUBSCRIBE or REGISTER
     *         may have succeeded and may not have expired yet.
     *  \param responseText - SIP response text. NULL if subscribeResponse is NULL
     *  \param expiration - epoch time in seconds when expiration of subscription
     *         or registration will occur.  A value of zero indicates that
     *         a unSUBSCRIBE or unREGISTER occurred and that it has expired
     *         and that no further attempts will be made to reSUBSCRIBE or
     *         reREGISTER.  Usual zero indicates that the application stopped
     *         the refresh.  A value of -1 indicates that no requests have 
     *         succeeded yet. A value greater than zero and less than the 
     *         current epoch time indicates the SUBSCRIBE or REGISTER has 
     *         expired most likely because of a request failure.
     *  \param subscribeResponse - SIP SUBSCRIBE or REGISTER response which
     *         stimulated the state change.  May be NULL.
     */
    typedef void (*RefreshStateCallback) (SipRefreshManager::RefreshRequestState requestState,
                                       const char* earlyDialogHandle,
                                       const char* dialogHandle,
                                       void* applicationData,
                                       int responseCode,
                                       const char* responseText,
                                       long expiration, // epoch seconds
                                       const SipMessage* response);

/* ============================ CREATORS ================================== */

    //! Default Dialog constructor
    SipRefreshManager(SipUserAgent& userAgent, 
                      SipDialogMgr& dialogMgr);


    //! Destructor
    virtual
    ~SipRefreshManager();


/* ============================ MANIPULATORS ============================== */

    //! Send message and keep request refreshed (i.e. subscribed or registered)
    /*! 
     *  Returns TRUE if the request was sent and the 
     *  refresh state proceeded to REFRESH_INITIATED.
     *  Returns FALSE if the request was not able to
     *  be sent, the refresh state is set to REFRESH_FAILED.
     *  The caller of this method must explicitly call stopRefresh
     *  to clean up the refresh state even if this method fails.
     *  This method may fail if the dialog or refresh state already
     *  exists or if the request immediately fails to send.  The
     *  refresh manager will attempt to resend the request to
     *  subscribe or register even if it fails the first time while
     *  this method is invoked.  The theory is that it may have
     *  failed due to a provisioning race condition or a temporary
     *  network problem.
     */
    UtlBoolean initiateRefresh(SipMessage& subscribeOrRegisterRequest,
                               void* applicationData,
                               const RefreshStateCallback refreshStateCallback,
                               UtlString& earlyDialogHandle);

    //! End the SIP refresh (registration or subscription) indicated by 
    /*! the dialog handle.  If the given dialogHandle is an early dialog it
     *  will end any established or early dialog subscriptions.  Typically 
     *  the application SHOULD use the established dialog handle.  This
     *  method can also be used to end one of the dialogs if multiple
     *  subscription dialogs were created as a result of a single 
     *  subscribe request.  The application will get multiple 
     *  REFRESH_SETUP RefreshStateCallback events when
     *  multiple dialogs are created as a result of a single SUBSCRIBE.
     *  To end one of the subscriptions the application should use
     *  the setup dialogHandle provided by the SubscriptionStateCallback.
     *  Only a single registration can occur as a result of sending
     *  a REGISTER request.
     */
    UtlBoolean stopRefresh(const char* dialogHandle);

    //! Stop refreshing, unregister and unsubscribe all
    void stopAllRefreshes();

    //! Handler for SUBSCRIBE and REGISTER responses
    UtlBoolean handleMessage(OsMsg &eventMessage);

/* ============================ ACCESSORS ================================= */

    //! Debugging method to get an dump of all refresh states
    int dumpRefreshStates(UtlString& dumpString);

    //! Get a string representation of the refresh state enumeration
    static void refreshState2String(RefreshRequestState state, UtlString& stateString);

/* ============================ INQUIRY =================================== */

    //! Get a count of the subscriptions and registration which have been added
    int countRefreshSessions() const;

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    //! lock for single thread use
    void lock();
    //! lock for single thread use
    void unlock();

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    //! Copy constructor NOT ALLOWED
    SipRefreshManager(const SipRefreshManager& rSipRefreshManager);

    //! Assignment operator NOT ALLOWED
    SipRefreshManager& operator=(const SipRefreshManager& rhs);

    //! Accessor to get the state that matches either an established or early dialog
    RefreshDialogState* getAnyDialog(UtlString& messageDialogHandle);

    //! Accessor to verify state is still in the mRefreshes container
    UtlBoolean stateExists(RefreshDialogState* statePtr);

    //! helper function to construct and initialize refresh state
    RefreshDialogState* createNewRefreshState(SipMessage& subscribeOrRegisterRequest,
                                              UtlString& messageDialogHandle,
                                              void* applicationData,
                                              const RefreshStateCallback refreshStateCallback,
                                              int& requestedExpiration);

    //! Create a new timer and set it to fire when its time to resend
    void setRefreshTimer(RefreshDialogState& state, 
                         UtlBoolean isSuccessfulReschedule);

    //! Calculate the time in seconds when a refresh should occur
    /*! Assume that the register or subscribe will succeed and that
     *  we should send the refresh safely before the expiration
     */
    int calculateResendTime(int requestedExpiration, 
                            UtlBoolean isSuccessfulResend);

    //! Stop the resend timer to indicate that it should be rescheduled with a short, failure timeout
    void stopTimerForFailureReschedule(OsTimer* timer);

    //! Delete the given timer and its associated notiifer
    static void deleteTimerAndEvent(OsTimer* timer);

    //! set the given state and attached request so that it can be resent
    void setForResend(RefreshDialogState& state, 
                             UtlBoolean expireNow);

    //! Get the expiration from the initial SUBSCRIBE or REGISTER request
    static UtlBoolean getInitialExpiration(const SipMessage& sipRequest, 
                                           int& expirationPeriod);

    //! Get the expiration from the accepted SUBSCRIBE or REGISTER response
    static UtlBoolean getAcceptedExpiration(RefreshDialogState* refreshState,
                                            const SipMessage& sipResponse, 
                                            int& expirationPeriod);

    OsMutex mRefreshMgrMutex; // used to lock this 
    SipUserAgent* mpUserAgent;
    SipDialogMgr* mpDialogMgr;
    UtlHashMap mRefreshes; // state info. for each subscription and registration being maintained.
    UtlHashMap mEventTypes; // SIP event types that we want SUBSCRIBE responses for
    UtlBoolean mReceivingRegisterResponses;
    int mDefaultExpiration;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipRefreshManager_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef SIPREFRESHMGR_H
#define SIPREFRESHMGR_H

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include "os/OsServerTask.h"
#include "net/SipMessage.h"
#include "net/SipTcpServer.h"
#include "net/SipUdpServer.h"
#include "net/SipMessageList.h"
#include "net/SipMessageEvent.h"
#include "utl/UtlRandom.h"
#include "utl/UtlHashMap.h"
#include "tapi/sipXtapiEvents.h" /* :TODO: CIRCULAR */

#include "net/SipLine.h"


// DEFINES
#define DEFAULT_PERCENTAGE_TIMEOUT 48 //48%
#define FAILED_PERCENTAGE_TIMEOUT 24 //24%
#define SIP_LINE_LINEID "lineID"
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class SipUserAgent;
class SipLineMgr;
class SipLineStateEventListener;

class SipRefreshMgr : public OsServerTask
{
public:
    //INITIALIZE
    UtlBoolean init(
        SipUserAgent *ptrToMyAgent,
        int sipTcpPort = SIP_PORT,
        int sipUdpPort = SIP_PORT,
        const char* defaultUser = NULL,
        const char* publicAddress = NULL,
        const char* defaultSipAddress = NULL,
        const char* sipDirectoryServers = NULL,
        const char* sipRegistryServers = NULL,
        int defaultRegistryTimeout = 3600,      // one hr
        int defaultSubscribeTimeout = 60*60*24, // 24 hrs
        int restartCount = 1,
        const char* macAddress = NULL );

    void StartRefreshMgr();
    
    /**
     * Mutator for the mDefaultRegistryPeriodMember
     */
    void setRegistryPeriod(const int periodInSeconds);
    
    /**
     * Mutator for the mDefaultSubscribePeriodMember
     */
    void setSubscribeTimeout(const int periodInSeconds);

    /**
     * Accessor for the mDefaultSubscribePeriodMember
     */
    const int getSubscribeTimeout();

    void addMessageConsumer( OsServerTask* messageEventListener );

    void addMessageObserver (
        OsMsgQ& messageQueue,
        const char* sipMethod = NULL,
        UtlBoolean wantRequests = TRUE,
        UtlBoolean wantResponses = TRUE,
        UtlBoolean wantIncoming = TRUE,
        UtlBoolean wantOutGoing = FALSE,
        const char* eventName = NULL,
        void* observerData = NULL );

    //: Add a SIP message observer for SIP messages meeting the filter criteria
    //! param: messageQueue - the queue on which an SipMessageEvent is dispatched
    //! param: sipMethod - the specific method type of the requests or responses to be observed.  NULL or a null string indicates all methods.
    //! param: wantRequests - want to observe SIP requests
    //! param: wantResponses - want to observe SIP responses
    //! param: wantIncoming - want to observe SIP messages originating from the network.
    //! param: wantOutGoing - want to observe SIP messages originating from locally.
    //! param: eventName - want to observer SUBSCRIBE or NOTIFY requests having the given event type
    //! param: observerData - data to be attached to SIP messages queued on the observer

    //void removeMessageConsumer(OsServerTask* messageConsumer);
    //: Remove a SIP message recipient

    //REGISTER METHODS
    UtlBoolean newRegisterMsg (
        const Url& fromUrl,
        const UtlString& lineId,
        int registryPeriodSeconds = -1,
        Url* pPreferredContactUri = NULL);

    void reRegisterAll();

    void reRegister ( const Url& fromUrl );

    void unRegisterUser (
        const Url& fromUrl,
        const UtlBoolean& onStartup = FALSE,
        const UtlString& lineid ="" );

    //SUBSRIBE METHODS
    void reSubscribeAll();
    
    void unSubscribeAll();
      //:Unsubscribe all
      
    void setLineMgr(SipLineMgr* const lineMgr);
    //: Sets a pointer to the line manager
    
    SipLineMgr* const getLineMgr() const;
    //: Gets the line manager pointer

    UtlBoolean newSubscribeMsg( SipMessage& message );

    SipRefreshMgr(SipLineStateEventListener *listener);

    void dumpMessageLists(UtlString& results) ;
      //:Appends the message contents of both the mRegisterList and 
      // mSubscribeList
  
    virtual ~SipRefreshMgr();

    virtual UtlBoolean handleMessage( OsMsg& eventMessage );

    UtlBoolean getNatMappedAddress(UtlString* pIpAddress, int* pPort) ;
      //: Get the nat mapped address (if available)

    void generateCallId (
        const UtlString& lineId,
        const UtlString& method,
        UtlString& callid,
        UtlBoolean onStartup = FALSE );


protected:
    SipLineMgr* mpLineMgr;
    // the line manager object that uses this refresh manager
    
    // MsgType categories defined for use by the system
    enum RefreshMsgTypes
    {
        UNSPECIFIED = 0,
        START_REFRESH_MGR
    };

    // Common Methods
    UtlBoolean isUAStarted();

    void waitForUA();

    void queueMessageToObservers (
        SipMessageEvent& event,
        const char* method);

    void getFromAddress (
        UtlString* address,
        int* port,
        UtlString* protocol);

    void rescheduleAfterTime (
        SipMessage* message,
        int percentage = DEFAULT_PERCENTAGE_TIMEOUT );

    void sendToObservers (
        const OsMsg& eventMessage,
        SipMessage * registerRequest );

    OsStatus sendRequest (
        SipMessage& registerRequest,
        const char *method);

    void rescheduleRequest (
        SipMessage* registerRequest,
        int secondsFromNow,
        const char* method,
        int percentage = DEFAULT_PERCENTAGE_TIMEOUT,
        UtlBoolean sendImmediate = FALSE );

    void processOKResponse (
        SipMessage* registerResponse,
        SipMessage* registerRequest );

    void parseContactFields (
        SipMessage* message,
        SipMessage* sipRequest,
        int& expireVal );

    void processResponse(
        const OsMsg& eventMessage,
        SipMessage* registerRequest);

    void createTagNameValuePair( UtlString& tagNamevaluePair );

    // register
    void registerUrl(
        const char* registerFromAddress,
        const char* registerToAddress,
        const char* registerUri,
        const char* contactUrl,
        const UtlString& registerCallId,
        int registerPeriod = -1);

    UtlBoolean isDuplicateRegister( 
        const Url& url,
        SipMessage& oldMessage );

    UtlBoolean isDuplicateRegister( const Url& url );

    void addToRegisterList( SipMessage* message);

    UtlBoolean removeFromRegisterList( SipMessage* message );
     //: Returns TRUE if message was found and removed from list.
     //: Message is NOT deleted.  

    // subscribe
    void addToSubscribeList( SipMessage * message);

    UtlBoolean removeFromSubscribeList( SipMessage* message );
     //: Returns TRUE if message was found and removed from list.
     //: Message is NOT deleted.  

    UtlBoolean isDuplicateSubscribe ( const Url& url );

    UtlBoolean isDuplicateSubscribe(
        const Url& fromUrl,
        SipMessage &oldMsg );

    void getContactField(
        const Url& registerToField,
        UtlString& contact,
        const UtlString& lineId = "",
        Url* pPreferredContactUri = NULL);
        
    void removeAllFromRequestList(SipMessage* response);
    //: Removes all prior request records for this response
    //: from the SipMessageLists (mRegisterList & mSubscribeList)
    
    void removeAllFromRequestList(SipMessage* response, SipMessageList* pRequestList);
    //: Removes all prior request records for this response
    //: from the passed-in SipMessageList
    
    UtlBoolean isExpiresZero(SipMessage* pRequest) ;
      //: Is the expires field set to zero for the specified msg?
         
    SIPX_LINESTATE_EVENT getLastLineEvent(const UtlString& lineId);
    //: holding on to the last known line event type 
    
    void setLastLineEvent(const UtlString& lineId, const SIPX_LINESTATE_EVENT eMajor);
    //: sets the last line event type 
    
    UtlHashMap* mpLastLineEventMap;

    // register
    int mDefaultRegistryPeriod;
    SipMessageList mRegisterList;
    OsRWMutex mRegisterListMutexR;
    OsRWMutex mRegisterListMutexW;
    UtlString mRegistryServer;

    // subscribe
    int mDefaultSubscribePeriod;
    SipMessageList mSubscribeList;
    OsRWMutex mSubscribeListMutexR;
    OsRWMutex mSubscribeListMutexW;

    // events
    SipLineStateEventListener* mLineListener;

    // common
    UtlBoolean mIsStarted;
    UtlHashBag mMessageObservers;
    OsRWMutex mObserverMutex;
    OsMutex mUAReadyMutex;
    UtlString mContactAddress;
    UtlString mDefaultSipAddress;
    UtlString mSipIpAddress;
    UtlString mDefaultUser;
    UtlString mMacAddress;
    UtlString mRestartCountStr;
    SipUserAgent* mMyUserAgent;
    int mTcpPort;
    int mUdpPort;
    int mRestartCount;
    UtlRandom mRandomNumGenerator ;
    UtlHashBag mTimerBag;
};

#endif // SIPREFRESHMGR_H
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SipRequestContext_h_
#define _SipRequestContext_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <utl/UtlString.h>
#include <utl/UtlDList.h>


// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//! Class Container for context variables for SIP request API
/*! The class is passed as an additional argument to contain
 *  context information that is not contained in the SIP request
 *  (which is also passed with this container).  Effectively this
 *  is supplimental informatiion to the SIP Request.
 *
 * The intention is for this to be used as part of standard
 * APIs that process SIP requests and generate SIP responses.
 * In those scenarios (e.g. the status server plugins, the
 * redirect server plugins) there is a need for a general 
 * container that provides more information than is available
 * or perhaps easily accessable in the SIP request itself.
 * The specific API will need to provide specifics such as
 * is the request context for consumption only (i.e. read only)
 * or can the application add content to the request context
 * that may be used by subsequent applications consuming the
 * same SipRequestContext.
 */

class SipRequestContext 
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
   static const char* sAUTH_USER;
   static const char* sAUTH_REALM;
   static const char* sREQUEST_METHOD;
   static const char* sSERVER_DOMAIN;

/* ============================ CREATORS ================================== */

   //! Constructor
   /*! Construct a request context for an incoming request of
    * the given request method.
    * \par requestMethod - the request method for the given request.
    */
   SipRequestContext(const char* requestMethod = NULL);
     //:Default constructor


   virtual
   ~SipRequestContext();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */
   
   //! Get context variables provided in this request context.
   /*! As it is possible to have multiple occurances of a named value
    *  the occurance argument indicates which occurance.  The default is 
    *  the first.
    * \param name - the name of the variable to be retrieved from the
    * request context.  It is legal to have multiple values for the
    * same name.  Hense the optional argument occurance.  In applications
    * where the consumer of the SipRequestContext may also set values,
    * the application should use a names space convention to avoid
    * accedental collisions (e.g. for an ENUM pluging, it might use
    * a prefix of "ENUM." in front of all the variable names it adds
    * to the request context.
    * \param value - the value of the given variable name.
    * \param occurance - if there are more than one instance of the
    * same variable name in the SipRequestContext, occurance is an
    * integer that can be used to walk through and retrieve all of the
    * values.  Returns FALSE if the given occurance number does not exist.
    */
   UtlBoolean getVariable(const char* name, 
                          UtlString& value, 
                          int occurance = 0) const;


   //! Add a variable to the context.
   /*! If there are other instances of the same variable in the
    * context, the new one is added after the last occurance.
    */
   void addVariable( const char* name, const char* value);

   //! Get a string of all the values and names in the SipRequestContext
   /*! This is a debugging tool to dump the context.
    *  Returns the number of variables found.
    */
   int toString(UtlString& dumpString);

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

   //! Get the name and value of the variable at the given index
   UtlBoolean getVariable(int index, 
                             UtlString& name, 
                             UtlString& value) const;

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

   SipRequestContext(const SipRequestContext& rSipRequestContext);
     //:Copy constructor 
   SipRequestContext& operator=(const SipRequestContext& rhs);
     //:Assignment operator

   UtlDList mVariableList;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipRequestContext_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SipResourceList_h_
#define _SipResourceList_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include <utl/UtlHashMap.h>
#include <net/HttpBody.h>
#include <net/Url.h>
#include <net/SipDialogEvent.h>
#include <net/SipPresenceEvent.h>
#include <os/OsDateTime.h>
#include <os/OsBSem.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
#define RESOURCE_LIST_CONTENT_TYPE "application/rlmi+xml"
#define RESOURCE_LIST_XMLNS "urn:ietf:params:xml:ns:rlmi"

#define BEGIN_LIST "<list xmlns=\"urn:ietf:params:xml:ns:rlmi\""
#define END_LIST "</list>\n"

#define URI_EQUAL " uri="
#define FULL_STATE_EQUAL " fullState="

#define BEGIN_RESOURCE "<resource uri="
#define END_RESOURCE "</resource>\n"

#define BEGIN_NAME "<name>"
#define END_NAME "</name>\n"

#define BEGIN_INSTANCE "<instance id="

#define STATE_ACTIVE "active"
#define STATE_PENDIND "pending"
#define STATE_TERMINATED "terminated"

// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//! Container for resource element in the resource list
/**
 * This class contains all the contents presented in a resource element of the
 * resource list described in draft-ietf-simple-event-list-07.txt
 * (A Session Initiation Protocol Event Notification Extension for Resource Lists).
 * This class has the methods to construct and manipulate the resource and its
 * sub-elements.
 */

class Resource : public UtlContainable
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

/** 
 * @name ====================== Constructors and Destructors
 * @{
 */
   /// Constructor
   Resource(const char* uri);

   /// Copy constructor
   Resource(const Resource& rResource);

   /// Destructor
   ~Resource();

   virtual UtlContainableType getContainableType() const;

   virtual unsigned int hash() const;

   int compareTo(const UtlContainable *b) const;

///@}
   
/**
 * @name ====================== Resource Setting Interfaces
 *
 * These methods set/get the resource element and sub-elements.
 *
 * @{
 */

   void getResourceUri(UtlString& uri) const;

   void setName(const char* name);

   void getName(UtlString& name) const;

   void setInstance(const char* id,
                    const char* state);

   void getInstance(UtlString& id,
                    UtlString& state) const;

///@}
   
/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:
   
/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:

   // Variables for resource element
   UtlString mUri;

   // Variables for name element
   UtlString mName;

   // Variables for instance element
   UtlString mId;
   UtlString mState;

   //Assignment operator
   Resource& operator=(const Resource& rhs);
};


//! Container for MIME type application/rlmi+xml.
/**
 * This class contains all the contents presented in a resource list
 * described in draft-ietf-simple-event-list-07.txt (A Session Initiation Protocol
 * (SIP) Event Notification Extension for Resource Lists). This class has the
 * methods to construct and manipulate the resources in a resource list.
 */
class SipResourceList : public HttpBody
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

/** 
 * @name ====================== Constructors and Destructors
 * @{
 */
   //! Construct an empty body of a resource list
   SipResourceList(const UtlBoolean state,
                   const char* uri,
                   const char* type);


   //! Construct from an existing resource list in the xml format
   SipResourceList(const char* bodyBytes, const char* type);

   //! Destructor that will free up the memory allocated for resource contents if it is not being deleted
   virtual
      ~SipResourceList();

///@}
   
/**
 * @name ====================== Resource List Serialization Interfaces
 *
 * @{
 */

   //! Build the body of this object
   void buildBody() const;

   //! Get the event type of this object
   void getEventType(UtlString& type) const;

   //! Get the string length of this object
   virtual int getLength() const;

   //! Get the resource list uri
   void getListUri(UtlString& uri) const;

   //! Get the serialized char representation of this resource list.
   /*! \param bytes - buffer space where the resource list is written, null
    *       terminated.
    *  \param length - the number of bytes written (not including the
    *       null terminator).
    */
   virtual void getBytes(const char** bytes,
                         int* length) const;

   //! Get the serialized string representation of this resource list.
   /*! \param bytes - buffer space where the resource list is written, null
    *       terminated.
    *  \param length - the number of bytes written (not including the
    *       null terminator).
    */
   virtual void getBytes(UtlString* bytes,
                         int* length) const;

///@}

/**
 * @name ====================== Resource List Setting Interfaces
 *
 * These methods set/get the resource element.
 *
 * @{
 */

   //! Insert a Resource object to the hash table.
   void insertResource(Resource* resource);

   //! Get the Resource object based on the resource Uri.
   Resource* getResource(UtlString& resourceUri);
   
   //! Remove the Resource object from the hash table.
   Resource* removeResource(Resource* resource);
   
   //! Insert a Event object to the hash table.
   void insertEvent(UtlContainable* event);

   //! Remove the Event object from the hash table.
   UtlContainable* removeEvent(UtlContainable* event);

   //! Check whether there is any resource or not
   UtlBoolean isEmpty();

///@}
   
/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:
   
   /// Parse an existing resource list from xml format into the internal representation.
   void parseBody(const char* bytes);


/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:

   //! Variables for list
   int mVersion;
   UtlString mFullState;
   UtlString mListUri;
   UtlString mEventType;

    //! reader/writer lock for synchronization
    OsBSem mLock;

   //! Variable for resource element
   UtlHashMap mResources;

   //! Variable for holding the event packages
   UtlHashMap mEvents;
  
   //! Disabled copy constructor
   SipResourceList(const SipResourceList& rSipResourceList);

   //! Disabled assignment operator
   SipResourceList& operator=(const SipResourceList& rhs);

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipResourceList_h_
//
// Copyright (C) 2007 Jaroslav Libak
// Licensed under the LGPL license.
//
// Copyright (C) 2005-2007 SIPez LLC.
// Licensed to SIPfoundry under a Contributor Agreement.
// 
// Copyright (C) 2004-2007 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef SipSecurityEventListener_h__
#define SipSecurityEventListener_h__


// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include <utl/UtlString.h>
#include "tapi/sipXtapiEvents.h"

// DEFINES
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// FORWARD DECLARATIONS
// STRUCTS
// TYPEDEFS
// MACROS
// GLOBAL VARIABLES
// GLOBAL FUNCTIONS

class SipSecurityEvent
{
public:
   UtlString           m_sSRTPkey;
   void*               m_pCertificate;
   size_t              m_nCertificateSize;
   SIPX_SECURITY_EVENT m_Event;
   SIPX_SECURITY_CAUSE m_Cause;
   UtlString           m_sSubjAltName;
   UtlString           m_SessionCallId;
   UtlString           m_sRemoteAddress;
};


/**
* Listener for Security events
*/
class SipSecurityEventListener
{
   /* //////////////////////////// PUBLIC //////////////////////////////////// */

   /* ============================ CREATORS ================================== */
public:
   SipSecurityEventListener() {}
   virtual ~SipSecurityEventListener() {}

   /* ============================ MANIPULATORS ============================== */

   virtual void OnEncrypt(const SipSecurityEvent& event) = 0;

   virtual void OnDecrypt(const SipSecurityEvent& event) = 0;

   virtual void OnTLS(const SipSecurityEvent& event) = 0;

   /* ============================ ACCESSORS ================================= */

   /* ============================ INQUIRY =================================== */

   /* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

   /* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

};

#endif // SipSecurityEventListener_h__
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SipServerBase_h_
#define _SipServerBase_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <os/OsServerTask.h>
// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class OsConfigDb;
class SipUserAgent;
class SipMessage;
//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class SipServerBase : public OsServerTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   virtual ~SipServerBase();
     //:Destructor

/* ============================ MANIPULATORS ============================== */
    virtual UtlBoolean handleMessage(OsMsg& eventMessage) = 0;
    virtual void initialize() = 0;

/* ============================ ACCESSORS ================================= */


/* ============================ INQUIRY =================================== */
/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
        virtual UtlBoolean isAuthorized(const SipMessage* message, SipMessage * responseMessage) = 0;
   virtual UtlBoolean isValidDomain(const SipMessage* message, SipMessage * responseMessage) = 0;
   virtual UtlBoolean isPermitted(const SipMessage* message, SipMessage * responseMessage) = 0;

   SipUserAgent* mSipUserAgent;
   UtlString mDefaultDomain;

   SipServerBase(const SipServerBase& rSipServerBase);
   //:Copy constructor (disabled)
   SipServerBase& operator=(const SipServerBase& rhs);
   //:Assignment operator (disabled)
   SipServerBase( SipUserAgent* sipUserAgent,
                 const UtlString& defaultDomain = "");

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipServerBase_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _INCLUDED_SipServerBroker_H /* [ */
#define _INCLUDED_SipServerBroker_H

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include "os/OsTask.h"
#include "os/OsLock.h"
#include "os/OsSocket.h"
#include "os/OsRWMutex.h"
#include "os/OsProtectEvent.h"
#include "os/OsServerSocket.h"
#include "os/OsServerTask.h"

class OsNotification;
// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS

class OsConnectionSocket;
class OsServerSocket;
class OsSocket;



class SipServerBroker : public OsTask
{

/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:


/* ============================ CREATORS ================================== */

   SipServerBroker(OsServerTask* pTask, OsServerSocket* pSocket);
   //:Constructor - takes a server task which created this broker,
   //   and also a socket to listen on
   
   virtual
   ~SipServerBroker();
     //:Destructor

/* ============================ MANIPULATORS ============================== */
    virtual int run(void* pArg);


/* ============================ ACCESSORS ================================= */


/* ============================ INQUIRY =================================== */
/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    OsServerSocket* mpSocket;
    OsServerTask* const mpOwnerTask;

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
   SipServerBroker(const SipServerBroker& rSipServerBroker);
     //:Copy constructor (not implemented for this task)

   SipServerBroker& operator=(const SipServerBroker& rhs);
     //:Assignment operator (not implemented for this task)
};

#endif /* _INCLUDED_SipServerBrokerH ] */
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SipSession_h_
#define _SipSession_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES

#include <os/OsDefs.h>
#include <net/Url.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class SipMessage;

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class SipSession : public UtlString
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    enum SessionState
    {
        SESSION_UNKNOWN,
        SESSION_INITIATED,
        SESSION_SETUP,
        SESSION_FAILED,
        SESSION_TERMINATED
    };

/* ============================ CREATORS ================================== */

   SipSession(const SipMessage* initialMessage = NULL,
              UtlBoolean isFromLocal = TRUE);
     //:Default constructor

   SipSession(const char* callId, const char* toUrl, const char* fromUrl); 
     //:Constructor accepting the basic pieces of a session callId, toUrl, 
     // and from Url.

   virtual
   ~SipSession();
     //:Destructor

   SipSession(const SipSession& rSipSession);
     //:Copy constructor

   SipSession& operator=(const SipSession& rhs);
     //:Assignment operator

/* ============================ MANIPULATORS ============================== */

   void updateSessionData(SipMessage& message);

/* ============================ ACCESSORS ================================= */

   void getCallId(UtlString& callId) const;
   void setCallId(const char* callId);

   void getFromUrl(Url& fromUrl) const;
   void setFromUrl(const Url& fromUrl);

   void getToUrl(Url& toUrl) const;
   void setToUrl(const Url& toUrl);

   void getRemoteContact(Url& remoteContact) const;
   void setRemoteContact(const Url& remoteContact);

   void getLocalContact(Url& localContact) const;
   void setLocalContact(const Url& localContact);

   void getInitialMethod(UtlString& method) const;
   void setInitialMethod(const char* method);

   int getNextFromCseq();
   int getLastFromCseq() const;
   void setLastFromCseq(int seqNum);

   int getLastToCseq() const;
   void setLastToCseq(int seqNum);

   void getLocalRequestUri(UtlString& requestUri) const;
   void setLocalRequestUri(UtlString& requestUri);
   void getRemoteRequestUri(UtlString& requestUri) const;
   void setRemoteRequestUri(UtlString& requestUri);
   void getContactRequestUri(UtlString& requestContactUri) const;
   void setContactRequestUri(UtlString& requestContactUri);

   int getSessionState() const { return mSessionState;};

/* ============================ INQUIRY =================================== */

   UtlBoolean isSameSession(SipMessage& message);

   UtlBoolean isMessageFromInitiator(SipMessage& message);

   UtlBoolean isMessageFromDestination(SipMessage& message);

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    // The callId is stored in the UtlString base class data element
    Url mLocalUrl;
    Url mRemoteUrl;
    Url mLocalContact;
    Url mRemoteContact;
    UtlString mInitialMethod;
    UtlString msLocalRequestUri;
    UtlString msRemoteRequestUri;
	UtlString msContactUriStr;
    int mInitialLocalCseq;
    int mInitialRemoteCseq;
    int mLastFromCseq;
    int mLastToCseq;
    int mSessionState;

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipSession_h_
//  
// Copyright (C) 2006 SIPez LLC. 
// Licensed to SIPfoundry under a Contributor Agreement. 
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipSrvLookup_h_
#define _SipSrvLookup_h_

// SYSTEM INCLUDES
#if defined(_WIN32)
//#   include <resparse/wnt/netinet/in.h>
#elif defined(_VXWORKS)
#  include <netinet/in.h>
#elif defined(__pingtel_on_posix__)
#   include <netinet/in.h>
#else
#  error Unsupported target platform.
#endif

// APPLICATION INCLUDES
#include "os/OsDefs.h"
#include "os/OsMutex.h"
#include "os/OsSocket.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS

// TYPEDEFS

// FORWARD DECLARATIONS
class server_t;
typedef struct s_res_response
    res_response;

/**
 * A class (with no members) whose 'servers' method implements the RFC
 * 3263 process for determining a list of server entries for a SIP
 * domain name.
 */
class SipSrvLookup
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

   /// Get the list of server entries for SIP domain name 'domain'.
   static server_t* servers(const char *domain,
                            ///< SIP domain name or host name
                            const char *service,
                            ///< "sip" or "sips"
                            OsSocket::IpProtocolSocketType socketType,
                            ///< types of transport
                            int port,
                            ///< port number from URI, or PORT_NONE
                            const char* srcIp
                            ///< the outgoing interface ip to send the request on
      );
   /**<
    * Returns the list of server entries for SIP domain name 'domain'.
    * Implements the processes of RFC 2543.
    * The search process is modified by the parameters:
    *
    * The 'service' is the URI scheme, "sip" or "sips".
    *
    * The 'port' argument is the port number supplied in the URI, or a
    * negative number if none was supplied.
    * If none was supplied, SRV records are consulted.  If no SRV records
    * are found, port defaults to 5060 for "sip" service and 5061 for
    * "sips" service.
    *
    * The 'socketType' restricts the search to that sort of transport,
    * and may have the values (within IpProtocolSocketType):
    *    TCP
    *    UDP
    *    SSL_SOCKET
    *    UNKNOWN (all of the above are acceptable)
    * It is used if the URI or other context information specifies a transport.
    * If UNKNOWN is specified, servers() attempts to return addresses for
    * all transports that it knows about that are compatible with the service.
    * (If socketType is incompatible with service, no addresses will
    * be returned.)
    *
    * @returns Allocates an array of server_t objects and returns
    * the pointer to it.  Caller is responsible for delete[]'ing the array.
    * The servers are listed in the array in preference order, with a final
    * entry with a host value of NULL.
    */

   /// Option codes for server lookup.
   enum OptionCode {
      OptionCodeNone = 0,       ///< Special value
      OptionCodeFirst,          ///< Start of range
      OptionCodeIgnoreSRV,      ///< If 1, do not search for SRV records.
      OptionCodeIgnoreNAPTR,    ///< If 1, do not search for NAPTR records.
      OptionCodeSortAnswers,    /**< If 1, sort DNS answers before using them.
                                 *   (For testing only.) */
      OptionCodePrintAnswers,   /**< If 1, print DNS answers.
                                 *   (For testing only.) */
      OptionCodeCNAMELimit,     ///< Max. number of CNAMEs to follow.
      OptionCodeNoDefaultTCP,   /**< If 1, do not add TCP contacts by default,
                                 *   for better RFC 3263 conformance. */
      OptionCodeLast            ///< End of range
   };
   /**<
    * All options have a code name in this enumeration.  All codes are in the
    * range OptionCodeFirst:OptionCodeLast.  OptionCodeNone is not in that
    * range and may be used as a special value.
    *
    * Option values are signed integers.
    *
    * Getting and setting all option codes in that range is guaranteed to
    * restore the server lookup algorithm to the preceeding codition.
    *
    * The way enum values are assigned is somewhat sloppy (it allows some
    * code values that are not used to be in the valid range), but it makes
    * editing the enum correctly quite easy.  Do not reorder the list without
    * checking the initializer in SipSrvLookup.cpp; some options have non-zero
    * initial values.
    */

   /// Get an option value.
   static inline int getOption(OptionCode option)
      {
         return options[option];
      }

   /// Set an option value.
   static void setOption(OptionCode option, int value);
   /**
    * setOption can be called at any time from any thread without
    * causing harm to any requests that may be being processed.
    * It may, however, block until all current requests are processed
    * before returning to the caller, and current requests may be processed
    * partly under the old configuration and partly under the new
    * configuration.
    */

   /// Sets the timing parameters for DNS SRV queries.
   static void setDnsSrvTimeouts(int initialTimeoutInSecs,
                                 /**< Timeout in seconds for first query,
                                  *   or 0 for no change. */
                                 int retries
                                 /**< Number of retries to attempt,
                                  *   or 0 for no change. */
      );
   ///< Defaults are: timeout = 5, retries = 4.

   /// Perform a DNS query and parse the results.  Follows CNAME records.
   static void res_query_and_parse(const char* in_name,
                                   ///< domain name to look up
                                   int type,
                                   ///< RR type to look up
                                   res_response* in_response,
                                   /**< response structure to
                                    *   look in before calling
                                    *   res_query, or NULL */
                                   const char*& out_name,
                                   ///< canonical name for in_name
                                   res_response*& out_response
                                   ///< response structure containing RRs
      );
   /**<
    * Performs a DNS query for a particular type of RR on a given name,
    * doing all the work to follow CNAMEs.  The 'in_name' and 'type'
    * arguments specify the RRs to look for.  If 'in_response' is not NULL,
    * it is the results of some previous search for the same name, for
    * a different type of RR, which might contain RRs for this search.
    *
    * @return out_response is a pointer to a response structure, or NULL.
    * If non-NULL, the RRs of the required type (if any) are in out_response
    * (in either the answer section or the additional section), under the name
    * out_name.
    *
    * The caller is responsible for freeing out_name if it is non-NULL
    * and != in_name.  The caller is responsible for freeing out_response if it
    * is non-NULL and != in_response.
    */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

   /// Mutex to keep the routines thread-safe.
   static OsMutex sMutex;

   /// The array of option values.
   static int options[OptionCodeLast+1];

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
};


/**
 * Structure to describe a server found for a SIP domain.
 */
class server_t {
  public:
   
   //! Sets the mDnsSrvResolveEnabled flag
   static void setDnsSrvResolveEnabled(UtlBoolean& enabled);   

   char *host;                  ///< Host name. (Owned by this object.)
   OsSocket::IpProtocolSocketType type;
                                ///< OsSocket:{TCP,UDP,SSL_SOCKET}
   struct sockaddr_in sin;      ///< IP address and port
   unsigned int priority;       ///< SRV priority value
   unsigned int weight;         ///< SRV weight
   float score;                 ///< Calculated sorting score

   /// Initializer for server_t
   server_t();
   static UtlBoolean mDnsSrvResolveEnabled;
   
   /// Copy constructor for server_t
   server_t(const server_t& rserver_t);

   /// Copy assignment constructor for server_t
   server_t& operator=(const server_t& rhs);

   /// Destructor for server_t
   ~server_t();

   /// Inquire if this is a valid SRV record
   UtlBoolean isValidServerT();
   ///< Tests whether the host name element is non-NULL.

   /// Accessor for host name
   void getHostNameFromServerT(UtlString& hostName);

   /// Accessor for host IP address
   void getIpAddressFromServerT(UtlString& hostName);

   /// Accessor for port
   int getPortFromServerT();

   /// Accessor for weight
   unsigned int getWeightFromServerT();

   /// Accessor for score
   float getScoreFromServerT();

   /// Accessor for priority
   unsigned int getPriorityFromServerT();

   /// Accessor for protocol
   OsSocket::IpProtocolSocketType getProtocolFromServerT();
};

#endif  // _SipSrvLookup_h_
// 
// Copyright (C) 2005 SIPez LLC.
// Licensed to SIPfoundry under a Contributor Agreement.
// 
// Copyright (C) 2004 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////
// Author: Dan Petrie (dpetrie AT SIPez DOT com)

//////////////////////////////////////////////////////////////////////////////
#ifndef _SipSubscribeClient_h_
#define _SipSubscribeClient_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES

#include <os/OsDefs.h>
#include <os/OsServerTask.h>
#include <utl/UtlHashMap.h>
#include <net/SipRefreshManager.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// FORWARD DECLARATIONS
class SipMessage;
class SipUserAgent;
class SipDialogMgr;
class SipRefreshManager;
class SubscribeClientState;

// TYPEDEFS

//! Class for containing SIP dialog state information
/*! In SIP a dialog is defined by the SIP Call-Id
 *  header and the tag parameter from the SIP To
 *  and From header fields.  An early dialog has
 *  has only the tag set on one side, the transaction
 *  originator side.  In the initial transaction the
 *  the originator tag in in the From header field.
 *  The final destination sets the To header field
 *  tag in the initial transaction.
 *
 * \par Local and Remote
 *  As the To and From fields get swapped depending
 *  upon which side initiates a transaction (i.e.
 *  sends a request) local and remote are used in
 *  SipDialog to label tags, fields and information.
 *  Local and Remote are unabiquous when used in
 *  an end point.  In a proxy context the SipDialog
 *  can still be used.  One can visualize the
 *  sides of the dialog by thinking Left and Right
 *  instead of local and remote.
 */
class SipSubscribeClient : public OsServerTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    enum SubscriptionState
    {
        SUBSCRIPTION_UNKNOWN,
        SUBSCRIPTION_INITIATED, // Early dialog
        SUBSCRIPTION_SETUP,     // Established dialog
        SUBSCRIPTION_FAILED,    // Failed dialog setup or refresh
        SUBSCRIPTION_TERMINATED // Ended dialog
    };

typedef void (*SubscriptionStateCallback) (SipSubscribeClient::SubscriptionState newState,
                                           const char* earlyDialogHandle,
                                           const char* dialogHandle,
                                           void* applicationData,
                                           int responseCode,
                                           const char* responseText,
                                           long expiration,
                                           const SipMessage* subscribeResponse);

typedef void (*NotifyEventCallback) (const char* earlyDialogHandle,
                                     /**< handle of the early dialog generated
                                      *   by the SUBSCRIBE.
                                      */
                                     const char* dialogHandle,
                                     /**< handle of the confirmed
                                      *   dialog generated by the first NOTIFY.
                                      */
                                     void* applicationData,
                                     const SipMessage* notifyRequest);

/* ============================ CREATORS ================================== */

    //! Create a SipDialogMgr, SipRefreshManager and construct a SipSubscribeClient
    static SipSubscribeClient* buildBasicClient(SipUserAgent& userAgent);

    //! Default Dialog constructor
    SipSubscribeClient(SipUserAgent& userAgent, 
                       SipDialogMgr& dialogMgr,
                       SipRefreshManager& refreshMgr);


    //! Destructor
    virtual
    ~SipSubscribeClient();


/* ============================ MANIPULATORS ============================== */

    //! Create a SIP event subscription for the given SUBSCRIBE header information
    /*! 
     *  Returns TRUE if the SUBSCRIBE request was sent and the 
     *  Subscription state proceeded to SUBSCRIPTION_INITIATED.
     *  Returns FALSE if the SUBSCRIBE request was not able to
     *  be sent, the subscription state is set to SUSCRIPTION_FAILED.
     */
    UtlBoolean addSubscription(const char* resourceId,
                               const char* eventHeaderValue,
                               const char* acceptHeaderValue,
                               const char* fromFieldValue,
                               const char* toFieldValue,
                               const char* contactFieldValue,
                               int subscriptionPeriodSeconds,
                               void* applicationData,
                               const SubscriptionStateCallback subscriptionStateCallback,
                               const NotifyEventCallback notifyEventsCallback,
                               UtlString& earlyDialogHandle);

    //! Create a SIP event subscription for the given SUBSCRIBE request
    /*! 
     *  Returns TRUE if the SUBSCRIBE request was sent and the 
     *  Subscription state proceeded to SUBSCRIPTION_INITIATED.
     *  Returns FALSE if the SUBSCRIBE request was not able to
     *  be sent, the subscription state is set to SUSCRIPTION_FAILED.
     */
    UtlBoolean addSubscription(SipMessage& subscriptionRequest,
                               void* applicationData,
                               const SubscriptionStateCallback subscriptionStateCallback,
                               const NotifyEventCallback notifyEventsCallback,
                               UtlString& earlyDialogHandle);

    //! End the SIP event subscription indicated by the dialog handle
    /*! If the given dialogHandle is an early dialog it will end any
     *  established or early dialog subscriptions.  Typically the
     *  application SHOULD use the established dialog handle.  This
     *  method can also be used to end one of the dialogs if multiple
     *  subsription dialogs were created as a result of a single 
     *  subscribe request.  The application will get multiple 
     *  SUBSCRIPTION_SETUP SubscriptionStateCallback events when
     *  multiple dialogs are created as a result of a single SUBSCRIBE.
     *  To end one of the subscriptions the application should use
     *  the setup dialogHandle provided by the SubscriptionStateCallback.
     */
    UtlBoolean endSubscription(const char* dialogHandle);


    //! End all subscriptions
    void endAllSubscriptions();

    //! Handler for NOTIFY requests
    UtlBoolean handleMessage(OsMsg &eventMessage);

/* ============================ ACCESSORS ================================= */

    //! Create a debug dump of all the client states
    int dumpStates(UtlString& dumpString);

    //! Get a string representation of the client state enumeration
    static void getSubscriptionStateEnumString(enum SubscriptionState stateValue, 
                                               UtlString& stateString);

/* ============================ INQUIRY =================================== */

    //! Get a count of the subscriptions which have been added
    int countSubscriptions();

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    //! Callback to handle subscription state changes from the refresh manager
    /*! RefreshStateCallback
     */
    static void refreshCallback(SipRefreshManager::RefreshRequestState newState,
                               const char* earlyDialogHandle,
                               const char* dialogHandle,
                               void* subscribeClientPtr,
                               int responseCode,
                               const char* responseText,
                               long expiration, // epoch seconds
                               const SipMessage* subscribeResponse);

    //! Handle incoming notify request
    void handleNotifyRequest(const SipMessage& notifyRequest);

    //! Add the client state to the container
    void addState(SubscribeClientState& clientState);

    //! find the state from the container that matches the dialog
    /* Assumes external locking
     */
    SubscribeClientState* getState(const UtlString& dialogHandle);

    //! remove the state from the container that matches the dialog
    /* Assumes external locking
     */
    SubscribeClientState* removeState(UtlString& dialogHandle);

    //! lock for single thread use
    void lock();
    //! lock for single thread use
    void unlock();

    //! Construct a call-id
    void getNextCallId(const char* resourceId, 
                       const char* eventHeaderValue, 
                       const char* fromFieldValue, 
                       const char* contactFieldValue,
                       UtlString& callId);

    //! generate a from tag
    void getNextFromTag(const char* resourceId, 
                        const char* eventHeaderValue, 
                        const char* fromFieldValue, 
                        const char* contactFieldValue,
                        UtlString& fromTag);

    //! Copy constructor NOT ALLOWED
    SipSubscribeClient(const SipSubscribeClient& rSipSubscribeClient);

    //! Assignment operator NOT ALLOWED
    SipSubscribeClient& operator=(const SipSubscribeClient& rhs);

    SipUserAgent* mpUserAgent;
    SipDialogMgr* mpDialogMgr;
    SipRefreshManager* mpRefreshMgr;
    UtlHashMap mSubscriptions; // state info. for each subscription
    UtlHashMap mEventTypes; // SIP event types that we want NOTIFY requests for
    OsMutex mSubcribeClientMutex;
    int mCallIdCount;
    int mTagCount;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipSubscribeClient_h_
// 
// Copyright (C) 2005, 2006 SIPez LLC
// Licensed to SIPfoundry under a Contributor Agreement.
//
// Copyright (C) 2005, 2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////
// Author: Dan Petrie (dpetrie AT SIPez DOT com)

#ifndef _SipSubscribeServer_h_
#define _SipSubscribeServer_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include <os/OsServerTask.h>
#include <os/OsDefs.h>
#include <os/OsRWMutex.h>
#include <utl/UtlString.h>
#include <utl/UtlHashMap.h>
#include <net/SipUserAgent.h>


// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// FORWARD DECLARATIONS
class SipSubscribeServerEventHandler;
class SipUserAgent;
class SipPublishContentMgr;
class SipSubscriptionMgr;
class OsMsg;
class SipMessage;


// TYPEDEFS


//! Top level class for accepting and processing SUBSCRIBE requests
/*! This implements a generic RFC 3265 SUBSCRIBE server or sometimes
 *  called a NOTIFIER.  This class receives SUBSCRIBE requests,
 *  retrieves the SIP Event content from the SipPublisherContentMgr
 *  generates a NOTIFY request with the retrieved Event content and send 
 *  the NOFITY using the SipUserAgent.  The SipSubscribeServer is
 *  designed so that it can handle several different event types or
 *  so that you can have multiple instances of the SipSubscribeServer
 *  each handling different event type.  However you can not have an
 *  event type that is handled by more than one SipSubScribeServer.
 *
 *  \par Event Specific Handling and Processing
 *  Event types are enabled with the enableEventType method.  This method
 *  handling and processing of the specified Event type to be specialized
 *  by providing an Event specific: SipEventPlugin, SipUserAgent and/or
 *  SipPublisherContentMgr.
 *
 *  \par Application Use
 *  An application which provides event state for a specific event type
 *  uses the SipPublishContentMgr to provide event state defaults as well
 *  as state specific to a resource.  The application enables the event
 *  type with the enableEventType method, providing the SipPublishContentMgr
 *  which contains the event state content for the event type.  The
 *  SipSubscribeServer provides the content for specific resource 
 *  contained in the SipPublishContentMgr to subscribers.  The SipPublishContentMgr
 *  notifies the SipSubscribeServer (via callback) of content changes made 
 *  by the application.
 *
 *  \par Subscription State
 *  The SipSubscriptionMgr is used by SipSubscribeServer to maintain
 *  the subscription state (SUBSCRIBE dialog state not Event state
 *  content).
 *
 *  \par Overall Data Flow
 *  The SipSubscribeServer needs to address 4 general stimulus:
 *  1) Respond to incoming SUBSCRIBE requests and send the cooresponding
 *     NOTIFY request.
 *  2) Generate NOTIFY requests when the event state changes for a resource
 *     that has an on-expired subscription.
 *  3) Generate NOTIFY requests to subscriptions when they expire.
 *  4) Some notification error responses should cause the subscription to expire
 *
 *  When enabling a SIP event type via the enableEventType method, 
 *  the SipSubscribeServer registers with
 *  the SipUserAgent to receive SUBSCRIBE requests and NOTIFY responses 
 *  for the event type which are processed by the handleMessage method.
 *  Applications that publish event state use the SipPublishContentMgr
 *  to update resource specific or default event states.  The SipSubscribeServer
 *  is notified by the SipPublishContentMgr (via callback) that the
 *  content has changed and sends a NOTIFY to those subscribed to the
 *  resourceId for the event type key.  The SipSubscribeServer uses
 *  timers to keep track of when event subscription expire.  When a timer
 *  fires, a message gets queued on the SipSubscribeServer which is that
 *  passed to handleMessage.
 */
class SipSubscribeServer : public OsServerTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:


/* ============================ CREATORS ================================== */

    //! Helper utility to build a basic server with default behavior
    static SipSubscribeServer* buildBasicServer(SipUserAgent& userAgent,
                                                const char* eventType = NULL);

    //! Default Dialog constructor
    SipSubscribeServer(SipUserAgent& defaultUserAgent,
                       SipPublishContentMgr& defaultContentMgr,
                       SipSubscriptionMgr& defaultSubscriptionMgr,
                       SipSubscribeServerEventHandler& defaultPlugin);


    //! Destructor
    virtual
    ~SipSubscribeServer();


/* ============================ MANIPULATORS ============================== */

    //! Callback invoked by SipPublishContentMgr when content changes
    /*! This is used to tell the SipSubscribeServer that a new notify
     *  needs to be sent as the event state content has changed.
     */
    static void contentChangeCallback(void* applicationData,
                                       const char* resourceId,
                                       const char* eventTypeKey,
                                       const char* eventType,
                                       UtlBoolean isDefaultContent);

    //! Send a NOTIFY to all subscribers to resource and event state
    UtlBoolean notifySubscribers(const char* resourceId, 
                                 const char* eventTypeKey,
                                 const char* eventType,
                                 UtlBoolean isDefaultContent);

    //! Tell subscribe server to support given event type
    UtlBoolean enableEventType(const char* eventType,
                                 SipUserAgent* userAgent = NULL,
                                 SipPublishContentMgr* contentMgr = NULL,
                                 SipSubscribeServerEventHandler* eventPlugin = NULL,
                                 SipSubscriptionMgr* subscriptionMgr = NULL);

    //! Tell subscribe server to stop supporting given event type
    UtlBoolean disableEventType(const char* eventType,
                                SipUserAgent*& userAgent,
                                SipPublishContentMgr*& contentMgr,
                                SipSubscribeServerEventHandler*& eventPlugin,
                                SipSubscriptionMgr*& subscriptionMgr);

    //! Handler for SUBSCRIBE requests, NOTIFY responses and timers
    UtlBoolean handleMessage(OsMsg &eventMessage);

/* ============================ ACCESSORS ================================= */

    //! Get the event handler for the given eventType
    /*! WARNING: there is no locking of the event handler once it is
     *  returned.  If the eventHandler is removed via disableEventType
     *  and destroyed, there is no locking protection.  The eventHandler
     *  is only safe to use if the application knows that it is not going
     *  to get the rug pulled out from under it.  Returns the default
     *  event handler if there is not an event specific handler.
     */
    SipSubscribeServerEventHandler* 
        getEventHandler(const UtlString& eventType);

    //! Get the content manager for the given event type
    /*! WARNING: there is no locking of the content manager once it is
     *  returned.  If the content manager is removed via disableEventType
     *  and destroyed, there is no locking protection.  The content manager
     *  is only safe to use if the application knows that it is not going
     *  to get the rug pulled out from under it.  Returns the default
     *  content manager if there is not an event specific content manager.
     */
    SipPublishContentMgr* getPublishMgr(const UtlString& eventType);

    //! Get the subscription manager for the given event type
    /*! WARNING: there is no locking of the subscription manager once it is
     *  returned.  If the subscription manager is removed via disableEventType
     *  and destroyed, there is no locking protection.  The subscription manager
     *  is only safe to use if the application knows that it is not going
     *  to get the rug pulled out from under it.  Returns the default
     *  subscription manager if there is not an event specific subscription 
     *  manager.
     */
    SipSubscriptionMgr* getSubscriptionMgr(const UtlString& eventType);

/* ============================ INQUIRY =================================== */


    //! Inquire if the given event type is enabled in the server
    UtlBoolean isEventTypeEnabled(const UtlString& eventType);

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:


/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    //! Copy constructor NOT ALLOWED
    SipSubscribeServer(const SipSubscribeServer& rSipSubscribeServer);

    //! Assignment operator NOT ALLOWED
    SipSubscribeServer& operator=(const SipSubscribeServer& rhs);

    //! Handle SUBSCIRBE requests
    UtlBoolean handleSubscribe(const SipMessage& subscribeRequest);

    //! Handle NOTIFY responses
    UtlBoolean handleNotifyResponse(const SipMessage& notifyResponse);

    //! Handle subscription expiration timer events
    UtlBoolean handleExpiration(UtlString* subscribeDialogHandle,
                                OsTimer* timer);

    //! lock for single thread write access (add/remove event handlers)
    void lockForWrite();

    //! unlock for use
    void unlockForWrite();

    //! lock for multiple-thread read access
    void lockForRead();

    //! unlock for use
    void unlockForRead();

    SipUserAgent* mpDefaultUserAgent;
    SipPublishContentMgr* mpDefaultContentMgr;
    SipSubscriptionMgr* mpDefaultSubscriptionMgr;
    SipSubscribeServerEventHandler* mpDefaultEventHandler;
    UtlHashMap mEventDefinitions; 
    OsRWMutex mSubscribeServerMutex;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipSubscribeServer_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////
// Author: Dan Petrie (dpetrie AT SIPez DOT com)

#ifndef _SipSubscribeServerEventHandler_h_
#define _SipSubscribeServerEventHandler_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES

#include <os/OsDefs.h>
#include <os/OsMutex.h>
#include <utl/UtlDefs.h>
#include <utl/UtlHashMap.h>


// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// FORWARD DECLARATIONS
class SipMessage;
class UtlString;
class SipPublishContentMgr;

// TYPEDEFS

//! Class for specializing the handling of SIP Events in SipSubscribeServer
/*! This class provides the default behavior for SIP event packages
 *  handled by SipSubscribeServer.  Event packages which wish to change
 *  or extend the default behavior should derived from this class and
 *  override the behavior of methods implemented by this class.
 *
 * \par 
 */
class SipSubscribeServerEventHandler
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:



/* ============================ CREATORS ================================== */

    //! Default Dialog constructor
    SipSubscribeServerEventHandler();


    //! Destructor
    virtual
    ~SipSubscribeServerEventHandler();


/* ============================ MANIPULATORS ============================== */

    /** Determine what the resourceId, eventTypeKey, and eventType
     *  should be for this SUBSCRIBE request.
     *  The default behavior is to use the identify from the request URI
     *  as the resourceId and the event type token from the Event header
     *  as the eventTypeKey.  Some event packages may wish to override
     *  this (e.g. the host part of the resourceID, which will usually be an
     *  IP addressmay make sense in some cases  to be substituted with the 
     *  domain name.  In some event packages, the content of the event state
     *  information will vary based upon some Event header parameters, in
     *  which cases it may make sense to include that event header parameter
     *  in a consistant order and format in the eventTypeKey.)
     */
    virtual UtlBoolean getKeys(const SipMessage& subscribeRequest,
                               UtlString& resourceId,
                               UtlString& eventTypeKey,
                               UtlString& eventType);

    //! Determine if the given SUBSCRIBE request is authenticated to subscribe
    /*! Default behavior is to not require any authentication.
     */
    virtual UtlBoolean isAuthenticated(const SipMessage& subscribeRequest,
                                       const UtlString& resourceId,
                                       const UtlString& eventTypeKey,
                                       SipMessage& subscribeResponse);

    //! Determine if the given SUBSCRIBE request is authorized to subscribe
    /*! Default behavior is to allow any request to subscribe
     */
    virtual UtlBoolean isAuthorized(const SipMessage& subscribeRequest,
                                   const UtlString& resourceId,
                                   const UtlString& eventTypeKey,
                                   SipMessage& subscribeResponse);

    //! Fill in the event specific content for the identified resource and eventTypeKey
    /*! The default behavior is to attach the content yielded from 
     *  contentMgr->getContent.
     */
    virtual UtlBoolean getNotifyContent(const UtlString& resourceId,
                                        const UtlString& eventTypeKey,
                                        const UtlString& eventType,
                                        SipPublishContentMgr& contentMgr,
                                        const char* allowHeaderValue,
                                        SipMessage& notifyRequest);

/* ============================ ACCESSORS ================================= */


/* ============================ INQUIRY =================================== */


/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    //! Copy constructor NOT ALLOWED
    SipSubscribeServerEventHandler(const SipSubscribeServerEventHandler& rSipSubscribeServerEventHandler);

    //! Assignment operator NOT ALLOWED
    SipSubscribeServerEventHandler& operator=(const SipSubscribeServerEventHandler& rhs);


};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipSubscribeServerEventHandler_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////
// Author: Dan Petrie (dpetrie AT SIPez DOT com)

#ifndef _SipSubscriptionMgr_h_
#define _SipSubscriptionMgr_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES

#include <os/OsDefs.h>
#include <os/OsMsgQ.h>
#include <os/OsMutex.h>
#include <utl/UtlDefs.h>
#include <utl/UtlHashMap.h>
#include <utl/UtlHashBag.h>
#include <net/SipDialogMgr.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// FORWARD DECLARATIONS
class SipMessage;
class UtlString;
class SipDialogMgr;

// TYPEDEFS

//! Class for maintaining SUBSCRIBE dialog information in subscription server
/*! 
 *
 * \par 
 */
class SipSubscriptionMgr
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:



/* ============================ CREATORS ================================== */

    //! Default constructor
    SipSubscriptionMgr();

    //! Destructor
    virtual
    ~SipSubscriptionMgr();

/* ============================ MANIPULATORS ============================== */

    //! Add/Update subscription for the given SUBSCRIBE request
    virtual UtlBoolean updateDialogInfo(const SipMessage& subscribeRequest,
                                        const UtlString& resourceId,
                                        const UtlString& eventTypeKey,
                                        OsMsgQ* subscriptionTimeoutQueue,
                                        UtlString& subscribeDialogHandle,
                                        UtlBoolean& isNew,
                                        UtlBoolean& isExpired,
                                        SipMessage& subscribeResponse);

    //! Set the subscription dialog information and cseq for the next NOTIFY request
    virtual UtlBoolean getNotifyDialogInfo(const UtlString& subscribeDialogHandle,
                                           SipMessage& notifyRequest);

    //! Construct a NOTIFY request for each subscription/dialog subscribed to the given resourceId and eventTypeKey
    /*! Allocates a SipMessage* array and allocates a SipMessage and sets the
     * dialog information for the NOTIFY request for each subscription.
     *  \param numNotifiesCreated - number of pointers to NOTIFY requests in
     *         the returned notifyArray
     *  \param notifyArray - if numNotifiesCreated > 0 array is allocated of
     *         sufficient size to hold a SipMessage for each subscription.
     */
    virtual UtlBoolean createNotifiesDialogInfo(const char* resourceId,
                                                const char* eventTypeKey,
                                                int& numNotifiesCreated,
                                                UtlString**& acceptHeaderValuesArray,
                                                SipMessage**& notifyArray);

    //! frees up the notifies created in createNotifiesDialogInfo
    virtual void freeNotifies(int numNotifies,
                              UtlString** acceptHeaderValues,
                              SipMessage** notifiesArray);

    //! End the dialog for the subscription indicated, by the dialog handle
    /*! Finds a matching dialog and expires the subscription if it has
     *  not already expired.
     *  \param dialogHandle - a fully established SIP dialog handle
     *  Returns TRUE if a matching dialog was found regardless of
     *  whether the subscription was already expired or not.
     */
    virtual UtlBoolean endSubscription(const UtlString& dialogHandle);

    //! Remove old subscriptions that expired before given date
    void removeOldSubscriptions(long oldEpochTimeSeconds);

/* ============================ ACCESSORS ================================= */


    //! Get the dialog manager
    /*! WARNING: the application must be aware of the lifetime of
     *  the dialog manager, as no reference counting is done on
     *  the dialog manager.  The application is responsible for
     *  knowing when the dialog manager will go way.
     */
    SipDialogMgr* getDialogMgr();

/* ============================ INQUIRY =================================== */

    //! inquire if the dialog exists
    virtual UtlBoolean dialogExists(UtlString& dialogHandle);

    //! inquire if the dialog has already expired
    virtual UtlBoolean isExpired(UtlString& dialogHandle);

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    //! Copy constructor NOT ALLOWED
    SipSubscriptionMgr(const SipSubscriptionMgr& rSipSubscriptionMgr);

    //! Assignment operator NOT ALLOWED
    SipSubscriptionMgr& operator=(const SipSubscriptionMgr& rhs);

    //! lock for single thread use
    void lock();

    //! unlock for use
    void unlock();

    int mEstablishedDialogCount;
    OsMutex mSubscriptionMgrMutex;
    SipDialogMgr mDialogMgr;
    int mMinExpiration;
    int mDefaultExpiration;
    int mMaxExpiration;

    // Container for the subscritption states
    UtlHashMap mSubscriptionStatesByDialogHandle;

    // Index to subscription states in mSubscriptionStatesByDialogHandle
    // indexed by the resourceId and eventTypeKey
    UtlHashBag mSubscriptionStateResourceIndex;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipSubscriptionMgr_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipTcpServer_h_
#define _SipTcpServer_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <os/OsServerSocket.h>
#include <net/SipProtocolServerBase.h>


// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class SipUserAgent;

enum EventSubTypes
{
    SIP_SERVER_BROKER_NOTIFY = 1
};

class SipServerBrokerListener : public OsServerTask
{
public:
    SipServerBrokerListener(SipProtocolServerBase* pOwner) :
        OsServerTask("SipTcpServerBrokerListener-%d", (void*)pOwner),
        mpOwner(pOwner)
        {
            start();
        }
        virtual ~SipServerBrokerListener()
        {
            waitUntilShutDown();
        }
        virtual UtlBoolean handleMessage(OsMsg& rMsg);
    private:
        SipProtocolServerBase* mpOwner;
};

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class SipTcpServer : public SipProtocolServerBase
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   SipTcpServer(int sipPort = SIP_PORT,
                SipUserAgent* userAgent = NULL,
                const char* protocolString = SIP_TRANSPORT_TCP,
                const char* taskName  = "SipTcpServer-%d",
                UtlBoolean bUseNextAvailablePort = FALSE,
                const char* szBindAddr = NULL);
     //:Default constructor


   virtual
   ~SipTcpServer();
     //:Destructor

/* ============================ MANIPULATORS ============================== */
    virtual UtlBoolean startListener();

    //void addEventConsumer(OsServerTask* messageEventListener);
    //void removeEventConsumer(OsServerTask* messageEventListener);

    void shutdownListener();

    int run(void* pArg);

/* ============================ ACCESSORS ================================= */

    int getServerPort() const ;
    //: The the local server port for this server

/* ============================ INQUIRY =================================== */


/* ============================ Enumerations ============================== */
    
/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    OsStatus createServerSocket(const char* szBindAddr,
                                int& port,
                                const UtlBoolean& bUseNextAvailablePort);
                                
    
    virtual OsSocket* buildClientSocket(int hostPort, const char* hostAddress, const char* localIp);
    
    int mServerPort;
    
    UtlHashMap mServerBrokers;

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    SipTcpServer(const SipTcpServer& rSipTcpServer);
        //: disable Copy constructor

    SipTcpServer& operator=(const SipTcpServer& rhs);
     //:disable Assignment operator

};


/* ============================ INLINE METHODS ============================ */

#endif  // _SipTcpServer_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipTlsServer_h_
#define _SipTlsServer_h_

#ifdef SIP_TLS

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <net/SipProtocolServerBase.h>
#include <os/OsTLSServerSocket.h>
#include "os/OsTLSClientConnectionSocket.h"
// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class SipTlsServer : public SipProtocolServerBase
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   SipTlsServer(int sipPort = SIP_TLS_PORT, 
                SipUserAgent* userAgent = NULL,
                UtlBoolean bUseNextAvailablePort = FALSE,
                UtlString certNickname = "",
                UtlString certPassword = "",
                UtlString dbLocation = ".",
                const char* szBoundIp = "0.0.0.0");
     //:Default constructor


   virtual
   ~SipTlsServer();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */

    int getServerPort() const ;
    //: The the local server port for this server

    OsStatus getTlsInitCode() { return mTlsInitCode; }

    UtlBoolean startListener();
    void shutdownListener();
    int run(void* pArg);

    UtlHashMap mServerBrokers;


/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    virtual OsSocket* buildClientSocket(int hostPort, const char* hostAddress, const char* localIp);
    
    OsStatus createServerSocket(const char* szBindAddr,
                                int& port,
                                const UtlBoolean& bUseNextAvailablePort);

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    UtlString mCertNickname;
    UtlString mCertPassword;
    UtlString mDbLocation;
    int mServerPort;
    OsStatus mTlsInitCode;

    SipTlsServer(const SipTlsServer& rSipTlsServer);
    //: disable Copy constructor

    SipTlsServer& operator=(const SipTlsServer& rhs);
    //:disable Assignment operator

};

/* ============================ INLINE METHODS ============================ */

#endif  // SIP_TLS
#endif  // _SipTlsServer_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipTransaction_h_
#define _SipTransaction_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES


#include <os/OsDefs.h>
#include <os/OsSocket.h>
#include <os/OsMsgQ.h>
#include <net/Url.h>
#include <net/SipSrvLookup.h>
#include <utl/UtlSList.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class SipMessage;
class SipUserAgent;
class OsEvent;
class OsTimer;
class SIPX_TRANSPORT_DATA;
class SipTransactionList;

//#include "tapi/sipXtapiInternal.h"

/** SipTransaction correlates requests and responses.
 * 
 * CallId  + 's' or 'c' (for server or client) is used as
 * the key for the hash (i.e. stored as the string/data in
 * the parent UtlString.
 */
class SipTransaction : public UtlString {
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    static int smTransactionNum;
    static UtlString smBranchIdBase;


    /*** States of a transaction.
     * @note
     *   See RFC 3261 for a defininition and description
     *   of these transaction states and when the transitions occur.
     * @endnote
     */
    enum transactionStates {
        TRANSACTION_UNKNOWN = 0,       ///< not yet set
        TRANSACTION_LOCALLY_INIITATED, ///< No messages sent (usually client)
        TRANSACTION_CALLING,           ///< Request sent
        TRANSACTION_PROCEEDING,        ///< Provisional response received
        TRANSACTION_COMPLETE,          ///< Final response received
        TRANSACTION_CONFIRMED,         ///< ACK recieved for 300-699 response classes
        TRANSACTION_TERMINATED
    };

    /// The relationship of a message to a transaction
    enum messageRelationship {
        MESSAGE_UNKNOWN,          ///< Relationship not yet determined, or error
        MESSAGE_UNRELATED,        ///< A with different Call-Id, To or From
        MESSAGE_SAME_SESSION,     ///< But not part of this TX or related branches
        MESSAGE_DIFFERENT_BRANCH, ///< Same Call-Id, to, from, cseq but different TX
        MESSAGE_REQUEST,          ///< The request to this TX
        MESSAGE_PROVISIONAL,      ///< A provision response to this TX
        MESSAGE_FINAL,            ///< The first final response to this TX
        MESSAGE_NEW_FINAL,        ///< A different final response for this TX
        MESSAGE_CANCEL,           ///< A cancel for this TX
        MESSAGE_CANCEL_RESPONSE,
        MESSAGE_ACK,              ///< An ACK for this non-2xx TX
        MESSAGE_2XX_ACK,          ///< An ACK assocated with this TX (but considered a different TX)
        MESSAGE_DUPLICATE         ///< A duplicate message for this TX
    };

/* ============================ CREATORS ================================== */

    SipTransaction(SipMessage* request = NULL,
                   UtlBoolean isOutgoing = TRUE,
                   UtlBoolean userAgentTransaction = TRUE);
    //:Default constructor
    // When this is an out going request, this is a client
    // transaction.  The via header field MUST be added before
    // constructing this transaction as this sets the branch ID.
    //! param: userAgentTransaction - user agent (vs proxy) client or
    //         server



    virtual
    ~SipTransaction();
    //:Destructor

/* ============================ MANIPULATORS ============================== */

    void getNewBranchId(SipMessage& request,
                        UtlString& branchId);

    UtlBoolean handleOutgoing(SipMessage& outgoingMessage,
                             SipUserAgent& userAgent,
                             SipTransactionList& transactionList,
                             enum messageRelationship relationship,
                             SIPX_TRANSPORT_DATA* pTransport = NULL);

    void handleResendEvent(const SipMessage& outgoingMessage,
                            SipUserAgent& userAgent,
                            enum messageRelationship relationship,
                            SipTransactionList& transactionList,
                            int& nextTimeout,
                            SipMessage*& delayedDispatchedMessage,
                            SIPX_TRANSPORT_DATA* pTransport);

    void handleExpiresEvent(const SipMessage& outgoingMessage,
                            SipUserAgent& userAgent,
                            enum messageRelationship relationship,
                            SipTransactionList& transactionList,
                            int& nextTimeout,
                            SipMessage*& delayedDispatchedMessage,
                            SIPX_TRANSPORT_DATA* pTransport);

    UtlBoolean handleIncoming(SipMessage& incomingMessage,
                             SipUserAgent& userAgent,
                             enum messageRelationship relationship,
                             SipTransactionList& transactionList,
                             SipMessage*& delayedDispatchedMessage,
                             SIPX_TRANSPORT_DATA* pTransport);

    void removeTimer(OsTimer* timer);

    void stopTimers() ;
    void startTimers();
    void deleteTimers();

/* ============================ Deprecated ============================== */

    void linkChild(SipTransaction& child);

    void toString(UtlString& dumpString,
                  UtlBoolean dumpMessagesAlso);
    //: Serialize the contents of this

    void dumpTransactionTree(UtlString& dumpstring, 
                             UtlBoolean dumpMessagesAlso);
    //: Serialize the contents of all the transactions in this tree
    // The parent is found first and then all children are serialized
    // recursively

    void dumpChildren(UtlString& dumpstring, 
                      UtlBoolean dumpMessagesAlso);
    //: Serialize the contents of all the child transactions to this transaction
    // All children are serialized recursively


/* ============================ ACCESSORS ================================= */

    static void getStateString(enum transactionStates state,
                               UtlString& stateString);

    static void getRelationshipString(enum messageRelationship relationship,
                                      UtlString& relationshipString);

    static void buildHash(const SipMessage& message, 
                          UtlBoolean isOutgoing,
                          UtlString& hash);

    SipTransaction* getTopMostParent() const;

    void getCallId(UtlString& callId) const;

    enum transactionStates getState() const;

    long getStartTime() const;

    long getTimeStamp() const;

    void touch();
    void touchBelow(int newDate);

    SipMessage* getRequest();

    SipMessage* getLastProvisionalResponse();

    SipMessage* getLastFinalResponse();

    void cancel(SipUserAgent& userAgent,
                SipTransactionList& transactionList);
    //: cancel any outstanding client transactions (recursively on children)

    void markBusy();

    void markAvailable();

    void notifyWhenAvailable(OsEvent* availableEvent);
    //: The given event is signaled when this transaction is not busy

    void signalNextAvailable();

    void signalAllAvailable();

/* ============================ INQUIRY =================================== */

    UtlBoolean isServerTransaction() const;
    //: Inquire if this transaction is a server as opposed to a client transaction

    //! Inquiry as to whether this transaction is a recursed DNS SRV child
    UtlBoolean isDnsSrvChild() const;

    UtlBoolean isUaTransaction() const;
    //: Inquire if transaction is UA based or proxy
    // Note this is different than server vs client transaction

    UtlBoolean isChildSerial();
    //: Inquire as to whether child transaction will be serial or all parallel searched
    // If all immediate child transactions have the same 
    // Q value FALSE is returned

    UtlBoolean isEarlyDialogWithMedia();
    //: Tests to see if this is an existing early dialog with early media
    // If transaction has not yet been completed and there was early media
    // (determined by the presence of SDP in a provisional response

    UtlBoolean isChildEarlyDialogWithMedia();
    //: Are any of the children in an early dialog with media

    UtlBoolean isMethod(const char* methodToMatch) const;
    //: see if this tranaction is of the given method type

    enum messageRelationship whatRelation(const SipMessage& message,
                                          UtlBoolean isOutgoing) const;
    //: Check if the given message is part of this transaction

    UtlBoolean isBusy();
    //: is this transaction being used (e.g. locked)

    //UtlBoolean isDuplicateMessage(SipMessage& message,
    //                             UtlBoolean checkIfTransactionMatches = TRUE);
    //: Check to see if this request or response has already been received by this transaction

    UtlBoolean isUriChild(Url& uri);
    // Does this URI already exist as an immediate child to this transaction
    // Search through each of the children and see if the child
    // transaction's URI matches.

    UtlBoolean isUriRecursed(Url& uri);
    // Has this URI been recursed anywhere in this transaction tree already
    // Start looking at the parent

    UtlBoolean isUriRecursedChildren(UtlString& uriString);
    // Has this URI been recursed anywhere at or below in this transaction tree already
    // Look at or below the current transaction in the transaction tree

    void setTransport(SIPX_TRANSPORT_DATA* pTransport) { mpTransport = pTransport; }
    // Mutator for mpTransport.

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    void handleChildTimeoutEvent(SipTransaction& child,
                                 const SipMessage& outgoingMessage,
                                 SipUserAgent& userAgent,
                                 enum messageRelationship relationship,
                                 SipTransactionList& transactionList,
                                 int& nextTimeout,
                                 SipMessage*& delayedDispatchedMessage,
                                 SIPX_TRANSPORT_DATA* pTransport);
    //: tells the parent transaction the result of the timeout event

    UtlBoolean handleChildIncoming(//SipTransaction& child,
                                  SipMessage& incomingMessage,
                                  SipUserAgent& userAgent,
                                  enum messageRelationship relationship,
                                  SipTransactionList& transactionList,
                                  UtlBoolean childSaysShouldDispatch,
                                  SipMessage*& delayedDispatchedMessage,
                                  SIPX_TRANSPORT_DATA* pTransport);
    //: Tells the parent transaction the result of the incoming message
    //! returns: TRUE/FALSE as to whether the message should be dispatched to applications

    UtlBoolean startSequentialSearch(SipUserAgent& userAgent,
                                    SipTransactionList& transactionList,
                                    SIPX_TRANSPORT_DATA* pTransport);
    //: Checks to see if a final response can be sent or if sequential search should be started

    UtlBoolean recurseChildren(SipUserAgent& userAgent,
                              SipTransactionList& transactionList);
    //: Starts search on any immediate children of the highest unpursued Q value

    UtlBoolean recurseDnsSrvChildren(SipUserAgent& userAgent,
                              SipTransactionList& transactionList,
                              SIPX_TRANSPORT_DATA* pTransport);
    //: Starts search on any immediate DNS SRV children of the highest unpursued Q value

    UtlBoolean findBestResponse(SipMessage& bestResponse);
    // Finds the best final response to return the the server transaction

    enum messageRelationship addResponse(SipMessage*& response,
                                         UtlBoolean isOutGoing,
                                         enum messageRelationship relationship = MESSAGE_UNKNOWN);
    //: Adds the provisional or final response to the transaction

    void cancelChildren(SipUserAgent& userAgent,
                        SipTransactionList& transactionList);
    //: Cancels children transactions on a server transaction

    void doMarkBusy(int markValue);

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    SipTransaction(const SipTransaction& rSipTransaction);
    //:Copy constructor (disabled)
    SipTransaction& operator=(const SipTransaction& rhs);
    //:Assignment operator (disabled)

    UtlBoolean doResend(SipMessage& resendMessage,
                       SipUserAgent& userAgent,
                       int& nextTimeoutMs,
                       SIPX_TRANSPORT_DATA* pTransport);

    UtlBoolean doFirstSend(SipMessage& message,
                          enum messageRelationship relationship,
                          SipUserAgent& userAgent,
                          UtlString& toAddress,
                          int& port,
                          OsSocket::IpProtocolSocketType& toProtocol,
                          SIPX_TRANSPORT_DATA* pTransport);

    void prepareRequestForSend(SipMessage& request,
                               SipUserAgent& userAgent,
                               UtlBoolean& addressRequiresDnsSrvLookup,
                               UtlString& toAddress,
                               int& port,
                               OsSocket::IpProtocolSocketType& toProtocol);

    // CallId  + 's' or 'c' (for server or client) is used as
    // the key for the hash (i.e. stored as the string/data in
    // the parent UtlString
    UtlString mCallId;
    UtlString mBranchId;
    UtlString mRequestUri;
    Url mFromField;
    Url mToField;
    UtlString mRequestMethod;
    int mCseq;
    UtlBoolean mIsServerTransaction; ///< TRUE = server, FALSE = client
    UtlBoolean mIsUaTransaction;     ///< UA or proxy transaction

    // Address and transport that have been established for this transaction.
    UtlString mSendToAddress;
    int mSendToPort;
    OsSocket::IpProtocolSocketType mSendToProtocol;

    server_t* mpDnsSrvRecords;
    SipMessage* mpRequest;
    SipMessage* mpLastProvisionalResponse;
    SipMessage* mpLastFinalResponse;
    SipMessage* mpAck;
    SipMessage* mpCancel;
    SipMessage* mpCancelResponse;
    SipTransaction* mpParentTransaction;
    UtlSList mChildTransactions;
    long mTransactionCreateTime;         ///< When this thing was created
    long mTransactionStartTime;          /**<  When the request was sent/received
                                          * i.e. went to TRANSACTION_CALLING state */
    long mTimeStamp;                     ///< When this was last used
    enum transactionStates mTransactionState;
    UtlBoolean mDispatchedFinalResponse; ///< For UA recursion
    UtlBoolean mProvisionalSdp;          ///< early media
    UtlSList mTimers;                    /**< A list of all outstanding timers
                                          *   started by this transaction. */

    // Recursion members
    UtlBoolean mIsCanceled;
    UtlBoolean mIsRecursing;   ///< TRUE if any braches have not be pursued
    UtlBoolean mIsDnsSrvChild; ///< This CT pursues one of the SRV records of the parent CT
    double mQvalue;            ///< Recurse order.  equal values are recursed in parallel
    int mExpires;              ///< Maximum time (seconds) to wait for a final outcome
    UtlBoolean mIsBusy;
    UtlString mBusyTaskName;
    UtlSList* mWaitingList;    /**< Events waiting until this is available
                                * Note only a parent tx should have a waiting list */
    SIPX_TRANSPORT_DATA* mpTransport; 
    //: An optional external transport mechanism pointer.  If this value is non-null, the
    //: transaction will use the SipUserAgent::sendCustom method, instead of sendUdp, sendTcp, etc.

};

/* ============================ INLINE METHODS ============================ */

#endif // _SipTransaction_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipTransactionList_h_
#define _SipTransactionList_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include <utl/UtlHashBag.h>

#include <os/OsDefs.h>
#include <os/OsMutex.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

class SipMessage;

//:Class short description which may consist of multiple lines (note the ':')
// Class detailed description which may extend to multiple lines
class SipTransactionList {
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

    SipTransactionList();
    //:Default constructor

    virtual
    ~SipTransactionList();
    //:Destructor

/* ============================ MANIPULATORS ============================== */

    void addTransaction(SipTransaction* transaction,
                        UtlBoolean lockList = TRUE);
    //: Adds a transaction to the list
    // Note: does not make a copy

    SipTransaction* findTransactionFor(const SipMessage& message,
                                       UtlBoolean isOutgoing,
                                       enum SipTransaction::messageRelationship& relationship);
    //: Find a transaction for the given message
    // Note: the caller should first lock the list and keep
    // it locked until all access of the transaction is complete

    UtlBoolean transactionExists(const SipTransaction* transaction,
                                const UtlString& hash);
    //: Used to confirm a transaction is still good and has not been deleted
    // Note: this should only be used inside of a lock to prevent any sort
    // of delete race.

    UtlBoolean waitUntilAvailable(SipTransaction* transaction,
                                 const UtlString& hash);
    //: waits until the transaction is available and them marks it as busy
    // Note: be sure to check the return.  If returns false the transaction
    // is not locked or available.  Most likely as it got removed from
    // the list (e.g. deleted)

    void markAvailable(SipTransaction& transaction);
    //: Marks the transaction as available

    void removeOldTransactions(long oldTransaction,
                               long oldTcpTransaction);
    //: Remove transactions not accessed after given time

    void stopTransactionTimers();
    void startTransactionTimers();

    void deleteTransactionTimers();

/* ============================ ACCESSORS ================================= */

    void toString(UtlString& string);

    void toStringWithRelations(UtlString& string,
                               SipMessage& message,
                               UtlBoolean isOutGoing);

/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    void lock();
    //: Locks the list for iteration, reading or writing

    void unlock();
    //: Unlock

/* //////////////////////////// PRIVATE /////////////////////////////////// */
    private:
    SipTransactionList(const SipTransactionList& rSipTransactionList);
    //:Copy constructor (disabled)

    SipTransactionList& operator=(const SipTransactionList& rhs);
    //:Assignment operator

    UtlHashBag mTransactions;
    OsMutex mListMutex;

};

/* ============================ INLINE METHODS ============================ */

#endif
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _SipUdpServer_h_
#define _SipUdpServer_h_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include <net/SipProtocolServerBase.h>
#include <os/OsNatKeepaliveListener.h>
#include <utl/UtlSList.h>
#include <os/OsRWMutex.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class SipUserAgent;
class OsNatDatagramSocket ;
class OsNotification ;
class OsTimer;


/**
 * The SipUdpServer is owner/container of the sockets used for UDP 
 * communications.  The SipUdpServer has a number of NAT APIs and
 * coordinates NAT detection/keepalives with the OsNatDatagramSocket / 
 * OsNatAgentTask.
 * 
 * The SipUdpServer may contain multiple sockets if being used in a multi-
 * home configuration.  This mostly works, but needs additional testing
 * and tweaking.
 *
 * Most of the NAT keepalives are delegated to the OsNatAgentTask.  The 
 * exception is the Sip keepalive.  For this, the SipUdpServer uses 
 * callbacks to send off the Sip messages (as opposed to introducing a 
 * OsMsgQueue).  The SipUdpServer never listens for responses, however, 
 * the SipUserAgent itself pays attention to rport results and notifies 
 * the OsNatAgentTask of local ip -> remote IP NAT bindings.
 */
class SipUdpServer : public SipProtocolServerBase
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   SipUdpServer(int sipPort = SIP_PORT,
       SipUserAgent* userAgent = NULL,
       int udpReadBufferSize = -1,
       UtlBoolean bUseNextAvailablePort = FALSE,
       const char* szBoundIp = NULL);
     //:Default constructor


   virtual
   ~SipUdpServer();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

    int run(void* pArg);

    void shutdownListener();

    void enableStun(const char* szStunServer, 
                    int iStunPort,
                    const char* szLocalIp, 
                    int refreshPeriodInSecs, 
                    OsNotification* pNotification) ;
      //:Enable stun lookups for UDP signaling
      // Use a NULL szStunServer to disable

    UtlBoolean sendTo(const SipMessage& message,
                     const char* address,
                     int port,
                     const char* szLocalSipIp = NULL);

    UtlBoolean addCrLfKeepAlive(const char* szLocalIp,
                                const char* szRemoteIp,
                                const int   remotePort,
                                const int   keepAliveSecs,
                                OsNatKeepaliveListener* pListener) ;

    UtlBoolean removeCrLfKeepAlive(const char* szLocalIp,
                                   const char* szRemoteIp,
                                   const int   remotePort) ;

    UtlBoolean addStunKeepAlive(const char* szLocalIp,
                                const char* szRemoteIp,
                                const int   remotePort,
                                const int   keepAliveSecs,
                                OsNatKeepaliveListener* pListener) ;

    UtlBoolean removeStunKeepAlive(const char* szLocalIp,
                                   const char* szRemoteIp,
                                   const int   remotePort) ;

    UtlBoolean addSipKeepAlive(const char* szLocalIp,
                               const char* szRemoteIp,
                               const int   remotePort,
                               const char* szMethod,
                               const int   keepAliveSecs,
                               OsNatKeepaliveListener* pListener) ;

    UtlBoolean removeSipKeepAlive(const char* szLocalIp,
                                  const char* szRemoteIp,
                                  const int   remotePort,
                                  const char* szMethod) ;

    void updateSipKeepAlive(const char* szLocalIp,
                            const char* szMethod,
                            const char* szRemoteIp,
                            const int   remotePort,
                            const char* szContactIp,
                            const int   contactPort) ;


    void sendSipKeepAlive(OsTimer* pTimer) ; 

    static void SipKeepAliveCallback(const int userData, 
                                     const int eventData) ;

/* ============================ ACCESSORS ================================= */

    void printStatus();

    int getServerPort(const char* szLocalIp = NULL) ;

    UtlBoolean getStunAddress(UtlString* pIpAddress,
                              int* pPort,
                              const char* szLocalIp = NULL) ;

    UtlBoolean addKeepAliveBinding(void* pBinding) ;
    UtlBoolean removeKeepAliveBinding(void* pBinding) ;

    void* findKeepAliveBinding(OsTimer* pTimer) ;

    void* findKeepAliveBinding(OsSocket*   pSocket,
                               const char* szRemoteIp,
                               const int   remotePort,
                               const char* szMethod) ;


/* ============================ INQUIRY =================================== */


/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

    OsSocket* buildClientSocket(int hostPort,
                                const char* hostAddress,
                                const char* localIp);

    OsMutex mMapLock;

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    UtlString mStunServer ;
    int mStunRefreshSecs ;
    int mStunPort ;
    UtlSList mSipKeepAliveBindings ;
    OsRWMutex mKeepAliveMutex ;

    OsStatus createServerSocket(const char* localIp,
                                 int& localPort,
                                 const UtlBoolean& bUseNextAvailablePort,
                                 int udpReadBufferSize);

    SipUdpServer(const SipUdpServer& rSipUdpServer);
    //: disable Copy constructor

    SipUdpServer& operator=(const SipUdpServer& rhs);
     //:disable Assignment operator
     

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipUdpServer_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipUserAgent_h_
#define _SipUserAgent_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <utl/UtlHashBag.h>
#include <os/OsServerTask.h>
#include <net/SipUserAgentBase.h>
#include <net/SipMessage.h>
#include <net/SipMessageEvent.h>
#include <net/SipTransaction.h>
#include <net/SipTransactionList.h>
#include <net/SipUdpServer.h>
#include <os/OsQueuedEvent.h>
#ifdef SIP_TLS
#include <net/SipTlsServer.h>
#include <os/OsTLS.h>
#endif
#include <os/OsNatKeepaliveListener.h>

// DEFINES
#define SIP_DEFAULT_RTT     500
#define SIP_MINIMUM_RTT     100
#define SIP_MAX_PORT_RANGE  10  // If a port is in use and the sip user agent 
                                // is created with bUseNextAvailablePort set to
                                // true, this is the number of sequential ports
                                // to try.

// proxy, registrar, etc. UDP socket buffer size
#define SIPUA_DEFAULT_SERVER_UDP_BUFFER_SIZE 1000000

// proxy, registrar, etc. OsServerTask OsMsg queue size
#define SIPUA_DEFAULT_SERVER_OSMSG_QUEUE_SIZE 10000

// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class OsConfigDb;
class OsQueuedEvent;
class OsTimer;
class SipSession;
class SipTcpServer;
class SipLineMgr;
class SipUserAgentBase;

//! Transaction and Transport manager for SIP stack
/*! Note SipUserAgent is perhaps not the best name for this class.
 * It is really the transaction and transport layers of
 * of a SIP stack which may be used in a User Agent or
 * server context.
 *
 * \par Using SipUserAgent
 *
 * The SipUserAgent is the primary interface for incoming
 * and out going SIP messages.  It handles all of the
 * reliability, resending, canceling and IP layer protocol
 * details.  Application developers that wish to send or
 * recieve SIP messages can use SipUserAgent without having
 * to worry about the transaction and transport details.
 * \par
 * Applications send SIP messages via the send() method.  Incoming
 * messages are received on an OsMsgQ to be handled by the
 * application.  The message queue must be registered with
 * the SipUserAgent via addMessageObserver() before they
 * can receive incoming messages.  Alternatively applications
 * that are only interested in a specific transaction can
 * pass the OsMsgQ as part of the send() method invocation.
 * Messages which fail to be sent due to transport problems
 * will be communicated back in one of three different ways:
 * -# send() returns a failure indication synchronously (e.g.
 *        due to unresolvable DNS name)
 * -# the send fails asynchronously (e.g. ICMP error) and puts
 *        a message in the OsMsgQ with a transport failure indication
 * -# the send succeeds, but the transaction fails or times out
 *        due to the lack of completion or responses to a request. In
 *        this case a message is put in the OsMsgQ with a transport
 *        failure indication.
 *
 * In the asynchronous cases where a message is put in the message
 * queue to indicate the failure, the original SIP message is attached
 * so that the application can determine which SIP message send failed.
 *
 * \par Internal Implementation Overview
 *
 * All state information will be contained in transactions
 * and/or the messages contained by a transaction.  The transaction
 * will keep track of what protocols to use and when as well as
 * when to schedule timers. send() will no longer be used for
 * resending.  It will only be used for the first time send.
 *
 * The flow for outgoing messages is something like the
 * following:
 * - 1) An application calls send() to send a SIP request or response
 * - 2) send() for requests: constructs a client transaction,
 *    for: responses finds an existing server transaction
 * - 3) send() asks the transaction how (i.e. protocol) and whether to
 *    send the message
 * - 4) send() calls the appropriate transport sender (e.g. sendUdp, sendTcp)
 * - 5A) If the send succeeded: send() asks the transaction to schedule
 *     a timeout for resending the message or failing the transaction
 * - 5B) If the send failed: send() asks the transaction whether to:
 *     - a) dispatch the transport error and mark the transaction state
 *         to indicate the failure.
 *     - b) try another protocol and repeat starting at step 4 above
 *
 * Timeouts are handled by handle message in the following flow:
 * - 1) The timeout expires and posts a SipMessageEvent on the
 *    SipUserAgent's queue which invokes handleMessage
 * - 2) handleMessage() finds the transaction for the timeout
 * - 3) handleMessage() asks the transaction if it should resend
 *    the message.
 * - 4A) The message may not be resent for one of a number of reasons:
 *     - a) a response or ACK was recieved
 *     - b) the transaction was canceled
 *     - c) It is time to give up and fail the transaction
 *     In the latter case an error must be dispatched to the
 *     application.  In the other cases nothing is done.
 * - 4B) If the message is to be resent, the transaction tells
 *     which protocol sender to use (as in steps 4 & 5 above
 *     for outbound messages).
 *
 * Inbound messages are still sent via dispatch.  The flow is now a
 * little different due to the use of transaction objects
 * - 1) dispatch() finds a matching transaction for non transport error
 *    messages.
 * - 2A) If the message is a duplicate it is dropped on the floor
 * 2B) If the message is a new request, a server transaction is
 *     created
 * - 2C) If the message is a new response, for an exising client
 *     transaction, it is sent to the interested observers, with
 *     the original request attached.
 * - 2D) If the message is a response with no existing transaction,
 *     it is dropped on the floor ??I think it should be for UAC
 *     transactions anyway.  Proxy client response may need to be
 *     sent to observers??
 * - 3) If the message was not dropped on the floor by step 2A or 2D,
 *    the message is sent to the interested observers
 */

class SipUserAgent : public SipUserAgentBase 
#ifdef SIP_TLS
                     , public ITlsSink
#endif 
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    friend class SipTransaction;
    friend class SipUdpServer;
    friend int SipUdpServer::run(void* runArg);

    enum EventSubTypes
    {
        UNSPECIFIED = 0,
        SHUTDOWN_MESSAGE = 10,
        KEEPALIVE_MESSAGE
    };

/* ============================ CREATORS ================================== */

    //! Constructor
    /*! Sets up listeners on the defined ports and IP layer
     * protocols for incoming SIP messages.
     * \param sipTcpPort - port to listen on for SIP TCP messages.
     *        Specify PORT_DEFAULT to automatically select a port, or
     *        PORT_NONE to disable.
     * \param sipUdpPort - port to listen on for SIP UDP messages.
     *        Specify PORT_DEFAULT to automatically select a port, or
     *        PORT_NONE to disable.
     * \param sipTlsPort - port to listen on for SIP TLS messages.
     *        Specify PORT_DEFAULT to automatically select a port, or
     *        PORT_NONE to disable.
     * \param publicAddress - use this address in Via and Contact headers
     *        instead of the actual adress.  This is useful for address
     *        spoofing in a UA when behind a NAT
     * \param defaultUser - default user ID to use in Contacts which get
     *        inserted when missing on a UA.
     * \param defaultSipAddress - deprecated
     * \param sipProxyServers - server to which non-routed requests should
     *        be sent for next hop before going to the final destination
     * \param sipDirectoryServers - deprecated
     * \param sipRegistryServers - deprecated
     * \param authenticationScheme - authentication scheme to use when
     *        challenging on behalf of the UA (i.e. 401).  Valid values
     *        are NONE and DIGEST.
     * \param authenicateRealm - The authentication realm to use when
     *        sending 401 challenges.
     * \param authenticateDb - the authentication DB to use when
     *        authenticating incoming requests on behalf of the UA
     *        application (as a result of locally generated 401 challenges
     * \param authorizeUserIds - depricated by the SipLineMgr
     * \param authorizePasswords - depricated by the SipLineMgr
     * \param lineMgr - SipLinMgr object which is container for user
     *        definitions and their credentials.  This is used to
     *        authenticate incoming requests to the UA application.
     * \param sipFirstResendTimeout - T1 in RFC 3261
     * \param defaultToUaTransactions - default transactions to be
     *        UA or PROXY.  TRUE means that this is a UA and associated
     *        validation should occur.  FALSE means that this is a
     *        PROXY and that minimal validation should occur.
     * \param readBufferSize - the default IP socket buffer size
     *        to use for the listener sockets.
     * \param queueSize - Size of the OsMsgQ to use for the queues
     *        internal to the SipUserAgent and subsystems.
     * \param bUseNextAvailablePort - When setting up the sip user 
     *        agent using the designated sipTcp, sipUdp, and sipTls
     *        ports, select the next available port if the supplied
     *        port is busy.  If enable, this will attempt at most
     *        10 sequential ports.
     * \param doUaMessageChecks - check the acceptability of method,
     *        extensions, and encoding.  The default is TRUE; it may 
     *        be set to false in applications such as a redirect server
     *        that will never actually send a 2xx response, so the
     *        checks might cause errors that the application should
     *        never generate.
     */
    SipUserAgent(int sipTcpPort = SIP_PORT,
                int sipUdpPort = SIP_PORT,
                int sipTlsPort = SIP_PORT+1,
                const char* publicAddress = NULL,
                const char* defaultUser = NULL,
                const char* defaultSipAddress = NULL,
                const char* sipProxyServers = NULL,
                const char* sipDirectoryServers = NULL,
                const char* sipRegistryServers = NULL,
                const char* authenticationScheme = NULL,
                const char* authenicateRealm = NULL,
                OsConfigDb* authenticateDb = NULL,
                OsConfigDb* authorizeUserIds = NULL,
                OsConfigDb* authorizePasswords = NULL,
                SipLineMgr* lineMgr = NULL,
                int sipFirstResendTimeout = SIP_DEFAULT_RTT,
                UtlBoolean defaultToUaTransactions = TRUE,
                int readBufferSize = -1,
                int queueSize = OsServerTask::DEF_MAX_MSGS,
                UtlBoolean bUseNextAvailablePort = FALSE,
                UtlString certNickname = "",
                UtlString certPassword = "",
                UtlString dbLocation = ".",
                UtlBoolean doUaMessageChecks = TRUE);

    //! Destructor
    virtual
    ~SipUserAgent();

/* ============================ MANIPULATORS ============================== */

    //! Cleanly shuts down SipUserAgent.
    /*! This method can block until the shutdown is complete, or it can be
     * non-blocking.  When complete, the SipUserAgent can be deleted.
     * \sa isShutdownDone
     *
     * \param blockingShutdown - TRUE if this method should block until the
     * shutdown is complete, FALSE if this method should be non-blocking.
     */
    void shutdown(UtlBoolean blockingShutdown = TRUE);

    //! Enable stun lookups for UDP signaling.  Use a NULL szStunServer to 
    //! disable
    virtual void enableStun(const char* szStunServer, 
                            int iStunPort,
                            int refreshPeriodInSecs, 
                            OsNotification* pNotification = NULL,
                            const char* szIp = NULL) ;

    //! For internal use only
    virtual UtlBoolean handleMessage(OsMsg& eventMessage);

    //! Deprecated (Add a SIP message recipient)
    virtual void addMessageConsumer(OsServerTask* messageConsumer);

    //! Add a SIP message observer for receiving SIP messages meeting the
    //! given filter criteria
    /*! SIP messages will be added to the \a messageQueue if they meet
     * the given filter criteria.
     *
     * \param messageQueue - the queue on which an SipMessageEvent is
     *        dispatched
     * \param sipMethod - the specific method type of the requests or
     *        responses to be observed.  NULL or a null string indicates
     *        all methods.
     * \param wantRequests - want to observe SIP requests
     * \param wantResponses - want to observe SIP responses
     * \param wantIncoming - want to observe SIP messages originating
     *        from the network.
     * \param wantOutGoing - (not implemented) want to observe SIP
     *        messages originating from locally.
     * \param eventName - want to observer SUBSCRIBE or NOTIFY requests
     *        having the given event type
     * \param pSession - want to observe SIP message with the
     *        specified session (call-id, to url, from url)
     * \param observerData - data to be attached to SIP messages queued
     *        on the observer
     */
    void addMessageObserver(OsMsgQ& messageQueue,
                              const char* sipMethod = NULL,
                              UtlBoolean wantRequests = TRUE,
                              UtlBoolean wantResponses = TRUE,
                              UtlBoolean wantIncoming = TRUE,
                              UtlBoolean wantOutGoing = FALSE,
                              const char* eventName = NULL,
                              SipSession* pSession = NULL,
                              void* observerData = NULL);


    //! Removes all SIP message observers for the given message/queue
    //! observer
    /*! This undoes what addMessageObserver() does.
     * \param messageQueue - All observers dispatching to this message queue
     *         will be removed if the pObserverData is NULL or matches.
     * \param pObserverData - If null, all observers that match the message
     *        queue will be removed.  Otherwise, only observers that match
     *        both the message queue and observer data will be removed.
     * \return TRUE if one or more observers are removed otherwise FALSE.
     */
    UtlBoolean removeMessageObserver(OsMsgQ& messageQueue,
                                    void* pObserverData = NULL);

    //! Send a SIP message over the net
    /*! This method sends the SIP message via
     * a SIP UDP or TCP client as dictated by policy and the address
     * specified in the message.  Most applications will register a
     * OsMsgQ via addMessageObserver() prior to calling send and so
     * should call send with only one argument.
     * \note If the application does register the message queue via
     * addMessageObserver() it should not pass the message queue as
     * an argument to send or it will receive multiple copies of the
     * incoming responses.
     * \param message - the sip message to be sent
     * \param responseListener - the optional queue on which to place
     *        SipMessageEvents containing SIP responses from the same
     *        transaction as the request sent in message
     * \param responseListenerData - optional data to be passed back
     *        with responses
     */
    virtual UtlBoolean send(SipMessage& message,
                            OsMsgQ* responseListener = NULL,
                            void* responseListenerData = NULL,
                            SIPX_TRANSPORT_DATA* pTransport = NULL);

    //! Dispatch the SIP message to the message consumer(s)
    /*! This is typically only used by the SipUserAgent and its sub-system.
     * So unless you know what you are doing you should not be using this
     * method. All incoming SIP message need to be dispatched via the
     * user agent server so that it can provide the reliablity for UDP
     * (i.e. resend requests when no response is received)
     * \param messageType - is as define by SipMessageEvent::MessageStatusTypes
     *        APPLICATION type are normal incoming messages
     *        TRANSPORT_ERROR type are notification of failures to
     *        send messages
     */
    virtual void dispatch(SipMessage* message,
                          int messageType = SipMessageEvent::APPLICATION,
                          SIPX_TRANSPORT_DATA* pData = NULL);

    void allowMethod(const char* methodName, const bool bAllow = true);

    void allowExtension(const char* extension);

    void getSupportedExtensions(UtlString& extensionsString);

    //! Set the SIP proxy servers for the user agent.
    /*! This method will clear any existing proxy servers before
     *  resetting this list.  NOTE: As for 12/2004, only the first
     *  proxy server is used.  Please consider using DNS SRV in
     *  until fully implemented.
     */
    void setProxyServers(const char* sipProxyServers);


    UtlBoolean addCrLfKeepAlive(const char* szLocalIp,
                                const char* szRemoteIp,
                                const int   remotePort,
                                const int   keepAliveSecs,
                                OsNatKeepaliveListener* pListener) ;

    UtlBoolean removeCrLfKeepAlive(const char* szLocalIp,
                                   const char* szRemoteIp,
                                   const int   remotePort) ;
 
    UtlBoolean addStunKeepAlive(const char* szLocalIp,
                                const char* szRemoteIp,
                                const int   remotePort,
                                const int   keepAliveSecs,
                                OsNatKeepaliveListener* pListener) ;

    UtlBoolean removeStunKeepAlive(const char* szLocalIp,
                                   const char* szRemoteIp,
                                   const int   remotePort) ;

    OsTimer* getTimer() { return mpTimer; }

    UtlBoolean addSipKeepAlive(const char* szLocalIp,
                               const char* szRemoteIp,
                               const int   remotePort,
                               const char* szMethod,
                               const int   keepAliveSecs,
                               OsNatKeepaliveListener* pListener) ;

    UtlBoolean removeSipKeepAlive(const char* szLocalIp,
                                  const char* szRemoteIp,
                                  const int   remotePort,
                                  const char* szMethod) ;

/* ============================ ACCESSORS ================================= */

    //! Enable or disable the outbound use of rport (send packet to actual
    //! port -- not advertised port).
    UtlBoolean setUseRport(UtlBoolean bEnable) ;

    //! Is use report set?
    UtlBoolean getUseRport() const ;

    //! Get the manually configured public address
    UtlBoolean getConfiguredPublicAddress(UtlString* pIpAddress, int* pPort) ;

    //! Get the local address and port
    UtlBoolean getLocalAddress(UtlString* pIpAddress,
                               int* pPort,
                               SIPX_TRANSPORT_TYPE protocol = TRANSPORT_UDP) ;

    //! Get the NAT mapped address and port
    UtlBoolean getNatMappedAddress(UtlString* pIpAddress, int* pPort) ;

    void setIsUserAgent(UtlBoolean isUserAgent);

    /// Provides a string to be appended to the standard User-Agent header.
    void setUserAgentHeaderProperty( const char* property );
    /**<
     * The property is added between "<product>/<version>" and the platform (eg "(VxWorks)")
     * The value should be formated either as "token/token", "token", or "(string)"
     * with no leading or trailing space.
     */

    //! Set the limit of allowed hops a message can make
    void setMaxForwards(int maxForwards);

    //! Get the limit of allowed hops a message can make
    int getMaxForwards();

    //! Allow or disallow recursion and forking of 3xx class requests
    void setForking(UtlBoolean enabled);

    void getFromAddress(UtlString* address, int* port, UtlString* protocol);

    void getViaInfo(int         protocol,
                    UtlString&  address,
                    int&        port,
                    const char* pszTargetAddress,
                    const int*  piTargetPort);

    void getDirectoryServer(int index, UtlString* address,
                            int* port, UtlString* protocol);

    void getProxyServer(int index, UtlString* address,
                        int* port, UtlString* protocol);

    //! Print diagnostics
    void printStatus();

    void startMessageLog(int newMaximumLogSize = 0);

    void stopMessageLog();

    void clearMessageLog();

    virtual void logMessage(const char* message, int messageLength);

    void getMessageLog(UtlString& logData);

    int getSipStateTransactionTimeout();

    int getDefaultExpiresSeconds() const;
    
    const int getRegisterResponseTimeout() const { return mRegisterTimeoutSeconds; }
    void setRegisterResponseTimeout(const int seconds) { mRegisterTimeoutSeconds = seconds; }

    void setDefaultExpiresSeconds(int expiresSeconds);

    int getDefaultSerialExpiresSeconds() const;

    void setLocationHeader(const char* szHeader);

    //! Tells the User Agent whether or not to append
    //! the platform name onto the User Agent string
    void setIncludePlatformInUserAgentName(const UtlBoolean bInclude);
    
    void setDefaultSerialExpiresSeconds(int expiresSeconds);

    //! Period of time a TCP socket can remain idle before it is removed
    void setMaxTcpSocketIdleTime(int idleTimeSeconds);

    //! Get the maximum number of DNS SRV records to pursue in the
    //! case of failover
    int getMaxSrvRecords() const;

    //! Set the maximum number of DNS SRV records to pursue in the
    //! case of failover
    void setMaxSrvRecords(int numRecords);

    //! Get the number of seconds to wait before trying the next DNS SRV record
    int getDnsSrvTimeout();

    //! Set the number of seconds to wait before trying the next DNS SRV record
    void setDnsSrvTimeout(int timeout);

    //! Set other DNS names or IP addresses which are considered to
    //! refer to this SipUserAgent.
    /*! Used with routing decisions to determine whether routes
     * are targeted to this SIP server or not.
     * \param aliases - space or comma separated of the format:
     *        "sip:host:port" or "host:port"
     */
    void setHostAliases(UtlString& aliases);

    //! Flag to recurse only one contact in a 300 response
    void setRecurseOnlyOne300Contact(UtlBoolean recurseOnlyOne);
    /***< @note this is a 300 not 3xx class response.@endnote */

    //! Flag to return Vias in too many hops response to request with max-forwards == 0
    void setReturnViasForMaxForwards(UtlBoolean returnVias);

    //! Get a copy of the original request that was sent corresponding
    //! to this incoming response
    /*! \returns NULL if not found.  Caller MUST free the copy of the
     * request when done
     */
    SipMessage* getRequest(const SipMessage& response);

    int getUdpPort() const ;
      //! Get the local UDP port number (or PORT_NONE if disabled) 

    int getTcpPort() const ;
     //! Get the local TCP port number (or PORT_NONE if disabled) 

    int getTlsPort() const ;
      //! Get the local Tls port number (or PORT_NONE if disabled) 
      
    void setUserAgentName(const UtlString& name);
      //! Sets the User Agent name sent with outgoing sip messages.

    const UtlString& getUserAgentName() const;
      //! Sets the User Agent name sent with outgoing sip messages.

    
    void setHeaderOptions(const UtlBoolean bAllowHeader,
                          const UtlBoolean bDateHeader,
                          const UtlBoolean bShortNames,
                          const UtlString& acceptLanguage);                                   
     //! Sets header options - send or not send

    UtlBoolean getEnabledShortNames()
        {return mbShortNames;}
     // Return enabled state of short names

    void setEnableLocationHeader(const bool bLocationHeader)
        {mbUseLocationHeader=bLocationHeader;}
     // Set if location header is enabled or not


    void stopTransactionTimers() { mSipTransactions.stopTransactionTimers(); }
    void startTransactionTimers() { mSipTransactions.startTransactionTimers(); }                                       

/* ============================ INQUIRY =================================== */

    virtual UtlBoolean isMessageLoggingEnabled();

    virtual UtlBoolean isReady();
    //: Return boolean if the UA is started and initialized

    virtual UtlBoolean waitUntilReady();
    //: Block and wait until the UA is started and initialized

    UtlBoolean isMethodAllowed(const char* method);

    UtlBoolean isExtensionAllowed(const char* extension) const;

    UtlBoolean isForkingEnabled();

    UtlBoolean isMyHostAlias(Url& route) const;

    UtlBoolean recurseOnlyOne300Contact();

    UtlBoolean isOk(OsSocket::IpProtocolSocketType socketType);

    //! Find out if SipUserAgent has finished shutting down.
    /*! Useful when using the non-blocking form of \ref shutdown.
     *
     * \returns TRUE if SipUserAgent has finished shutting down, FALSE otherwise.
     */
    UtlBoolean isShutdownDone();

    void setUserAgentHeader(SipMessage& message);

    void setServerHeader(SipMessage& message);

    /// Add either Server or User-Agent header, as appropriate based on isUserAgent
    void setSelfHeader(SipMessage& message);

    SipContactDb& getContactDb() { return mContactDb; }

    //! Adds a contact record to the contact db
    const bool addContactAddress(SIPX_CONTACT_ADDRESS& contactAddress);
    
    //! Gets all contact addresses for this user agent
    void getContactAddresses(SIPX_CONTACT_ADDRESS* pContacts[], int &numContacts);

    void prepareVia(SipMessage&          message,
                    UtlString&           branchId, 
                    OsSocket::IpProtocolSocketType& toProtocol,
                    const char*          szTargetAddress, 
                    const int*           piTargetPort,
                    SIPX_TRANSPORT_DATA* pTransport = NULL) ;

#ifdef SIP_TLS    
    SipTlsServer* getTlsServer() { return mSipTlsServer; }
    // ITlsSink implementation
    bool onServerCertificate(void* pCert, char* serverHostName);
    bool onTlsEvent(int cause);
#endif

    void addExternalTransport(const UtlString tranportName, const SIPX_TRANSPORT_DATA* const pTransport);
    void removeExternalTransport(const UtlString transportName, const SIPX_TRANSPORT_DATA* const pTransport);
    const SIPX_TRANSPORT_DATA* const lookupExternalTransport(const UtlString transportName, const UtlString ipAddress) const;
    
/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    void prepareContact(SipMessage& message, 
                        const char* szTargetAddress, 
                        const int*  piTargetPort) ;

    /// constuct the value to be used in either user-agent or server header.
    void selfHeaderValue(UtlString& self);

    void getAllowedMethods(UtlString* allowedMethods);

    void whichExtensionsNotAllowed(const SipMessage* message,
                                   UtlString* disallowedExtensions) const;

    UtlBoolean checkMethods(SipMessage* message);

    UtlBoolean checkExtensions(SipMessage* message);

    UtlBoolean sendStatelessResponse(SipMessage& response);

    UtlBoolean sendStatelessRequest(SipMessage& request,
                                    UtlString& address,
                                    int port,
                                    OsSocket::IpProtocolSocketType protocol,
                                    UtlString& branchId);

    UtlBoolean sendTls(SipMessage* message,
                       const char* serverAddress,
                       int port);

    UtlBoolean sendTcp(SipMessage* message,
                       const char* serverAddress,
                       int port);

    UtlBoolean sendUdp(SipMessage* message,
                       const char* serverAddress,
                       int port);

    UtlBoolean sendCustom(SIPX_TRANSPORT_DATA* pTransport, 
                          SipMessage* message, 
                          const char* sendAddress, 
                          const int sendPort);                       

    UtlBoolean sendSymmetricUdp(SipMessage& message,
                                const char* serverAddress,
                                int         port);

    //! DNS SRV lookup for to address
    void lookupSRVSipAddress(UtlString protocol,
                             UtlString& sipAddress,
                             int& port,
                             UtlString& srcIp);

    int getReliableTransportTimeout();

    int getFirstResendTimeout();

    int getLastResendTimeout();

    UtlBoolean shouldAuthenticate(SipMessage* message) const;

    UtlBoolean authorized(SipMessage* request,
                          const char* uri = NULL) const;

    void addAuthentication(SipMessage* message) const;

    UtlBoolean resendWithAuthorization(SipMessage* response,
                                       SipMessage* request,
                                       int* messageType,
                                       int authorizationEntity);
   
/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

    SipTcpServer* mSipTcpServer;
    SipUdpServer* mSipUdpServer;
#ifdef SIP_TLS
    SipTlsServer* mSipTlsServer;
#endif
    SipTransactionList mSipTransactions;
    UtlString defaultSipUser;
    UtlString defaultSipAddress;
    UtlString proxyServers;
    UtlString directoryServers;
    UtlString registryServers;
    int registryPeriod;
    int lastRegisterSeqNum;
    UtlString registerCallId;
    UtlString sipIpAddress;
    UtlString mConfigPublicAddress ;
    int mSipPort;
    UtlDList allowedSipMethods;
    UtlDList allowedSipExtensions;
    UtlString mUserAgentHeaderProperties;
    UtlHashBag mMyHostAliases;
    UtlHashBag mMessageObservers;
    UtlHashMap mExternalTransports;
    OsRWMutex mMessageLogRMutex;
    OsRWMutex mMessageLogWMutex;
    
    //times
    int mFirstResendTimeoutMs; //intialtimeout
    int mLastResendTimeoutMs; //timeout between last 2 resends
    int mReliableTransportTimeoutMs;//TCP timeout
    int mTransactionStateTimeoutMs;//transaction timeout
    int mDefaultExpiresSeconds; // Seconds
    int mDefaultSerialExpiresSeconds;
    int mMinInviteTransactionTimeout; // INVITE tx must live longer so the phone can ring
    int mMaxTcpSocketIdleTime; // time after which unused TCP sockets are removed
    int mMaxSrvRecords; // Max num of DNS SRV records to use before giving up
    int mDnsSrvTimeout; // second to give up & try the next DNS SRV record

    SipMessage* mpLastSipMessage;
    UtlString defaultUserAgentName;
    long mLastCleanUpTime;
    UtlString mAuthenticationScheme;
    UtlString mAuthenticationRealm;
    OsConfigDb* mpAuthenticationDb;
    OsConfigDb* mpAuthorizationUserIds;
    OsConfigDb* mpAuthorizationPasswords;
    SipLineMgr* mpLineMgr;
    int mMaxMessageLogSize;
    UtlString mMessageLog;
    UtlString mLocationHeader;
    UtlBoolean mIsUaTransactionByDefault;
    UtlBoolean mForkingEnabled;
    int mMaxForwards;
    UtlBoolean mRecurseOnlyOne300Contact;
    UtlBoolean mReturnViasForMaxForwards;
    UtlBoolean mbUseRport;
    UtlBoolean mbUseLocationHeader;
    UtlBoolean mbIncludePlatformInUserAgentName; // whether or not the platform name should
                                                 // be appended to the user agent name

    /** check the acceptability of method, extensions, and encoding.
     * The default is TRUE; it may be set to false in applications such as a redirect server
     * that will never actually send a 2xx response, so the checks might cause errors that
     * the application should never generate.
     */
    UtlBoolean mDoUaMessageChecks;

    void garbageCollection();

    void queueMessageToInterestedObservers(SipMessageEvent& event,
                                           const UtlString& method);
    void queueMessageToObservers(SipMessage* message,
                                 int messageType);

    //! timer that sends events to the queue periodically
    OsTimer* mpTimer;

    //! flags used during shutdown
    UtlBoolean mbShuttingDown;
    UtlBoolean mbShutdownDone;
    UtlBoolean mbBlockingShutdown;
    
    UtlBoolean mbAllowHeader;
    UtlBoolean mbDateHeader;
    UtlBoolean mbShortNames;
    UtlString mAcceptLanguage;

    int mRegisterTimeoutSeconds;    

    //! Disabled copy constructor
    SipUserAgent(const SipUserAgent& rSipUserAgent);

    //! Disabled assignment operator
    SipUserAgent& operator=(const SipUserAgent& rhs);

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipUserAgent_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipUserAgentBase_h_
#define _SipUserAgentBase_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <utl/UtlHashBag.h>

#include <os/OsServerTask.h>
#include <os/OsRWMutex.h>
#include <net/SipMessage.h>
#include <net/SipMessageEvent.h>
#include <net/SipContactDb.h>

class SIPX_TRANSPORT_DATA;




// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class OsConfigDb;

//:Base class for SipUserAgent
// Class detailed description which may extend to multiple lines
class SipUserAgentBase : public OsServerTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:


/* ============================ CREATORS ================================== */

   SipUserAgentBase(int sipTcpPort = SIP_PORT,
                    int sipUdpPort = SIP_PORT,
                    int sipTlsPort = SIP_TLS_PORT,
                    int queueSize = OsServerTask::DEF_MAX_MSGS);
     //:Default constructor


   virtual
   ~SipUserAgentBase();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

    virtual UtlBoolean handleMessage(OsMsg& eventMessage) = 0;

    virtual void addMessageConsumer(OsServerTask* messageConsumer) = 0;
    //: Add a SIP message recipient


    //: Send a SIP message over the net
    // This method sends the SIP message via
    // a SIP UDP or TCP client as dictated by policy and the address
    // specified in the message
    virtual UtlBoolean send(SipMessage& message,
        OsMsgQ* responseListener = NULL,
        void* responseListenerData = NULL,
        SIPX_TRANSPORT_DATA* pTransport = NULL) = 0;
    //! param: message - the sip message to be sent
    //! param: responseListener - the queue on which to place SipMessageEvents containing SIP responses from the same transaction as the request sent in message
    //! param: responseListenerData - data to be passed back with responses

    //: Dispatch the SIP message to the message consumer(s)
    // All incoming SIP message need to be dispatched via the user agent
    // server so that it can provide the reliablity for UDP
    // (i.e. resend requests when no response is received)
    // messageType - is as define by SipMessageEvent::MessageStatusTypes
    // APPLICATION type are normal incoming messages
    // TRANSPORT_ERROR type are notification of failures to send messages
    virtual void dispatch(SipMessage* message,
                              int messageType = SipMessageEvent::APPLICATION,
                              SIPX_TRANSPORT_DATA* pTransport = NULL) = 0;

    void addConfigChangeConsumer(OsMsgQ& messageQueue);
    //: Register to find out when UA config changes (i.e. contact address)

/* ============================ ACCESSORS ================================= */

    virtual void logMessage(const char* message, int messageLength) = 0;

    virtual void getContactUri(UtlString* contactUri) ;

/* ============================ INQUIRY =================================== */

    virtual UtlBoolean isMessageLoggingEnabled() = 0;
    //: Is message logging enabled?

    virtual UtlBoolean isReady();
    //: Return boolean if the UA is started and initialized

    virtual UtlBoolean waitUntilReady();
    //: Block and wait until the UA is started and initialized

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
    int mTcpPort;
    int mUdpPort;
    int mTlsPort;
    UtlBoolean mMessageLogEnabled;
    UtlString mContactAddress;
    OsRWMutex mObserverMutex;
    UtlHashBag mConfigChangeObservers;
    SipContactDb mContactDb;

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    SipUserAgentBase(const SipUserAgentBase& rSipUserAgent);
     //:Copy constructor

    SipUserAgentBase& operator=(const SipUserAgentBase& rhs);
     //:Assignment operator



};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipUserAgentBase_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _SipUserAgentStateless_h_
#define _SipUserAgentStateless_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include <net/SipUserAgentBase.h>
#include <net/SipMessage.h>
#include <net/SipMessageEvent.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class SipClient;

//:Base class for SipUserAgent
// Class detailed description which may extend to multiple lines
class SipUserAgentStateless : public SipUserAgentBase
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:


/* ============================ CREATORS ================================== */

   SipUserAgentStateless(int sipTcpPort = SIP_PORT, int sipUdpPort = SIP_PORT);
     //:Default constructor


   virtual
   ~SipUserAgentStateless();
     //:Destructor

/* ============================ MANIPULATORS ============================== */

    virtual UtlBoolean handleMessage(OsMsg& eventMessage);

    virtual void addMessageConsumer(OsServerTask* messageConsumer);
    //: Add a SIP message recipient


    //: Send a SIP message over the net
    // This method sends the SIP message via
    // a SIP UDP or TCP client as dictated by policy and the address
    // specified in the message
    virtual UtlBoolean send(SipMessage& message,
        OsMsgQ* responseListener = NULL,
        void* responseListenerData = NULL);
    //! param: message - the sip message to be sent
    //! param: responseListener - the queue on which to place SipMessageEvents containing SIP responses from the same transaction as the request sent in message
    //! param: responseListenerData - data to be passed back with responses

    UtlBoolean sendTo(SipMessage& message,
           const char* sendAddress,
           const char* sendProtocol,
           int sendPort);

    //: Dispatch the SIP message to the message consumer(s)
    // All incoming SIP message need to be dispatched via the user agent
    // server so that it can provide the reliablity for UDP
    // (i.e. resend requests when no response is received)
    // messageType - is as define by SipMessageEvent::MessageStatusTypes
    // APPLICATION type are normal incoming messages
    // TRANSPORT_ERROR type are notification of failures to send messages
    virtual void dispatch(SipMessage* message,
                              int messageType = SipMessageEvent::APPLICATION);

/* ============================ ACCESSORS ================================= */

    virtual void logMessage(const char* message, int messageLength);

/* ============================ INQUIRY =================================== */

    virtual UtlBoolean isMessageLoggingEnabled();

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
        OsServerTask* mpMessageObserver;
    SipClient* mpUdpServer;

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    SipUserAgentStateless(const SipUserAgentStateless& rSipUserAgent);
     //:Copy constructor

    SipUserAgentStateless& operator=(const SipUserAgentStateless& rhs);
     //:Assignment operator



};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipUserAgentStateless_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////
// Author: Dan Petrie (dpetrie AT SIPez DOT com)


#ifndef _SmimeBody_h_
#define _SmimeBody_h_

// SYSTEM INCLUDES
//#include <...>
#ifdef HAVE_NSS
#include <nspr.h>
#include <nss.h>
#include <secutil.h>
#include <secport.h>
#include <certdb.h>
#include <ssl.h>
#include <cms.h>
#include <cert.h>
#include <pk11func.h>
#include <pkcs12.h>
#include <p12plcy.h>
#include <p12.h>
#include <ciferfam.h>
#include <base64.h>
#include "net/pk12wrapper.h"
#endif

// APPLICATION INCLUDES
#include <net/HttpBody.h>
#include <tapi/sipXtapiEvents.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
// ENUMS

/**
 * Container class for security attributes.  
 */

#define SIPXTACK_MAX_SRTP_KEY_LENGTH   31
#define SIPXTACK_MAX_SMIME_KEY_LENGTH  2048
#define SIPXTACK_MAX_PKCS12_KEY_LENGTH 4096
#define SIPXTACK_MAX_CERT_LENGTH       4096
#define SIPXTACK_MAX_PASSWORD_LENGTH   32

/*
typedef enum SMIME_ERRORS
{
    SMIME_SUCCESS,
    SMIME_ENCRYPT_FAILURE_LIB_INIT,
    SMIME_ENCRYPT_FAILURE_BAD_PUBLIC_KEY, 
    SMIME_ENCRYPT_FAILURE_INVALID_PARAMETER,
    SMIME_DECRYPT_FAILURE_DB_INIT,
    SMIME_DECRYPT_FAILURE_BAD_DB_PASSWORD,
    SMIME_DECRYPT_FAILURE_INVALID_PARAMETER,
    SMIME_DECRYPT_BAD_SIGNATURE,
    SMIME_DECRYPT_MISSING_SIGNATURE,
    SMIME_UNKNOWN
} SMIME_ERRORS;
*/

enum SIPXTACK_SRTP_LEVEL
{
    SIPXTACK_SRTP_LEVEL_NONE,
    SIPXTACK_SRTP_LEVEL_ENCRYPTION,
    SIPXTACK_SRTP_LEVEL_AUTHENTICATION,
    SIPXTACK_SRTP_LEVEL_ENCRYPTION_AND_AUTHENTICATION
};

/**
 * Container class for security attributes.  
 */
class SIPXTACK_SECURITY_ATTRIBUTES
{
  public:
    friend class SipMessage;
    SIPXTACK_SECURITY_ATTRIBUTES()
    {
        nSrtpKeyLength = 0 ;
        nSmimeKeyLength = 0 ;
        nSrtpLevel = SIPXTACK_SRTP_LEVEL_NONE ;
        memset(szSrtpKey, 0, sizeof(szSrtpKey));
        memset(szSmimeKeyDer, 0, sizeof(szSmimeKeyDer));
        memset(dbLocation, 0, sizeof(dbLocation));
        memset(szMyCertNickname, 0, sizeof(szMyCertNickname));
        memset(szCertDbPassword, 0, sizeof(szCertDbPassword));
        nSmimeKeyLength = 0 ;
        nSrtpLevel = SIPXTACK_SRTP_LEVEL_NONE ;
    }    
    SIPXTACK_SECURITY_ATTRIBUTES(const SIPXTACK_SECURITY_ATTRIBUTES& ref)
    {
        copyData(ref);
    }    
    virtual ~SIPXTACK_SECURITY_ATTRIBUTES() { }    
    SIPXTACK_SECURITY_ATTRIBUTES& operator=(const SIPXTACK_SECURITY_ATTRIBUTES& ref)
    {
        if (this == &ref) return *this;
        copyData(ref);
        return *this;
    }    
    /**
     * Sets the symmetric srtp key.  If this is not supplied by the user,
     * sipXtapi will generate a random key.
     */
    void setSrtpKey(const char* szKey, const int length)
    {
        strncpy(szSrtpKey, szKey, length);
        nSrtpKeyLength = length;
    }    
    /**
     * Sets the public key of the remote party, which is used to
     * encrypt the S/MIME container for the SDP.
     */
    void setSmimeKey(const char* szKey, const int length)
    {
        memcpy((void*)szSmimeKeyDer, (void*)szKey, length);
        nSmimeKeyLength = length;
    }
    /**
     * Sets the S/MIME & SRTP security level
     */
    void setSecurityLevel(SIPXTACK_SRTP_LEVEL security) { nSrtpLevel = security; }
    /**
     * Gets the symmetric srtp key.
     */
    const char* getSrtpKey() const  { return szSrtpKey; }    
    /**
     * Gets the public key of the remote party, which is used to
     * encrypt the S/MIME container for the SDP.
     */
    const char* getSmimeKey() const { return szSmimeKeyDer; }
    /**
     * Gets the symmetric srtp key length.
     */
    const int getSrtpKeyLength() const  { return nSrtpKeyLength; }
    /**
     * Gets the public key of the remote party, which is used to
     * encrypt the S/MIME container for the SDP.
     */
    const int getSmimeKeyLength() const { return nSmimeKeyLength; }
    /**
     * Sets the S/MIME & SRTP security level
     */
    const int getSecurityLevel() const {return nSrtpLevel;}
    /**
     * Gets the Certificate Database location (set internally to
     * the location specified in the call to 
     * sipxConfigSetSecurityParameters() )
     */
    const char* getCertDbLocation() const { return dbLocation; }

  private:
    SIPXTACK_SRTP_LEVEL nSrtpLevel;
    char szSrtpKey[SIPXTACK_MAX_SRTP_KEY_LENGTH];
    int  nSrtpKeyLength;    
    char szSmimeKeyDer[SIPXTACK_MAX_SMIME_KEY_LENGTH];
    int  nSmimeKeyLength; 
    // internally set private member, use sipxConfigSetSecurityParameters
    char dbLocation[256];         
    // internally set private member, use sipxConfigSetSecurityParameters
    char szMyCertNickname[32];                
    // internally set private member, use sipxConfigSetSecurityParameters
    char szCertDbPassword[SIPXTACK_MAX_PASSWORD_LENGTH];   
    void copyData(const SIPXTACK_SECURITY_ATTRIBUTES& ref)
    {
        nSrtpLevel = ref.nSrtpLevel;
        nSrtpKeyLength = ref.nSrtpKeyLength;
        nSmimeKeyLength = ref.nSmimeKeyLength;
        strcpy(szSrtpKey, ref.szSrtpKey);
        memcpy((void*)szSmimeKeyDer, (void*)ref.szSmimeKeyDer, ref.nSmimeKeyLength);
        strncpy(dbLocation, ref.dbLocation, sizeof(dbLocation) - 1);
        strncpy(szMyCertNickname, ref.szMyCertNickname, sizeof(szMyCertNickname) - 1);
        strncpy(szCertDbPassword, ref.szCertDbPassword, sizeof(szCertDbPassword) - 1);
        return;
    }
};


//: Interface defintion for receiving events: SMIME errors or SMIME signature notifications.
class ISmimeNotifySink
{
public:
        virtual void OnError(SIPX_SECURITY_EVENT event, SIPX_SECURITY_CAUSE cause) = 0;
        virtual bool OnSignature(void* pCert, char* szSubjAltName) = 0 ;

        virtual ~ISmimeNotifySink() { } ;
};
//! class to contain an PKCS7 (S/MIME) body
/*! This class can be used to create an encrypted S/MIME
    body as well as to decrypt an encrypted body.
 */
class SmimeBody : public HttpBody
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    enum ContentEncoding
    {
        SMIME_ENODING_UNKNOWN = 0,
        SMIME_ENODING_BINARY,
        SMIME_ENODING_BASE64
    };

/* ============================ CREATORS ================================== */

    //! default constructor
    SmimeBody();

    //! Construct an SmimeBody from a bunch of bytes
    SmimeBody(const char* bytes, 
              int length,
              const char* contentEncodingValueString);

    //! Copy constructor
    SmimeBody(const SmimeBody& rSmimeBody);

    //! Destructor
    virtual
    ~SmimeBody();

/* ============================ MANIPULATORS ============================== */

    //! Assignment operator
    SmimeBody& operator=(const SmimeBody& rhs);

    //! Decrypt this body using the given private key and cert. contained in the pkcs12 package
    /*! Decrypts this body using the derPkcs12PrivateKey.
     *  \param derPkcs12 - DER format pkcs12 container for the 
     *         private key and public key/Certificate for a recipent who is 
     *         allowed to decrypt this pkcs7 (S/MIME) encapsulated body.
     *  \param derPkcs12Length - length in bytes of derPkcs12PrivateKey
     *  \param pkcs12Password - symetric key (password) used to protect 
     *         (encrypt) the derPkcs12PrivateKey (the private key is 
     *         contained in a pkcs12 in an encrypted format to protect 
     *         it from theft).  Must be NULL terminated string.
     */
    UtlBoolean decrypt(const char* derPkcs12,
                      int derPkcs12Length,
                      const char* pkcs12password,
                      const char* certDbPassword,
                      const char* signerCertDER,
                      int signerCertDERLength,                      
                      ISmimeNotifySink* pSink = NULL);

    //! Encrypt the given body for the given list of recipients
    /*! \param bodyToEncrypt - Body to encrypt, note bodyToEncrypt
    *         will be attached to and deleted with this SmimeBody.
    *         bodyToEncrypt can be retrieved after invoking decrypt
    *         using the getDecyptedBody method.
    *  \param numRecipients - number of recipients for which 
    *         bodyToEncrypt will be encrypted.  For each recipient
    *         an element in derPublicKeyCerts and derPubliceKeyCertLengths 
    *         must be given.
    *  \param derPublicKeyCerts - array containing a DER format
    *         certificate (containing the public key) for each recipient.
    *  \param derPubliceKeyCertLengths - length in bytes of the 
    *         corresponding element in derPublicKeyCerts.
    */
    UtlBoolean encrypt(HttpBody* bodyToEncrypt,
                      int numRecipients,
                      const char* derPublicKeyCerts[],
                      int derPubliceKeyCertLengths[],
                      const char* szMyCertNickname,
                      const char* szCertDbPassword,
                      ISmimeNotifySink* pSink = NULL);


#ifdef HAVE_NSS
    static void getSubjAltName(char* szSubjAltName,
                        const CERTCertificate* pCert,
                        const size_t length);
#endif
    // Lower level utility to do S/MIME encryption using the NSS library.
    /*! Encrypts the given data for the recipients represented by the
     *  array of certificates containing the public keys.
     *  \param numRecipientCerts the number of recipient certificates in
     *         the derPublicKeyCerts array.
     *  \param derPublicKeyCerts - array containing DER format certificates.
     *  \param derPublicKeyCertLengths - array containing the length of the
     *         corresponding certificate DER data.
     *  \param dataToEncrypt - raw data to encrypt using PKCS7 S/MIME format
     *  \param dataToEncryptLength length in bytes of dataToEncrypt
     *  \param encryptedDataInBase64Format - TRUE: output encrypted data in
     *         base64 format, FALSE: output data in raw binary format.  Typically
     *         for SIP one should send in binary format.
     *  \param encryptedData - string containing the encrypted result.
     */
    static UtlBoolean nssSmimeEncrypt(int numRecipientCerts,
                                       const char* derPublicKeyCerts[], 
                                       int derPublicKeyCertLengths[],
                                       const char* szMyCertNickname,
                                       const char* szCertDbPassword,
                                       const char* dataToEncrypt,
                                       int dataToEncryptLength,
                                       UtlBoolean encryptedDataInBase64Format,
                                       UtlString& encryptedData,
                                       ISmimeNotifySink* pSmimeSink);

    // Lower level utility to do S/MIME decryption using the NSS library
    /*! Decrypts this body using the derPkcs12PrivateKey.
     *  \param derPkcs12 - DER format pkcs12 container for the 
     *         private key and public key/Certificate for a recipent who is 
     *         allowed to decrypt this pkcs7 (S/MIME) encapsulated body.
     *  \param derPkcs12Length - length in bytes of derPkcs12PrivateKey
     *  \param pkcs12Password - symetric key (password) used to protect 
     *         (encrypt) the derPkcs12PrivateKey (the private key is 
     *         contained in a pkcs12 in an encrypted format to protect 
     *         it from theft).  Must be NULL terminated string.
     *  \param dataIsInBase64Format - TRUE: encrypted data is in base64
     *         format, FALSE: encrypted data is in binary format.
     *  \param dataToDecrypt - raw data to be decrypted. Must be in binary
     *         or base64 format.  Does NOT need to be NULL terminated.
     *  \param dataToDecryptLength - length of the data in dataToDecrypt
     *         to be decrypted.
     *  \param decryptedData - string to contain the resulting decrypted
     *         data.
     */
    static UtlBoolean nssSmimeDecrypt(const char* derPkcs12,
                                      int derPkcs12Length,
                                      const char* pkcs12Password,
                                      const char* certDbPassword,
                                      const char* signerCertDER,
                                      int signerCertDERLength,                      
                                      UtlBoolean dataIsInBase64Format,
                                      const char* dataToDecrypt,
                                      int dataToDecryptLength,
                                      UtlString& decryptedData,
                                      ISmimeNotifySink* pSmimeSink);

    // Lower level utility to do S/MIME encryption using the NSS library.
    /*! Encrypts the given data for the recipients represented by the
     *  array of certificates containing the public keys.
     *  \param numRecipientCerts the number of recipient certificates in
     *         the derPublicKeyCerts array.
     *  \param derPublicKeyCerts - array containing DER format certificates.
     *  \param derPublicKeyCertLengths - array containing the length of the
     *         corresponding certificate DER data.
     *  \param dataToEncrypt - raw data to encrypt using PKCS7 S/MIME format
     *  \param dataToEncryptLength length in bytes of dataToEncrypt
     *  \param encryptedDataInBase64Format - TRUE: output encrypted data in
     *         base64 format, FALSE: output data in raw binary format.  Typically
     *         for SIP one should send in binary format.
     *  \param encryptedData - string containing the encrypted result.
     */
    static UtlBoolean opensslSmimeEncrypt(int numRecipientCerts,
                                          const char* derPublicKeyCerts[], 
                                          int derPublicKeyCertLengths[],
                                          const char* dataToEncrypt,
                                          int dataToEncryptLength,
                                          UtlBoolean encryptedDataInBase64Format,
                                          UtlString& encryptedData);

    // Lower level utility to do S/MIME decryption using the OpenSSL library
    /*! Decrypts this body using the derPkcs12PrivateKey.
     *  \param derPkcs12 - DER format pkcs12 container for the 
     *         private key and public key/Certificate for a recipent who is 
     *         allowed to decrypt this pkcs7 (S/MIME) encapsulated body.
     *  \param derPkcs12Length - length in bytes of derPkcs12PrivateKey
     *  \param pkcs12Password - symetric key (password) used to protect 
     *         (encrypt) the derPkcs12PrivateKey (the private key is 
     *         contained in a pkcs12 in an encrypted format to protect 
     *         it from theft).  Must be NULL terminated string.
     *  \param dataIsInBase64Format - TRUE: encrypted data is in base64
     *         format, FALSE: encrypted data is in binary format.
     *  \param dataToDecrypt - raw data to be decrypted. Must be in binary
     *         or base64 format.  Does NOT need to be NULL terminated.
     *  \param dataToDecryptLength - length of the data in dataToDecrypt
     *         to be decrypted.
     *  \param decryptedData - string to contain the resulting decrypted
     *         data.
     */
    static UtlBoolean opensslSmimeDecrypt(const char* derPkcs12,
                                   int derPkcs12Length,
                                   const char* pkcs12Password,
                                   UtlBoolean dataIsInBase64Format,
                                   const char* dataToDecrypt,
                                   int dataToDecryptLength,
                                   UtlString& decryptedData);

    //! Utility to convert PEM format data to DER format
    static UtlBoolean convertPemToDer(UtlString& pemData,
                                      UtlString& derData);
                                      
    static bool importPKCS12Object(const char* derPkcs12,
                                       int derPkcs12Length,
                                       const char* pkcs12Password,
                                       const char* certDbLocation,
                                       const char* certDbPassword);


/* ============================ ACCESSORS ================================= */

    //! Gets the decrypted form of this body if available
    const HttpBody* getDecryptedBody() const;

/* ============================ INQUIRY =================================== */

   //! Query if this body has been decrypted
   UtlBoolean isDecrypted() const;

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

   HttpBody* mpDecryptedBody;
   enum ContentEncoding mContentEncoding;

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
#ifdef HAVE_NSS
    static UtlString createSignedData(CERTCertificate *cert,
                          const char* dataToSign,
                          const int dataToSignLength,
                          NSSCMSSignedData*& sigd, 
                          char* szCertDbPassword);


#endif
    ISmimeNotifySink* mpSmimeSink;

};

/* ============================ INLINE METHODS ============================ */

#endif  // _SmimeBody_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _STATECHANGENOTIFIER_H_
#define _STATECHANGENOTIFIER_H_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include <net/Url.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS


/**
 * A StateChangeNotifier is used in the dialog monitor when the dialog state is
 * changed from one state to another.
 * 
 * This class is the abstract base from which all state change notifiers must inherit.
 * One method must be implemented by the subclasses:
 * - setState() is for SipDialogMonitor to set the state value based on its
 * notification.
 *
 */

class StateChangeNotifier
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

   enum Status
   {
      PRESENT,
      AWAY,
      OFF_HOOK,
      RINGING,
      ON_HOOK,
      SIGN_IN,
      SIGN_OUT
   };

/* ============================ CREATORS ================================== */

   /// Constructor
   StateChangeNotifier();
  
   /// Destructor
   virtual ~StateChangeNotifier();

   /// Set the status value. Subclasses must provide a definition for this method.
   virtual bool setStatus(const Url& aor, const Status value) = 0;

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */


/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

   /// Disabled copy constructor
   StateChangeNotifier(const StateChangeNotifier& rStateChangeNotifier);

   /// Disabled assignment operator
   StateChangeNotifier& operator=(const StateChangeNotifier& rhs);
   
};

/* ============================ INLINE METHODS ============================ */

#endif  // _STATECHANGENOTIFIER_H_


//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////


#ifndef _Url_h_
#define _Url_h_

// SYSTEM INCLUDES
//#include <...>

// APPLICATION INCLUDES
#include "utl/UtlDefs.h"
#include "utl/UtlString.h"
#include "utl/UtlRegex.h"
class UtlDList;

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS
class NameValuePair ;

/// URL parser and constructor
/**
 * This object is used to parse and construct URL strings.  This object
 * contains all of the parsed components of a URL.  It has the ability
 * to construct a serialized string of the object using the toString()
 * method.  It can also be used as a parser using the constructor 
 * which accepts a string as input.  This is intended to be a
 * generic URL parser for all schema/protocol types.  It is currently
 * tested and known to work for sip, sips, http, https, ftp, and file type
 * URLs. There are accessors for the various parts of the URL
 * These parts appear in URLs such as the following:
 * @code
 * "display name"<protocol:[//]user:password@host:port;urlparm=value?headerParam=value>;fieldParam=value
 * @endcode
 * The routines for the various parts are:
 * - display name
 *   - getDisplayName()
 *   - setDisplayName()
 * - protocol
 *   - getUrlType()
 *   - setUrlType()
 * - user
 *   - getUserId()
 *   - setUserId()
 * - password
 *   - getPassword()
 *   - setPassword()
 * - host
 *   - getHostAddress()
 *   - setHostAddress()
 * - port
 *   - getHostPort()
 *   - setHostPort()
 * - URL parameter names and values
 *   - getUrlParameter()
 *   - getUrlParameters()
 *   - setUrlParameter()
 *   - removeUrlParameter()
 *   - removeUrlParameters()
 * - header (or CGI) parameter names and values
 *   - getHeaderParameter()
 *   - getHeaderParameters()
 *   - setHeaderParameter()
 *   - removeHeaderParameter()
 *   - removeHeaderParameters()
 * - field parameter names and values
 *   - getFieldParameter()
 *   - getFieldParameters()
 *   - setFieldParameter()
 *   - removeFieldParameter()
 *   - removeFieldParameters()
 * 
 */

class Url
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
   
   /// Identifiers for all supported URI schemes
   typedef enum
      {
         UnknownUrlScheme,  ///< invalid or unset scheme
         SipUrlScheme,      ///< sip:    (RFC 3261)
         SipsUrlScheme,     ///< sips:   (RFC 3261)
         HttpUrlScheme,     ///< http:   (RFC 2616)
         HttpsUrlScheme,    ///< https:  (RFC 2818)
         FtpUrlScheme,      ///< ftp:    (RFC 1738)
         FileUrlScheme,     ///< file:   (RFC 1738)
         MailtoUrlScheme,   ///< mailto: (RFC 2368)
         NUM_SUPPORTED_URL_SCHEMES
      }  Scheme;
   /**<
    * URI types are distinguished by the scheme names.
    * The scheme method translates names into these enumerations;
    * the schemeName method translates these into the canonical string for a URI.
    * The authoritative record of what schemes are defined is at:
    *   http://www.iana.org/assignments/uri-schemes
    * The general rules for URIs are in RFC 3986
    */

/* ============================ CREATORS ================================== */

   /// Default constructor from string
   Url(const char* urlString = NULL, ///< string to parse URL from
       UtlBoolean isAddrSpec = FALSE /**< - TRUE if this is an addrspec (a Request URI)
                                      *   - FALSE if this is a URL from a header field */
       );

    //! Copy constructor
    Url(const Url& rUrl);

    //! Destructor
    virtual
    ~Url();

/* ============================ MANIPULATORS ============================== */

     //! Assignment operator
    Url& operator=(const Url& rhs);

    //! Assignment from string
    /*! Parse the given null terminated string and set the
     * URL parts as found in the string.
     */
    Url& operator=(const char* urlString);

    /// set the value of this url by parsing the given string.
    void fromString(const UtlString& urlString,
                    UtlBoolean isAddrSpec = FALSE
                    );
    ///< all arguments are the same as for the constructor.

    //! Serialize this URL to a string in name-addr format, suitable for use
    //  as a field in a header.
    void toString(UtlString& urlString) const;

    //! Serialize this URL to a string in name-addr format, suitable for use
    //  as a field in a header.
    UtlString toString() const;

    //! Debug dump to STDOUT
    void dump();

    //! Clear the contents of this URL
    void reset();

    //! Remove all of the URL, header and field parameters and values
    void removeParameters();

/* ============================ ACCESSORS ================================= */

    /// Construct the cannonical identity.
    void getIdentity(UtlString& identity) const;
    /**<
     * In some applications this is used to compare if this
     * URL refers to the same destination.  The identity is:
     * @code
     * "user@host:port"
     * @endcode
     */

    /// Get the URL application layer protocol scheme string.
    void getUrlType(UtlString& urlProtocol) const;
    /**<
     * If you are going to make decisions based on the type,
     * it is more efficient to use getScheme to get the Scheme enumerated form
     * rather than comparing strings.
     */

    /// Set the URL application layer protocol using the scheme name string
    void setUrlType(const char* urlProtocol);
    ///< also see setScheme.

    /// Get the URL display name if present
    void getDisplayName(UtlString& displayName) const;

    /// Set the URL display name
    void setDisplayName(const char* displayName);

    /// Get the URL user identity if present
    void getUserId(UtlString& userId) const;

    /// Set the URL user identity
    void setUserId(const char* userId);

    /// Get the users password if present in the URL
    UtlBoolean getPassword(UtlString& userId) const;

    /// Set the users password in the URL
    void setPassword(const char* userId);
    /**<
     * Putting a password in a URL is a
     * <strong>really really bad idea</strong>.
     * RFC 3261 says:
     *
     * While the SIP and SIPS URI syntax allows this field to be
     * present, its use is NOT RECOMMENDED, because the passing
     * of authentication information in clear text (such as URIs)
     * has proven to be a security risk in almost every case where
     * it has been used.
     */

    /// Get the URL host name or IP address
    void getHostAddress(UtlString& address) const;

    /// Get the host and port together as a string "host:port"
    void getHostWithPort(UtlString& domain) const;
    
    /// Set the URL host name or IP address
    void setHostAddress(const char* address);

    /// Get the URL host port
    int getHostPort() const;

    /// Set the URL host port
    void setHostPort(int port);

    /// Get the file path from the URL
    UtlBoolean getPath(UtlString& path,
                       UtlBoolean getStyle = FALSE /**< TRUE will put header (or CGI) parameters
                                                    *   in path in the format needed for an HTTP
                                                    *   GET.  FALSE will form the path without
                                                    *   the header parameters as formated for a
                                                    *   HTTP POST. */

                       );


    /// Set the file path
    void setPath(const char* path);
    /**< @note the path should \a not contain header (or CGI) parameters @endnote */

    /// Get the named URL parameter value
    UtlBoolean getUrlParameter(const char* name,  ///< the parameter name to get
                               UtlString& value,  ///< the value of the named parameter
                               int index = 0 
                               );
    /**<
     * Gets the index occurrence of the named parameter (the same parameter name may
     * occur multiple times in a URL).
     * @return TRUE if the indicated parameter exists
     */

    /// Get the name and value of the URL parameter at the indicated index.
    UtlBoolean getUrlParameter(int urlIndex,    /**< the index indicting which URL parameter to 
                                                 *   get (starting at 0 for the first one). */
                               UtlString& name,  ///< the parameter name at urlIndex
                               UtlString& value  ///< the value of the parameter at urlIndex
                               );
    /**< @return TRUE if the indicated parameter exists. */

    /// Set the named URL parameter to the given value
    /*! Adds the parameter if it does not exist, sets the value if
     * it does exist.
     * \param name - the parameter name
     * \param value - the value of the parameter
     */
    void setUrlParameter(const char* name, const char* value);

    /// Removes all of the URL parameters
    void removeUrlParameters();

    /// Removes all of the URL parameters with the given name
    void removeUrlParameter(const char* name);

    /// Gets all of the URL parameters and values
    /*! \param iMaxReturn (in) - the maximum number of items to return
     * \param pNames (out) - Pointer to a preallocated array of 
     *        UtlStrings.  If a null is specified, the function will
     *        return false and the iActualReturn will contain the actual
     *        number of parameters.
     * \param pValues (out) - Pointer to a preallocated array of 
     *        UtlStrings.  If a null is specified, the function will
     *        return false and the \a iActualReturn will contain the actual
     *        number of parameters.
     * \param iActualReturn (out) - The actual number of items returned
     * \returns TRUE if values are returned otherwise FALSE   
     */
    UtlBoolean getUrlParameters(int iMaxReturn, 
                               UtlString *pNames, 
                               UtlString *pValues, 
                               int& iActualReturn);

    /// Get the named header parameter value
    /*! \param name - the parameter name to get
     * \param value - the value of the named parameter
     * \param index - gets the \a index occurance of the named parameter 
     *        (the same parameter name may occur multiple times in the URL).
     * \return TRUE if the indicated parameter exists
     */
    UtlBoolean getHeaderParameter(const char* name, 
                                 UtlString& value, 
                                 int index = 0);

    /// Get the name and value of the header parameter at the indicated index
    /*! \param headerIndex - the index indicting which header parameter to 
     *          get (starting at 0 for the first one).
     * \param name - the parameter name at headerIndex
     * \param value - the value of the parameter at headerIndex
     * \return TRUE if the indicated parameter exists
     */
    UtlBoolean getHeaderParameter(int headerIndex, 
                                 UtlString& headerName, 
                                 UtlString& headerValue);

    /// Set the named header parameter to the given value
    void setHeaderParameter(const char* name,  ///< the parameter name
                            const char* value  ///< the value of the parameter
                            );
    /**<
     * For sip and sips URLs, this sets the header parameter to the value if the header name
     * is unique according to SipMessage::isUrlHeaderUnique, overwriting any previous value.
     * If the header is not unique, then this appends the header parameter.
     *
     * For all other URL schemes, the parameter is always appended.
     *
     * To ensure that any previous value is replaced, call removeHeaderParameter(name) first.
     */

    /// Removes all of the header parameters
    void removeHeaderParameters();

    /// Removes all of the header parameters with the given name
    void removeHeaderParameter(const char* name);

    ///Gets all of the Header parameters
    /*! \param iMaxReturn (in) - the maximum number of items to return
     * \param pNames (out) - Pointer to a preallocated collection of 
     *        UtlStrings.  If a null is specified, the function will
     *        return false and the iActualReturn will contain the actual
     *        number of parameters.
     * \param pValues (out) - Pointer to a preallocated collection of 
     *        UtlStrings.  If a null is specified, the function will
     *        return false and the iActualReturn will contain the actual
     *        number of parameters.
     * \param iActualReturn (out) - The actual number of items returned
     * \return TRUE if values are returned otherwise FALSE
     */
    UtlBoolean getHeaderParameters(int iMaxReturn, UtlString *pNames, UtlString *pValues, int& iActualReturn);


    /// Get the named field parameter value
    /*! \param name - the parameter name to get
     * \param value - the value of the named parameter
     * \param index - gets the \a index occurance of the named parameter 
     *        (the same parameter name may occur multiple times in the URL).
     * \return TRUE if the indicated parameter exists
     */
    UtlBoolean getFieldParameter(const char* name, 
                                UtlString& value, 
                                int index = 0) const;

    /// Get the name and value of the field parameter at the indicated
    //! index
    /*! \param fieldIndex - the index indicting which field parameter to 
     *          get (starting at 0 for the first one).
     * \param name - the parameter name at fieldIndex
     * \param value - the value of the parameter at fieldIndex
     * \return TRUE if the indicated parameter exists
     */
    UtlBoolean getFieldParameter(int fieldIndex, 
                                UtlString& name, 
                                UtlString& value);

    /// Set the named field parameter to the given value
    /*! Adds the parameter if it does not exist, sets the value if
     * it does exist.
     * \param name - the parameter name
     * \param value - the value of the parameter
     */
    void setFieldParameter(const char* name, 
                           const char* value);

    /// Removes all of the field parameters
    void removeFieldParameters();

    /// Removes all of the field parameters with the given name
    void removeFieldParameter(const char* name);

    /// Gets all of the Header parameters
    /*! \param iMaxReturn (in) - the maximum number of items to return
     *        UtlStrings.  If a null is specified, the function will
     *        return false and the iActualReturn will contain the actual
     *        number of parameters.
     * \param pValues (out) - Pointer to a preallocated collection of 
     *        UtlStrings.  If a null is specified, the function will
     *        return false and the iActualReturn will contain the actual
     *        number of parameters.
     * \param iActualReturn (out) - The actual number of items returned
     * \return TRUE if values are returned otherwise FALSE
     */
    UtlBoolean getFieldParameters(int iMaxReturn, 
                                 UtlString *pNames, 
                                 UtlString *pValues, 
                                 int& iActualReturn);

    /// Forces the presence of angle brackets (i.e. <>) in the URL 
    //! when serialized
    void includeAngleBrackets();

    /// Remove the angle brackets (i.e. <>) from the URL
    void removeAngleBrackets();
    /**<
     * This does not really do anything - the toString function always puts
     * out a canonical form that does not include angle brackets if it is
     * possible to omit them.
     */

    /// Escape a string as a gen_value, which is what field-parameters use for values.
    static void gen_value_escape(UtlString& escapedText);

    /// Un-escape a string as a gen_value, which is what field-parameters use for values.
    static void gen_value_unescape(UtlString& escapedText);

    /// Gets the serialized URL as a string (with no display name or field parameters)
    void getUri(UtlString& Uri);

/* ============================ INQUIRY =================================== */

    /// Is string all digits
    /*! \param dialedCharacters - null terminated string containing 
     *       ascii test
     * \ return TRUE if the dialedCharacters are all digits
     */
   static UtlBoolean isDigitString(const char* dialedCharacters);

   /// Compare two URLs to see if the have the same user, host and port
   UtlBoolean isUserHostPortEqual(const Url& uri,
                                  int impliedPort = PORT_NONE 
                                  ) const ;
   /**<
    * Follows the rules of RFC 3261 section 19.1.4, especially that
    * that no port specifies is NOT the same as the default port for
    * the URL type/protocol (but see the description of impliedPort).
    *
    * Assumes that host is not case sensitive (because DNS names are not by definition),
    * but that user id is case sensitive.
    *
    * If the impliedPort is some value other than PORT_NONE, then that port number
    * is considered to be equal to an unspecified port number.  For example:
    * @code
    *   Url implicitPortUrl("sip:user@example.com");
    *   UtlBoolean result;
    *   
    *   Url explicitPortUrl("<sip:user@Example.COM:5060>;param=x");
    *   result = implicitPortUrl.isUserHostPortEqual(explicitPortUrl);
    *   // result is FALSE because an implicit port != 5060
    *
    *   Url unspecifiedPortUrl("<sip:user@Example.COM>;param=x");
    *   result = implicitPortUrl.isUserHostPortEqual(unspecifiedPortUrl);
    *   // result is TRUE, despite case difference in domain name
    *
    *   Url otherPortUrl("<sip:user@Example.COM:5999>;param=x");
    *   result = implicitPortUrl.isUserHostPortEqual(otherPortUrl, 5999);
    *   // result is TRUE because the specified implicit port is
    *   // considered to be that implied by the unspecified port in implicitPortUrl
    *
    *   result = implicitPortUrl.isUserHostPortEqual(otherPortUrl, 5060);
    *   // result is FALSE because the specified implicit port does not match
    * @endcode
    *
    * @return TRUE if the user Id, host and port are the same
    */

   /// Compare two URLs to see if the have the same user and host
   UtlBoolean isUserHostEqual(const Url& uri) const ;
   /**<
    * Assumes that host is not case sensitive, but that user id is case sensitive.
    * @return TRUE if the user Id and host are the same
    */   

   /// Are angle brackets explicitly included
   UtlBoolean isIncludeAngleBracketsSet() const ;
   /**<
    * @note does not test if angle brackets are required or will be added
    * implicitly.
    * @returns TRUE if angle brackets were found when parsing or if they are
    *          explicitly set to be inserted during serialization.
    */

   /// Translate a scheme string (not including the terminating colon) to a Scheme enum.
   Scheme scheme( const UtlString& schemeName );

   /// Get the canonical (lowercase) name constant for a supported Scheme.
   const char* schemeName( Scheme scheme );

   /// Get the enumerator for the URL scheme type (more convenient than getUrlType).
   Scheme getScheme() const;

   /// Set the scheme to be used (also see setUrlType).
   void setScheme(Scheme scheme);
   

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
   /// parse a URL in string form into its component parts
   void parseString(const char* urlString, ///< the raw URL string
                    UtlBoolean isAddrSpec = FALSE  /**< TRUE if this came from a Request URI or
                                                    *   other place where only the addr-spec production
                                                    *   is valid. */
                    );

   Scheme    mScheme;

   UtlString mDisplayName;
   UtlString mUserId;
   UtlString mPassword;
   UtlBoolean mPasswordSet;
   UtlString mHostAddress;
   int mHostPort;
   UtlString mPath;

   UtlString mRawUrlParameters;
   bool      parseUrlParameters();//< lazy parser for url parameters
   UtlDList* mpUrlParameters;

   UtlString mRawHeaderOrQueryParameters;
   bool      parseHeaderOrQueryParameters();//< lazy parser for header or query parameters
   UtlDList* mpHeaderOrQueryParameters;

   UtlString mRawFieldParameters;
   bool      parseFieldParameters(); //< lazy parser for field parameters
   UtlDList* mpFieldParameters;

   UtlBoolean mAngleBracketsIncluded;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _Url_h_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _XMLRPCBODY_H_
#define _XMLRPCBODY_H_

// SYSTEM INCLUDES
// APPLICATION INCLUDES
#include <net/HttpBody.h>

// DEFINES
#define CONTENT_TYPE_TEXT_XML "text/xml"

#define BEGIN_METHOD_CALL "<methodCall>\n"
#define END_METHOD_CALL "</methodCall>\n"

#define BEGIN_METHOD_NAME "<methodName>"
#define END_METHOD_NAME "</methodName>\n"

#define BEGIN_PARAMS "<params>\n"
#define END_PARAMS "</params>\n"

#define BEGIN_PARAM "<param>\n"
#define END_PARAM "</param>\n"

#define BEGIN_I4 "<value><i4>"
#define END_I4 "</i4></value>\n"

#define BEGIN_INT "<value><int>"
#define END_INT "</int></value>\n"

#define BEGIN_I8 "<value><i8>"
#define END_I8 "</i8></value>\n"

#define BEGIN_BOOLEAN "<value><boolean>"
#define END_BOOLEAN "</boolean></value>\n"

#define BEGIN_STRING "<value><string>"
#define END_STRING "</string></value>\n"

#define BEGIN_TIME "<value><dateTime.iso8601>"
#define END_TIME "</dataTime.iso8601></value>\n"

#define BEGIN_ARRAY "<value><array><data>\n"
#define END_ARRAY "</data></array></value>\n"

#define BEGIN_STRUCT "<value><struct>\n"
#define END_STRUCT "</struct></value>\n"

#define BEGIN_MEMBER "<member>\n"
#define END_MEMBER "</member>\n"

#define BEGIN_NAME "<name>"
#define END_NAME "</name>"

#define BEGIN_RESPONSE "<methodResponse>\n"
#define END_RESPONSE "</methodResponse>\n"

#define BEGIN_FAULT "<fault>\n"
#define END_FAULT "</fault>\n"

#define FAULT_CODE "<name>faultCode</name>"
#define FAULT_STRING "<name>faultString</name>"

// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS

// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

/**
 * This class contains all the contents presented in a XML-RPC body. This class
 * has the methods to construct a XML-RPC body. It is only used by XmlRpcRequest
 * and XmlRpcResponse classes.
 * 
 */
class XmlRpcBody : public HttpBody
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
  public:

   /// Construct an empty body of a XML-RPC
   XmlRpcBody();

   /// Destructor
   virtual ~XmlRpcBody();

   /// Append the string to the body
   void append(const char* string);

   /// Get the string length of this object
   virtual int getLength() const;

   /// Get the serialized char representation of this body.
   virtual void getBytes(const char** bytes, ///< buffer space where the body content is written, null terminated
                         int* length ///< the number of bytes written (not including the null terminator
                         ) const;

   /// Get the serialized string representation of this body.
   virtual void getBytes(UtlString* bytes, ///< buffer space where the body content is written, null terminated
                         int* length ///< the number of bytes written (not including the null terminator
                         ) const;

   /// Add a value to the XML-RPC content
   bool addValue(UtlContainable* value);

   /// Add an array to the XML-RPC content
   bool addArray(UtlSList* array); ///< array of elements

   /// Add a struct to the XML-RPC content
   bool addStruct(UtlHashMap* members); ///< struct of members
   
/* //////////////////////////// PROTECTED ///////////////////////////////// */
  protected:
   

/* //////////////////////////// PRIVATE /////////////////////////////////// */
  private:

   /// Disabled copy constructor
   XmlRpcBody(const XmlRpcBody& rXmlRpcBody);

   /// Disabled assignment operator
   XmlRpcBody& operator=(const XmlRpcBody& rhs);

};

/* ============================ INLINE METHODS ============================ */

#endif  // _XMLRPCBODY_H_
//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _XMLRPCDISPATCH_H_
#define _XMLRPCDISPATCH_H_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include <os/OsBSem.h>
#include <xmlparser/tinyxml.h>
#include "net/HttpService.h"
#include "net/HttpServer.h"
#include "net/XmlRpcMethod.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS

// FORWARD DECLARATIONS

// Private class to contain XmlRpcMethod and user data for each methodName
class XmlRpcMethodContainer : public UtlContainable
{
public:
   static const UtlContainableType TYPE ;    /** < Class type used for runtime checking */ 

   XmlRpcMethodContainer();

   virtual ~XmlRpcMethodContainer();

   virtual UtlContainableType getContainableType() const;

   virtual unsigned int hash() const;

   int compareTo(const UtlContainable *b) const;
   
   void setData(XmlRpcMethod::Get* method, void* userData);
   
   void getData(XmlRpcMethod::Get*& method, void*& userData);

private:

   void* mpUserData;
   XmlRpcMethod::Get* mpMethod;
    
   //! DISALLOWED accidental copying
   XmlRpcMethodContainer(const XmlRpcMethodContainer& rXmlRpcMethodContainer);
   XmlRpcMethodContainer& operator=(const XmlRpcMethodContainer& rhs);
};

/**
 * A XmlRpcDispatch is a object that monitors the incoming
 * XML-RPC requests, parses XmlRpcRequest messages, invokes the correct
 * XmlRpcMethod calls, and sends back the corresponding XmlRpcResponse responses.
 * If the correspnding method does not exit, it will send back a 404 response.
 * Otherwise, it will always send back a 200 OK response with XmlRpcResponse
 * content.
 * 
 * For each XML-RPC server, it needs to instantiate a XmlRpcDispatch object first,
 * and then register each service method using addMethod() or remove the method
 * using removeMethod().
 */

class XmlRpcDispatch : public HttpService
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:
   static const char* DEFAULT_URL_PATH;

/* ============================ CREATORS ================================== */

   /// Create a dispatch object.
   XmlRpcDispatch(int httpServerPort,           ///< port number for HttpServer
                  bool isSecureServer,          ///< option for HTTP or HTTPS
                  const char* uriPath = DEFAULT_URL_PATH          ///< uri path
                  ); 

   /// Destructor.
   virtual ~XmlRpcDispatch();

/* ============================ MANIPULATORS ============================== */

   /// Handler for XML-RPC requests
   void processRequest(const HttpRequestContext& requestContext,
                       const HttpMessage& request,
                       HttpMessage*& response );

/* ============================ ACCESSORS ================================= */

   /// Add a method to the RPC dispatch
   void addMethod(const char* methodName, XmlRpcMethod::Get* method, void* userData = NULL);

   /// Remove a method from the RPC dispatch by name
   void removeMethod(const char* methodName);
   
   /// Return the HTTP server that services RPC requests
   HttpServer* getHttpServer();
   
/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

   friend class XmlRpcTest;
   
   /// Parse the XML-RPC request
   bool parseXmlRpcRequest(UtlString& requestContent,
                           XmlRpcMethodContainer*& method,
                           UtlSList& params,
                           XmlRpcResponse& response);

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

   /// Parse a value in the XML-RPC request
   bool parseValue(TiXmlNode* valueNode, int index, UtlSList& params);

   /// Parse an array in the XML-RPC request
   bool parseArray(TiXmlNode* valueNode, UtlSList*& array);

   /// Parse a struct in the XML-RPC request
   bool parseStruct(TiXmlNode* valueNode, UtlHashMap*& memebers);

   /// Clean up the memory in a struct
   void cleanUp(UtlHashMap* members);
   
   /// Clean up the memory in an array
   void cleanUp(UtlSList* array);
   
   /// Http server for handling the HTTP POST request  
   HttpServer* mpHttpServer;
   
   /// hash map for holding all registered XML-RPC methods
   UtlHashMap  mMethods;
   
   /// reader/writer lock for synchronization
   OsBSem mLock;

   /// Disabled copy constructor
   XmlRpcDispatch(const XmlRpcDispatch& rXmlRpcDispatch);

   /// Disabled assignment operator
   XmlRpcDispatch& operator=(const XmlRpcDispatch& rhs);

};

/* ============================ INLINE METHODS ============================ */

#endif  // _XMLRPCDISPATCH_H_


//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _XMLRPCMETHOD_H_
#define _XMLRPCMETHOD_H_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include <utl/UtlString.h>
#include <utl/UtlSList.h>
#include <utl/UtlHashMap.h>
#include <net/HttpRequestContext.h>
#include <net/XmlRpcResponse.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// TYPEDEFS
// FORWARD DECLARATIONS

class XmlRpcDispatch;


/**
 * A XmlRpcMethod is a dynamically loaded object that is invoked by the XmlRpcDispatch
 * during the runtime.
 *
 * This class is the abstract base from which all XML-RPC methods must inherit. Two
 * methods must be implemented by the subclasses:
 * 
 * - get() is for XmlRpcDispatch to instantiate the subclass during the runtime. It
 * is not a singleton class. The XmlRpcMethod derived objects will be deleted after
 * each use in XmlRpcDispatch.
 * 
 * - execute() is for XmlRpcDispatch to execute the XML-RPC request and send back
 * the XmlRpcResponse to the client side.
 * 
 * All the params in the XML-RPC request are stored in a UtlSList and passed to
 * the service in execute(). All the param values are stored in UtlContainable
 * types. The mapping between XML-RPC value types and UtlContainable types is:
 * 
 * - \<i4\> or \<int\> is UtlInt
 * - \<i8\> is UtlLongLongInt
 * - \<boolean\> is UtlBool
 * - \<string\> is UtlString
 * - \<dateTime.iso8601\> is UtlDateTime
 * - \<array\> is UtlSList
 * - \<struct\> is UtlHashMap
 * 
 * \<i8\> is a SIPfoundry extension to XML-RPC that is not compatible with other
 * XML-RPC implementations. 
 * \<double\> and \<base64\> are currently not supported.
 * 
 */

class XmlRpcMethod
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

   typedef enum ExecutionStatus
   {
      OK,
      FAILED,
      REQUIRE_AUTHENTICATION
   } ExecutionStatus;

/* ============================ CREATORS ================================== */

   typedef XmlRpcMethod* Get();
   
   /// Get the instance of this method. Subclasses must provide a definition for this method.
   static XmlRpcMethod* get();
   
   /// Destructor
   virtual ~XmlRpcMethod();

   /// Execute the method. Subclasses must provide a definition for this method.
   virtual bool execute(const HttpRequestContext& requestContext, ///< request context
                        UtlSList& params, ///< request param list
                        void* userData, ///< user data
                        XmlRpcResponse& response, ///< request response
                        ExecutionStatus& status) = 0; ///< execution status

/* ============================ MANIPULATORS ============================== */

/* ============================ ACCESSORS ================================= */


/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

   /// Constructor
   XmlRpcMethod();

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

   /// Disabled copy constructor
   XmlRpcMethod(const XmlRpcMethod& rXmlRpcMethod);

   /// Disabled assignment operator
   XmlRpcMethod& operator=(const XmlRpcMethod& rhs);
   
};

/* ============================ INLINE METHODS ============================ */

#endif  // _XMLRPCMETHOD_H_


//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _XMLRPCREQUEST_H_
#define _XMLRPCREQUEST_H_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include <utl/UtlString.h>
#include <utl/UtlSList.h>
#include <utl/UtlHashMap.h>
#include "net/Url.h"
#include "net/HttpMessage.h"
#include "net/XmlRpcBody.h"
#include "net/XmlRpcResponse.h"

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
const int XML_RPC_TIMEOUT = 5*1000;

// STRUCTS
// TYPEDEFS

// FORWARD DECLARATIONS
class ResultSetRpcTest; // unit test - see sipXcommserverLib/src/test/ResultSetRpcTest.cpp

/**
 * This object is used to create a XML-RPC request to a specific remote XML-RPC
 * server. The caller is required to create this object for each XML-RPC request.
 * 
 * The caller uses the addParam(), addArray() and/or addStruct() functions to 
 * build up XML-RPC request content in XmlRpcBody.
 * 
 * - addParam() is for adding a param in the XmlRpcRequest.
 * 
 * All the param types must be UtlContainable. Here is the mapping from XML-RPC
 * types to UtlContainable types:
 * 
 * * \<i4\> or \<int\> is UtlInt.
 * * \<i8\> is UtlLongLongInt
 * * \<boolean\> is UtlBool.
 * * \<string\> is UtlString.
 * * \<dateTime.iso8601\> is UtlDateTime.
 * * \<array\> is UtlSList.
 * * \<struct\> is UtlHashMap.
 * 
 * \<i8\> is a SIPfoundry extension to XML-RPC that is not compatible with other
 * XML-RPC implementations. 
 * \<double\> and \<base64\> are currently not supported.
 *  
 * The execute() function closes the XML-RPC request frame and sends the
 * request to the remote server specified in the Url. The execute() function
 * receives the XmlRpcResponse from the remote server. If the return is true,
 * the caller can use getResponse() to obtain the response value. If the return
 * is false, the caller can use getFault() in XmlRpcResponse to get the fault
 * code and fault string.
 * 
 */

class XmlRpcRequest
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

   friend class XmlRpcTest;
   
/* ============================ CREATORS ================================== */

   /// Contruct an XML-RPC request for a given method
   XmlRpcRequest(Url& uri, ///< uri type can only be either http or https
                 const char* methodName ///< name of the method in XML-RPC request
                 );

   /// Destructor
   virtual ~XmlRpcRequest();

   /// Execute the named procedure on the remote server.
   bool execute(XmlRpcResponse& response); ///< response returned from the remote server
   /**<
    * @note
    * This is a synchronous (blocking) implementation (execute does not return
    * until it receives a response or an error).
    * 
    * If the return is false, the caller can use response.getFault() to obtain
    * the fault code and fault string.
    * 
    */

/* ============================ MANIPULATORS ============================== */

   /// Add an atomic param to the XML-RPC request
   bool addParam(UtlContainable* value); ///< value for the param
   
/* ============================ ACCESSORS ================================= */


/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:
   friend class ResultSetRpcTest;

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

   /// Url for the XML-RPC request
   Url mUrl;
   /**<
    * Only http or https can be used.
    */
   
   /// client for sending out XML-RPC request
   HttpMessage* mpHttpRequest;
   
   /// XML-RPC body
   XmlRpcBody* mpRequestBody;
    
   /// Disabled copy constructor
   XmlRpcRequest(const XmlRpcRequest& rXmlRpcRequest);

   /// Disabled assignment operator
   XmlRpcRequest& operator=(const XmlRpcRequest& rhs);   
};

/* ============================ INLINE METHODS ============================ */

#endif  // _XMLRPCREQUEST_H_


//
// Copyright (C) 2004-2006 SIPfoundry Inc.
// Licensed by SIPfoundry under the LGPL license.
//
// Copyright (C) 2004-2006 Pingtel Corp.  All rights reserved.
// Licensed to SIPfoundry under a Contributor Agreement.
//
// $$
///////////////////////////////////////////////////////////////////////////////

#ifndef _XMLRPCRESPPONSE_H_
#define _XMLRPCRESPPONSE_H_

// SYSTEM INCLUDES

// APPLICATION INCLUDES
#include <utl/UtlString.h>
#include <utl/UtlSList.h>
#include <xmlparser/tinyxml.h>
#include "net/Url.h"
#include "net/XmlRpcBody.h"

// DEFINES
#define ILL_FORMED_CONTENTS_FAULT_STRING "Ill-formed XML contents"
#define METHOD_NAME_FAULT_STRING "Method name is missing"
#define UNREGISTERED_METHOD_FAULT_STRING "Method has not been registered"
#define AUTHENTICATION_REQUIRED_FAULT_STRING "Authentication is required"
#define EMPTY_PARAM_VALUE_FAULT_STRING "Empty param value"
#define CONNECTION_FAILURE_FAULT_STRING "Connection Failed"

// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS

// for backward compatibility with old #define codes
#define ILL_FORMED_CONTENTS_FAULT_CODE     XmlRpcResponse::IllFormedContents
#define METHOD_NAME_FAULT_CODE             XmlRpcResponse::InvalidMethodName
#define UNREGISTERED_METHOD_FAULT_CODE     XmlRpcResponse::UnregisteredMethod
#define AUTHENTICATION_REQUIRED_FAULT_CODE XmlRpcResponse::AuthenticationRequired
#define EMPTY_PARAM_VALUE_FAULT_CODE       XmlRpcResponse::EmptyParameterValue

// STRUCTS
// TYPEDEFS

// FORWARD DECLARATIONS

/**
 * This object is used to create a XML-RPC response to a XmlRpcRequest request.
 * setResponse() is used for creating the response, and getResponse() is
 * used for getting the value from the request. Furthermore, setFault() is for
 * creating a fault response, and getFault() is used for getting the fault code
 * and fault string in the fault response.
 * 
 */

class XmlRpcResponse
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

/* ============================ CREATORS ================================== */

   /// Contruct a XML-RPC response
   XmlRpcResponse();

   /// Destructor
   virtual ~XmlRpcResponse();

   /// Fault code values.
   typedef enum
      {
         IllFormedContents = -1,      ///< xmlrpc message was not well formed xml
         InvalidMethodName = -2,      ///< name is not syntactically valid
         UnregisteredMethod = -3,     ///< no server found for requested method 
         AuthenticationRequired = -4, ///< request was not properly authenticated
         EmptyParameterValue = -5,    ///< missing value for a required parameter
         ConnectionFailure = -6,      ///< unable to connect to service
         HttpFailure = -7             ///< http returned a non-2xx status
      } FaultCode;
   /**
    * Values used by this subsystem in the fault code;
    * Applications may use these or any integer value.
    */

/* ============================ MANIPULATORS ============================== */

   /// Set the XML-RPC response
   bool setResponse(UtlContainable* value); ///< value for the response

   /// Set the fault code and fault string in a fault response
   bool setFault(int faultCode, const char* faultString);
   /**<
    * This function will create a fault response
    * 
    */

   /// Get the XML-RPC response
   bool getResponse(UtlContainable*& value); ///< value for the param

   /// Get the fault code and fault string from the XML-RPC response
   void getFault(int* faultCode, UtlString& faultString);

   /// Parse the XML-RPC response
   bool parseXmlRpcResponse(UtlString& responseContent); ///< response content from XML-RPC request
   
   /// Get the content of the response
   XmlRpcBody* getBody();
         
/* ============================ ACCESSORS ================================= */


/* ============================ INQUIRY =================================== */

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:

   /// Parse a value in the XML-RPC response
   bool parseValue(TiXmlNode* valueNode);

   /// Parse an array in the XML-RPC response
   bool parseArray(TiXmlNode* valueNode, UtlSList* array);

   /// Parse a struct in the XML-RPC response
   bool parseStruct(TiXmlNode* valueNode, UtlHashMap* memebers);

   // Clean up the memory in a UtlContainable
   void cleanUp(UtlContainable* value);
   
   /// XML-RPC body
   XmlRpcBody* mpResponseBody;

   /// Value for the XML-RPC response
   UtlContainable* mResponseValue;
   
   /// Fault code
   int mFaultCode;
   
   /// Fault string
   UtlString mFaultString;
     
   /// Disabled copy constructor
   XmlRpcResponse(const XmlRpcResponse& rXmlRpcResponse);

   /// Disabled assignment operator
   XmlRpcResponse& operator=(const XmlRpcResponse& rhs);   
};

/* ============================ INLINE METHODS ============================ */

#endif  // _XMLRPCRESPPONSE_H_


